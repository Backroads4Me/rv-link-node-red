[
    {
        "id": "b3d80c5dc947ec88",
        "type": "tab",
        "label": "Home Assistant",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "eb0b5e642ff5aeb2",
        "type": "tab",
        "label": "Encoding",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3470febb2cd6e952",
        "type": "tab",
        "label": "Switches",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7f95345534f00358",
        "type": "tab",
        "label": "Tanks and Batteries",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3e5f038a4f5a8b9a",
        "type": "tab",
        "label": "Status Decode",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "292e70a6ba25b323",
        "type": "tab",
        "label": "Config",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "222c995b7790b8de",
        "type": "tab",
        "label": "Delete HA Entity",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ee904ab46f56578e",
        "type": "tab",
        "label": "HomeKit",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "9cfcca5efde78052",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "RVC Spec",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7e609140970f546c",
            "74c7e4a6cc2508eb",
            "cd670f6465b6374b",
            "c78420a075d43408"
        ],
        "x": 74,
        "y": 39,
        "w": 852,
        "h": 82
    },
    {
        "id": "aea9d97e0563bd83",
        "type": "group",
        "z": "b3d80c5dc947ec88",
        "name": "Home Assistant message routing",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a37da245aba53b96",
            "240ac01d68f44ecf",
            "4ed779099168c76a",
            "a3b957142479c075",
            "73fd777cc2b241ed",
            "8fc64d2211e09bdd"
        ],
        "x": 94,
        "y": 79,
        "w": 812,
        "h": 162
    },
    {
        "id": "3c819b7900145438",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "MQTT",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "19e68bc19dddefb9",
            "cacf35b859af22a9",
            "e7ae35364ce60f3f",
            "4fce77126a105df2",
            "f658418a7b9b4857",
            "b86f82e84d961549",
            "64c5e5cfd4382453",
            "2110ea4d0b85f784",
            "958fed9f12301f59",
            "32add109922d428a",
            "c6fd91cf9695813b",
            "4ad3b304d4f1e27b",
            "d34a8c1fd2cc4320"
        ],
        "x": 74,
        "y": 199,
        "w": 652,
        "h": 382
    },
    {
        "id": "f09f79586501cb0b",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "CAN message routing",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "8d7d5d3ea117cf79",
            "ac47ce53a9fc3f21",
            "698efabc308fece6",
            "a16ce99da6a2a88f",
            "2e131d4d25819c93",
            "a2dad25eb05117f7",
            "fc66c16576e28548",
            "c6fb02a17f709e08",
            "2fcbc4d630144362",
            "a6594a9464d8fe4e",
            "01b53bba61cb7227",
            "9dd6a98018824be9",
            "02bdfc59de71b5a5",
            "37b11a996fc2757e"
        ],
        "x": 74,
        "y": 633,
        "w": 1778,
        "h": 434
    },
    {
        "id": "0b18891888586798",
        "type": "group",
        "z": "ee904ab46f56578e",
        "name": "HomeKit",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "faf503bfdd48519a",
            "107cff91357ef6da",
            "9104e3fb894083ee",
            "b7cc11c60eb56768",
            "7c30a3bc33fa2315",
            "9428382ab57f3f5d",
            "1bf17ae955275cf0"
        ],
        "x": 84,
        "y": 279,
        "w": 942,
        "h": 202
    },
    {
        "id": "eb51c1f2d0d389d1",
        "type": "group",
        "z": "3e5f038a4f5a8b9a",
        "name": "Reset unique STATUS list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ffd5bc5ca5695602",
            "09640adb1fd08fbb",
            "b797e5a52b6db5b4",
            "48e6dda2b2d9575e"
        ],
        "x": 14,
        "y": 619,
        "w": 492,
        "h": 142
    },
    {
        "id": "067069104a82b459",
        "type": "group",
        "z": "7f95345534f00358",
        "name": "Tanks",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d4ef1d361f084b58",
            "61f4573c56915577",
            "6dc4171b23e1cc2a",
            "f9f5381eb086c0e6",
            "b6d3cd6d2e6fbc66",
            "240af7ca01aa2041"
        ],
        "x": 134,
        "y": 99,
        "w": 932,
        "h": 308
    },
    {
        "id": "e2dc4d711cc9dc94",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Switches",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d3a13b531babee66",
            "7313d7c724d31538",
            "f0083147745c8366",
            "fa3a575e55726ee5",
            "828d354cf5dc7635",
            "df501afdd145a6bb",
            "bc789673d06d10ac",
            "48e3b18cb440da52",
            "25162d774c052102"
        ],
        "x": 74,
        "y": 39,
        "w": 1098,
        "h": 408
    },
    {
        "id": "5d1ecae7ac09586c",
        "type": "group",
        "z": "7f95345534f00358",
        "name": "Batteries",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ea29386f9f8682bc",
            "663120adc5ec254f",
            "2c1151c97bb185f2",
            "b6d90639c3fc122c",
            "86fa588a8393f6de",
            "d68c2206e3379850",
            "a1c297b2d8067a0b",
            "64578fa414def60a",
            "2f30b41e1278ef47"
        ],
        "x": 134,
        "y": 539,
        "w": 1072,
        "h": 308
    },
    {
        "id": "04e375b0c463df72",
        "type": "group",
        "z": "222c995b7790b8de",
        "name": "Delete Home Assistant Entity",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "802228bc8d89d80a",
            "a2d2ed96ff4615f9",
            "d38c75bc1474be23",
            "abd1e06a1927df6d"
        ],
        "x": 94,
        "y": 79,
        "w": 592,
        "h": 162
    },
    {
        "id": "852597de52df1703",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "DC_DIMMER_COMMAND_2",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a1beccb1a2803ca5",
            "44947b512cb27b5b",
            "25e6f74b216427e5",
            "000b002344662b42"
        ],
        "x": 74,
        "y": 519,
        "w": 1152,
        "h": 82
    },
    {
        "id": "99bbe464a236c0bb",
        "type": "group",
        "z": "b3d80c5dc947ec88",
        "name": "Switch",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "f1ac757ce0696d47",
            "85de1b537d9b8b35",
            "6aa079d768e1571c"
        ],
        "x": 94,
        "y": 319,
        "w": 572,
        "h": 82
    },
    {
        "id": "ab1d402876612dd8",
        "type": "group",
        "z": "b3d80c5dc947ec88",
        "name": "Switch",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "cd9b46909448f43d",
            "e0c0bb35150de614",
            "7dc76fed7cb91e49"
        ],
        "x": 94,
        "y": 479,
        "w": 572,
        "h": 82
    },
    {
        "id": "01b53bba61cb7227",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique CAN decode list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "1e93f7b73c40091a",
            "38606e245b70b98e",
            "d0150fd6556514e6",
            "8f7381d08bf2b8a8"
        ],
        "x": 1294,
        "y": 899,
        "w": 492,
        "h": 142
    },
    {
        "id": "9dd6a98018824be9",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique UNKNOWN",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a4028527eb23fa04",
            "092c751dcdd12270",
            "c781b519a9f9b156",
            "eea1641469efb23f"
        ],
        "x": 1294,
        "y": 659,
        "w": 532,
        "h": 142
    },
    {
        "id": "b6d3cd6d2e6fbc66",
        "type": "group",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Rest unique tank list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "bfc3dc28b23b2396",
            "d574ead42dd36caa"
        ],
        "x": 174,
        "y": 299,
        "w": 472,
        "h": 82
    },
    {
        "id": "fa3a575e55726ee5",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Rest unique light list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "1f628567c4df0138",
            "393fac7ed2755f3a"
        ],
        "x": 674,
        "y": 339,
        "w": 472,
        "h": 82
    },
    {
        "id": "d68c2206e3379850",
        "type": "group",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "Rest unique battery list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7c04541818436246",
            "738718a321d185e7"
        ],
        "x": 174,
        "y": 739,
        "w": 472,
        "h": 82
    },
    {
        "id": "481f3f804361a6fd",
        "type": "homekit-bridge",
        "bridgeName": "CoachHomekit",
        "pinCode": "4062-3183",
        "port": "",
        "advertiser": "bonjour-hap",
        "allowInsecureRequest": false,
        "manufacturer": "NRCHKB",
        "model": "1.7.3",
        "serialNo": "Default Serial Number",
        "firmwareRev": "1.7.3",
        "hardwareRev": "1.7.3",
        "softwareRev": "1.7.3",
        "bind": "",
        "bindType": "str",
        "customMdnsConfig": false,
        "mdnsMulticast": true,
        "mdnsInterface": "",
        "mdnsPort": "",
        "mdnsIp": "",
        "mdnsTtl": "",
        "mdnsLoopback": true,
        "mdnsReuseAddr": true,
        "allowMessagePassthrough": true
    },
    {
        "id": "80727e60a251c36c",
        "type": "mqtt-broker",
        "name": "Mosquitto",
        "broker": "127.0.0.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a37da245aba53b96",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Decode HA MQTT",
        "func": "const topicParts = msg.topic.split('/');\nif (topicParts.length !== 4) {\n    return null; // unexpected format\n}\n\nconst entityType = topicParts[1];\nconst entityId = topicParts[2];\nconst command = (typeof msg.payload === 'string') ? msg.payload.toUpperCase() : msg.payload;\n\nmsg.entityType = entityType;\nmsg.entityId = entityId;\nmsg.command = command;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 180,
        "wires": [
            [
                "4ed779099168c76a"
            ]
        ]
    },
    {
        "id": "240ac01d68f44ecf",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Home Assistant MQTT In",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 450,
        "y": 120,
        "wires": []
    },
    {
        "id": "4ed779099168c76a",
        "type": "switch",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA Entity Type",
        "property": "entityType",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "switch",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "light",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 610,
        "y": 180,
        "wires": [
            [
                "73fd777cc2b241ed"
            ],
            [
                "8fc64d2211e09bdd"
            ]
        ]
    },
    {
        "id": "a3b957142479c075",
        "type": "link in",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA in",
        "links": [
            "64c5e5cfd4382453"
        ],
        "x": 170,
        "y": 180,
        "wires": [
            [
                "a37da245aba53b96",
                "240ac01d68f44ecf"
            ]
        ],
        "l": true
    },
    {
        "id": "f1ac757ce0696d47",
        "type": "link in",
        "z": "b3d80c5dc947ec88",
        "g": "99bbe464a236c0bb",
        "name": "HA Switch",
        "links": [
            "73fd777cc2b241ed"
        ],
        "x": 180,
        "y": 360,
        "wires": [
            [
                "85de1b537d9b8b35"
            ]
        ],
        "l": true
    },
    {
        "id": "85de1b537d9b8b35",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "99bbe464a236c0bb",
        "name": "Send toggle",
        "func": "// Encodes any HA switch command to an RV-C DC_DIMMER_COMMAND_2 \"Toggle\"\n// Outputs in standard CAN bus format for a 'can/send' topic.\n\n// --- Configuration ---\nconst RVC_COMMAND = 0x05; // 0x05 is the \"Toggle\" command\nconst NON_GROUP = 0xFF;\nconst SOURCE_ADDRESS = 0x81; // A source address for your Node-RED instance (pick one)\nconst PRIORITY = 6;\nconst DGN = \"1FEDB\";\n\n// Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/);\n\nif (!match) {\n    node.warn(`Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`Parsed instance number \"${instance}\" is invalid.`);\n    return null;\n}\n\n// Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = instance;\ndataBytes[1] = NON_GROUP;\ndataBytes[2] = 0xFF; // Desired Level (not used by Toggle, set to Not Available)\ndataBytes[3] = RVC_COMMAND;\ndataBytes[4] = 0;\ndataBytes[5] = 0;\ndataBytes[6] = 0;\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 360,
        "wires": [
            [
                "6aa079d768e1571c"
            ]
        ]
    },
    {
        "id": "6aa079d768e1571c",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "99bbe464a236c0bb",
        "name": "RVC out",
        "mode": "link",
        "links": [
            "b7cc11c60eb56768"
        ],
        "x": 580,
        "y": 360,
        "wires": [],
        "l": true
    },
    {
        "id": "73fd777cc2b241ed",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA Switch",
        "mode": "link",
        "links": [
            "f1ac757ce0696d47"
        ],
        "x": 810,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "8fc64d2211e09bdd",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA Light",
        "mode": "link",
        "links": [
            "cd9b46909448f43d"
        ],
        "x": 800,
        "y": 200,
        "wires": [],
        "l": true
    },
    {
        "id": "cd9b46909448f43d",
        "type": "link in",
        "z": "b3d80c5dc947ec88",
        "g": "ab1d402876612dd8",
        "name": "HA Light",
        "links": [
            "8fc64d2211e09bdd"
        ],
        "x": 180,
        "y": 520,
        "wires": [
            [
                "e0c0bb35150de614"
            ]
        ],
        "l": true
    },
    {
        "id": "e0c0bb35150de614",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "ab1d402876612dd8",
        "name": "Set brightness",
        "func": "// Encodes an HA switch command to an RV-C DC_DIMMER_COMMAND_2\n// Outputs in standard CAN bus format for a 'can/send' topic.\n\n// --- Configuration ---\nconst RVC_COMMAND = 0x00; // 0x00 is \"Set Level\"\nconst LEVEL_ON = 200;\nconst LEVEL_OFF = 0;\nconst NON_GROUP = 0xFF;\nconst SOURCE_ADDRESS = 0x81; // A source address for your Node-RED instance (pick one)\nconst PRIORITY = 6;\nconst DGN = \"1FEDB\";\n\n// Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/);\n\nif (!match) {\n    node.warn(`Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`Parsed instance number \"${instance}\" is invalid.`);\n    return null;\n}\n\n// Determine the desired level from the payload\nlet desiredLevel;\nconst state = msg.payload.toUpperCase();\n\nif (state === \"ON\") {\n    desiredLevel = LEVEL_ON;\n} else if (state === \"OFF\") {\n    desiredLevel = LEVEL_OFF;\n} else {\n    node.warn(`Invalid payload: \"${msg.payload}\". Expected \"ON\" or \"OFF\".`);\n    return null;\n}\n\n// Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = instance;\ndataBytes[1] = NON_GROUP;\ndataBytes[2] = desiredLevel;\ndataBytes[3] = RVC_COMMAND;\ndataBytes[4] = 0;\ndataBytes[5] = 0;\ndataBytes[6] = 0;\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// Construct the CAN ID\n// CAN ID format is: Priority (3 bits) + DGN (18 bits) + Source Address (8 bits)\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 520,
        "wires": [
            [
                "7dc76fed7cb91e49"
            ]
        ]
    },
    {
        "id": "7dc76fed7cb91e49",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "ab1d402876612dd8",
        "name": "RVC out",
        "mode": "link",
        "links": [
            "b7cc11c60eb56768"
        ],
        "x": 580,
        "y": 520,
        "wires": [],
        "l": true
    },
    {
        "id": "0e15072afeb4d46d",
        "type": "function",
        "z": "eb0b5e642ff5aeb2",
        "d": true,
        "name": "Encode DC_DIMMER_COMMAND",
        "func": "// DC_DIMMER Command Encoder - Complete RV-C Implementation\n// Encodes DC_DIMMER_COMMAND messages per RV-C specification\n// Handles lighting control commands for DC_DIMMER devices\n// Input: msg.payload with command parameters\n// Output: msg.payload with encoded CAN message ready for transmission\n\n// === Helper Functions ===\n\nfunction encodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1);\n    return (value & mask) << startBit;\n}\n\nfunction encodeDesiredLevel(value) {\n    // Encode desired level - supports percentages, scenes, and special commands\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 100) {\n            return Math.round(value / 0.5); // 0.5% per step, 0-100%\n        }\n    } else if (typeof value === 'string') {\n        const lowerValue = value.toLowerCase();\n\n        // Handle scene commands\n        const sceneMatch = lowerValue.match(/scene (\\d+)/);\n        if (sceneMatch) {\n            const sceneNum = parseInt(sceneMatch[1]);\n            if (sceneNum >= 1 && sceneNum <= 20) {\n                return 229 + sceneNum; // Scene 1-20 maps to 230-249\n            }\n        }\n\n        // Handle special commands\n        const specialCommands = {\n            'dimmed memory': 250,\n            'master memory': 251,\n            'stop': 252,\n            'no change': 253\n        };\n\n        if (specialCommands[lowerValue] !== undefined) {\n            return specialCommands[lowerValue];\n        }\n    }\n\n    // Default to no change if invalid\n    return 253;\n}\n\nfunction encodeCommand(value) {\n    // Encode command type\n    const commands = {\n        'set level': 0,\n        'set level (delay)': 0,\n        'on': 1,\n        'on (duration)': 1,\n        'on (delay)': 2,\n        'off': 3,\n        'off (delay)': 3,\n        'stop': 4,\n        'toggle': 5,\n        'memory off': 6,\n        'save scene': 7,\n        'ramp brightness': 11,\n        'ramp toggle': 12,\n        'ramp up': 13,\n        'ramp down': 14,\n        'ramp up/down': 15,\n        'ramp up/down toggle': 16,\n        'lock': 21,\n        'unlock': 22,\n        'flash': 31,\n        'flash momentary': 32\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return commands[lowerValue] !== undefined ? commands[lowerValue] : 253; // Default to no change\n}\n\nfunction encodeGroup(value) {\n    // Encode group selection\n    if (typeof value === 'number') {\n        if (value === 0) return 0x00; // All groups\n        if (value >= 1 && value <= 7) {\n            return ~(1 << (value - 1)) & 0x7F; // Invert bit for group membership\n        }\n    } else if (typeof value === 'string') {\n        const lowerValue = value.toLowerCase();\n        if (lowerValue === 'all groups') return 0x00;\n        if (lowerValue === 'non-group') return 0x80;\n        if (lowerValue === 'no data') return 0xFF;\n\n        const groupMatch = lowerValue.match(/group (\\d+)/);\n        if (groupMatch) {\n            const groupNum = parseInt(groupMatch[1]);\n            if (groupNum >= 1 && groupNum <= 7) {\n                return ~(1 << (groupNum - 1)) & 0x7F;\n            }\n        }\n    }\n\n    return 0xFF; // Default to no data\n}\n\nfunction encodeRampTime(value) {\n    // Encode ramp time in 0.1s increments\n    if (typeof value === 'number') {\n        if (value === 0) return 0;\n        if (value > 0 && value <= 25) {\n            return Math.round(value / 0.1); // 0.1s per step\n        }\n    }\n    return 255; // Not available\n}\n\nfunction encodeDuration(value) {\n    // Encode delay/duration\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 240) {\n            return value; // Direct seconds\n        }\n        if (value >= 60 && value <= 600) {\n            const minutes = Math.round(value / 60);\n            if (minutes >= 1 && minutes <= 10) {\n                return 240 + minutes; // 1-10 minutes maps to 241-250\n            }\n        }\n    } else if (typeof value === 'string' && value.toLowerCase() === 'continuous') {\n        return 255;\n    }\n    return 0; // Default to no delay\n}\n\nfunction encodeOnOffDuration(onDuration, offDuration) {\n    // Encode on/off durations in single byte\n    let onValue = 0;\n    let offValue = 0;\n\n    // Encode on duration (bits 0-3)\n    if (typeof onDuration === 'number' && onDuration >= 0 && onDuration <= 15) {\n        onValue = onDuration;\n    }\n\n    // Encode off duration (bits 4-7)\n    if (typeof offDuration === 'number' && offDuration >= 0 && offDuration <= 15) {\n        offValue = offDuration;\n    } else if (typeof offDuration === 'string' && offDuration.toLowerCase() === 'one shot') {\n        offValue = 0;\n    }\n\n    return (offValue << 4) | onValue;\n}\n\n// === Main Encode Function ===\n\nfunction encodeDCDimmerCommand(params) {\n    // Default 8-byte payload filled with 0xFF (not available)\n    const payload = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];\n\n    // Byte 0: Instance (required)\n    if (params.instance !== undefined) {\n        const instance = parseInt(params.instance);\n        if (instance >= 0 && instance <= 200) {\n            payload[0] = instance;\n        }\n    }\n\n    // Byte 1: Command (required)\n    if (params.command !== undefined) {\n        payload[1] = encodeCommand(params.command);\n    }\n\n    // Byte 2: Desired Level\n    if (params.level !== undefined || params.desired_level !== undefined) {\n        const level = params.level !== undefined ? params.level : params.desired_level;\n        payload[2] = encodeDesiredLevel(level);\n    }\n\n    // Byte 3: Ramp Time\n    if (params.ramp_time !== undefined) {\n        payload[3] = encodeRampTime(params.ramp_time);\n    }\n\n    // Byte 4: Group\n    if (params.group !== undefined) {\n        payload[4] = encodeGroup(params.group);\n    }\n\n    // Byte 5: On/Off Duration (combined)\n    if (params.on_duration !== undefined || params.off_duration !== undefined) {\n        payload[5] = encodeOnOffDuration(params.on_duration, params.off_duration);\n    }\n\n    // Byte 6: Delay/Duration\n    if (params.delay !== undefined || params.duration !== undefined) {\n        const delayDuration = params.delay !== undefined ? params.delay : params.duration;\n        payload[6] = encodeDuration(delayDuration);\n    }\n\n    // Byte 7: Reserved (keep as 0xFF)\n\n    return payload;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object with command parameters');\n    return null;\n}\n\nconst params = msg.payload;\n\n// Validate required parameters\nif (params.instance === undefined) {\n    node.warn('Missing required parameter: instance');\n    return null;\n}\n\nif (params.command === undefined) {\n    node.warn('Missing required parameter: command');\n    return null;\n}\n\ntry {\n    // Encode the DC_DIMMER_COMMAND message\n    const dataBytes = encodeDCDimmerCommand(params);\n\n    // Convert to hex string\n    const dataPayload = dataBytes.map(byte =>\n        byte.toString(16).toUpperCase().padStart(2, '0')\n    ).join('');\n\n    // Default DGN for DC_DIMMER_COMMAND\n    const dgn = '1FEDB'; // Standard DGN for DC_DIMMER_COMMAND\n\n    // Prepare output payload\n    msg.payload = {\n        ...params, // Preserve original parameters\n        dgn: dgn,\n        dataPayload: dataPayload,\n        message_type: 'DC_DIMMER_COMMAND',\n        encoded: true\n    };\n\n    return msg;\n\n} catch (error) {\n    node.error(`Failed to encode DC_DIMMER_COMMAND: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "4087127e448ab9ae",
        "type": "function",
        "z": "eb0b5e642ff5aeb2",
        "d": true,
        "name": "Encode FURNACE_COMMAND",
        "func": "// FURNACE_COMMAND Encoder - Complete RV-C Implementation\n// Encodes FURNACE_COMMAND messages per RV-C specification\n// Handles furnace control commands\n// Input: msg.payload with command parameters\n// Output: msg.payload with encoded CAN message ready for transmission\n\n// === Helper Functions ===\n\nfunction encodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1);\n    return (value & mask) << startBit;\n}\n\nfunction encodeFurnaceCommand(value) {\n    // Encode furnace command\n    const commands = {\n        'stop': 0,\n        'start': 1,\n        'reset fault': 2,\n        'test': 3,\n        'service mode': 4\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return commands[lowerValue] !== undefined ? commands[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeFurnaceMode(value) {\n    // Encode furnace operating mode\n    const modes = {\n        'off': 0,\n        'manual': 1,\n        'thermostat': 2,\n        'service': 3,\n        'test': 4\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return modes[lowerValue] !== undefined ? modes[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeHeatLevel(value) {\n    // Encode heat level as percentage\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 100) {\n            return Math.round(value / 0.5); // 0.5% per step\n        }\n    }\n    return 255; // Not available\n}\n\nfunction encodeFanSpeed(value) {\n    // Encode fan speed as percentage\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 100) {\n            return Math.round(value / 0.5); // 0.5% per step\n        }\n    }\n    return 255; // Not available\n}\n\nfunction encodeTimer(value) {\n    // Encode timer in minutes\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 600) {\n            return value;\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodeTemperature(value, isCelsius = false) {\n    // Encode temperature with -40°C offset\n    if (typeof value === 'number') {\n        let tempC = value;\n\n        // Convert Fahrenheit to Celsius if needed\n        if (!isCelsius) {\n            tempC = (value - 32) * 5 / 9;\n        }\n\n        // Apply RV-C encoding: temp + 40\n        const encodedValue = Math.round(tempC + 40);\n\n        if (encodedValue >= 0 && encodedValue <= 210) {\n            return encodedValue;\n        }\n    }\n    return 255; // Not available\n}\n\nfunction encodeUint16(value) {\n    // Encode 16-bit value as two bytes (little-endian)\n    if (typeof value === 'number' && value >= 0 && value <= 65535) {\n        return [value & 0xFF, (value >> 8) & 0xFF];\n    }\n    return [0xFF, 0xFF]; // Not available\n}\n\nfunction encodeFurnaceSettings(params) {\n    // Encode furnace settings in bit field\n    let settings = 0;\n\n    if (params.auto_ignition === true) {\n        settings |= 0x01; // Bit 0: Auto ignition enabled\n    }\n    if (params.altitude_compensation === true) {\n        settings |= 0x02; // Bit 1: Altitude compensation enabled\n    }\n    if (params.safety_lockout_bypass === true) {\n        settings |= 0x04; // Bit 2: Safety lockout bypass enabled\n    }\n    if (params.circulation_fan === true) {\n        settings |= 0x08; // Bit 3: Circulation fan enabled\n    }\n\n    return settings;\n}\n\n// === Main Encode Function ===\n\nfunction encodeFurnaceCommand(params) {\n    // Default 8-byte payload filled with 0xFF (not available)\n    const payload = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];\n\n    // Byte 0: Instance (required)\n    if (params.instance !== undefined) {\n        const instance = parseInt(params.instance);\n        if (instance >= 0 && instance <= 200) {\n            payload[0] = instance;\n        }\n    }\n\n    // Byte 1: Command\n    if (params.command !== undefined) {\n        payload[1] = encodeFurnaceCommand(params.command);\n    }\n\n    // Byte 2: Mode\n    if (params.mode !== undefined || params.operating_mode !== undefined) {\n        const mode = params.mode !== undefined ? params.mode : params.operating_mode;\n        payload[2] = encodeFurnaceMode(mode);\n    }\n\n    // Byte 3: Heat Level\n    if (params.heat_level !== undefined || params.level !== undefined) {\n        const level = params.heat_level !== undefined ? params.heat_level : params.level;\n        payload[3] = encodeHeatLevel(level);\n    }\n\n    // Byte 4: Fan Speed\n    if (params.fan_speed !== undefined) {\n        payload[4] = encodeFanSpeed(params.fan_speed);\n    }\n\n    // Byte 5: Desired Temperature\n    if (params.desired_temperature !== undefined || params.setpoint !== undefined) {\n        const temp = params.desired_temperature !== undefined ? params.desired_temperature : params.setpoint;\n        payload[5] = encodeTemperature(temp, params.celsius || false);\n    }\n\n    // Bytes 6-7: Timer (16-bit, little-endian) or Settings\n    if (params.timer !== undefined || params.run_time !== undefined) {\n        const timer = params.timer !== undefined ? params.timer : params.run_time;\n        const encoded = encodeUint16(encodeTimer(timer));\n        payload[6] = encoded[0];\n        payload[7] = encoded[1];\n    } else if (params.furnace_settings !== undefined ||\n        params.auto_ignition !== undefined ||\n        params.altitude_compensation !== undefined ||\n        params.safety_lockout_bypass !== undefined ||\n        params.circulation_fan !== undefined) {\n        payload[6] = encodeFurnaceSettings(params);\n        // Byte 7 remains 0xFF\n    }\n\n    return payload;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object with command parameters');\n    return null;\n}\n\nconst params = msg.payload;\n\n// Validate required parameters\nif (params.instance === undefined) {\n    node.warn('Missing required parameter: instance');\n    return null;\n}\n\n// At least one command parameter should be provided\nconst hasCommand = params.command !== undefined ||\n    params.mode !== undefined ||\n    params.operating_mode !== undefined ||\n    params.heat_level !== undefined ||\n    params.level !== undefined ||\n    params.fan_speed !== undefined ||\n    params.desired_temperature !== undefined ||\n    params.setpoint !== undefined ||\n    params.timer !== undefined ||\n    params.run_time !== undefined ||\n    params.auto_ignition !== undefined ||\n    params.altitude_compensation !== undefined ||\n    params.safety_lockout_bypass !== undefined ||\n    params.circulation_fan !== undefined;\n\nif (!hasCommand) {\n    node.warn('No command parameters provided (command, mode, heat_level, fan_speed, etc.)');\n    return null;\n}\n\ntry {\n    // Encode the FURNACE_COMMAND message\n    const dataBytes = encodeFurnaceCommand(params);\n\n    // Convert to hex string\n    const dataPayload = dataBytes.map(byte =>\n        byte.toString(16).toUpperCase().padStart(2, '0')\n    ).join('');\n\n    // Default DGN for FURNACE_COMMAND (this should match your RV-C specification)\n    const dgn = '1FEF4'; // Standard DGN for FURNACE_COMMAND\n\n    // Prepare output payload\n    msg.payload = {\n        ...params, // Preserve original parameters\n        dgn: dgn,\n        dataPayload: dataPayload,\n        message_type: 'FURNACE_COMMAND',\n        encoded: true\n    };\n\n    return msg;\n\n} catch (error) {\n    node.error(`Failed to encode FURNACE_COMMAND: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "d68a4bae129db753",
        "type": "function",
        "z": "eb0b5e642ff5aeb2",
        "d": true,
        "name": "Encode GENERATOR_COMMAND",
        "func": "// GENERATOR_COMMAND Encoder - Complete RV-C Implementation\n// Encodes GENERATOR_COMMAND messages per RV-C specification\n// Handles generator control commands\n// Input: msg.payload with command parameters\n// Output: msg.payload with encoded CAN message ready for transmission\n\n// === Helper Functions ===\n\nfunction encodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1);\n    return (value & mask) << startBit;\n}\n\nfunction encodeGeneratorCommand(value) {\n    // Encode generator command\n    const commands = {\n        'stop': 0,\n        'start': 1,\n        'exercise': 2,\n        'test': 3,\n        'prime': 4,\n        'pre-heat': 5,\n        'reset fault': 6,\n        'clear maintenance': 7\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return commands[lowerValue] !== undefined ? commands[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeGeneratorMode(value) {\n    // Encode generator operating mode\n    const modes = {\n        'off': 0,\n        'auto': 1,\n        'manual': 2,\n        'exercise': 3,\n        'test': 4,\n        'maintenance': 5\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return modes[lowerValue] !== undefined ? modes[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeLoadPriority(value) {\n    // Encode load priority\n    const priorities = {\n        'none': 0,\n        'low': 1,\n        'medium': 2,\n        'high': 3,\n        'critical': 4\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return priorities[lowerValue] !== undefined ? priorities[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeTimer(value) {\n    // Encode timer in minutes\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 600) {\n            return value;\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodeRPM(value) {\n    // Encode RPM with 4 RPM resolution\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 64000) {\n            return Math.round(value / 4); // 4 RPM per step\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodePercentage(value) {\n    // Encode percentage with 0.5% resolution\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 100) {\n            return Math.round(value / 0.5); // 0.5% per step\n        }\n    }\n    return 255; // Not available\n}\n\nfunction encodeUint16(value) {\n    // Encode 16-bit value as two bytes (little-endian)\n    if (typeof value === 'number' && value >= 0 && value <= 65535) {\n        return [value & 0xFF, (value >> 8) & 0xFF];\n    }\n    return [0xFF, 0xFF]; // Not available\n}\n\nfunction encodeExerciseSettings(params) {\n    // Encode exercise settings in bit field\n    let settings = 0;\n\n    if (params.weekly_exercise === true) {\n        settings |= 0x01; // Bit 0: Weekly exercise enabled\n    }\n    if (params.monthly_exercise === true) {\n        settings |= 0x02; // Bit 1: Monthly exercise enabled\n    }\n    if (params.auto_start === true) {\n        settings |= 0x04; // Bit 2: Auto start enabled\n    }\n    if (params.load_test === true) {\n        settings |= 0x08; // Bit 3: Load test enabled\n    }\n\n    return settings;\n}\n\n// === Main Encode Function ===\n\nfunction encodeGeneratorCommand(params) {\n    // Default 8-byte payload filled with 0xFF (not available)\n    const payload = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];\n\n    // Byte 0: Instance (required)\n    if (params.instance !== undefined) {\n        const instance = parseInt(params.instance);\n        if (instance >= 0 && instance <= 200) {\n            payload[0] = instance;\n        }\n    }\n\n    // Byte 1: Command\n    if (params.command !== undefined) {\n        payload[1] = encodeGeneratorCommand(params.command);\n    }\n\n    // Byte 2: Mode\n    if (params.mode !== undefined || params.operating_mode !== undefined) {\n        const mode = params.mode !== undefined ? params.mode : params.operating_mode;\n        payload[2] = encodeGeneratorMode(mode);\n    }\n\n    // Byte 3: Load Priority or Load Level\n    if (params.load_priority !== undefined) {\n        payload[3] = encodeLoadPriority(params.load_priority);\n    } else if (params.load_level !== undefined) {\n        payload[3] = encodePercentage(params.load_level);\n    }\n\n    // Bytes 4-5: Timer (16-bit, little-endian)\n    if (params.timer !== undefined || params.run_time !== undefined) {\n        const timer = params.timer !== undefined ? params.timer : params.run_time;\n        const encoded = encodeUint16(encodeTimer(timer));\n        payload[4] = encoded[0];\n        payload[5] = encoded[1];\n    }\n\n    // Bytes 6-7: RPM or Exercise Settings\n    if (params.desired_rpm !== undefined || params.rpm !== undefined) {\n        const rpm = params.desired_rpm !== undefined ? params.desired_rpm : params.rpm;\n        const encoded = encodeUint16(encodeRPM(rpm));\n        payload[6] = encoded[0];\n        payload[7] = encoded[1];\n    } else if (params.exercise_settings !== undefined ||\n        params.weekly_exercise !== undefined ||\n        params.monthly_exercise !== undefined ||\n        params.auto_start !== undefined ||\n        params.load_test !== undefined) {\n        payload[6] = encodeExerciseSettings(params);\n        // Byte 7 remains 0xFF\n    }\n\n    return payload;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object with command parameters');\n    return null;\n}\n\nconst params = msg.payload;\n\n// Validate required parameters\nif (params.instance === undefined) {\n    node.warn('Missing required parameter: instance');\n    return null;\n}\n\n// At least one command parameter should be provided\nconst hasCommand = params.command !== undefined ||\n    params.mode !== undefined ||\n    params.operating_mode !== undefined ||\n    params.load_priority !== undefined ||\n    params.load_level !== undefined ||\n    params.timer !== undefined ||\n    params.run_time !== undefined ||\n    params.desired_rpm !== undefined ||\n    params.rpm !== undefined ||\n    params.weekly_exercise !== undefined ||\n    params.monthly_exercise !== undefined ||\n    params.auto_start !== undefined ||\n    params.load_test !== undefined;\n\nif (!hasCommand) {\n    node.warn('No command parameters provided (command, mode, load_priority, timer, etc.)');\n    return null;\n}\n\ntry {\n    // Encode the GENERATOR_COMMAND message\n    const dataBytes = encodeGeneratorCommand(params);\n\n    // Convert to hex string\n    const dataPayload = dataBytes.map(byte =>\n        byte.toString(16).toUpperCase().padStart(2, '0')\n    ).join('');\n\n    // Default DGN for GENERATOR_COMMAND (this should match your RV-C specification)\n    const dgn = '1FED9'; // Standard DGN for GENERATOR_COMMAND\n\n    // Prepare output payload\n    msg.payload = {\n        ...params, // Preserve original parameters\n        dgn: dgn,\n        dataPayload: dataPayload,\n        message_type: 'GENERATOR_COMMAND',\n        encoded: true\n    };\n\n    return msg;\n\n} catch (error) {\n    node.error(`Failed to encode GENERATOR_COMMAND: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "91034676e3b8a5c3",
        "type": "function",
        "z": "eb0b5e642ff5aeb2",
        "d": true,
        "name": "Encode THERMOSTAT_COMMAND",
        "func": "// THERMOSTAT_COMMAND Encoder - Complete RV-C Implementation\n// Encodes THERMOSTAT_COMMAND messages per RV-C specification\n// Handles HVAC thermostat control commands\n// Input: msg.payload with command parameters\n// Output: msg.payload with encoded CAN message ready for transmission\n\n// === Helper Functions ===\n\nfunction encodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1);\n    return (value & mask) << startBit;\n}\n\nfunction encodeOperatingMode(value) {\n    // Encode operating mode\n    const modes = {\n        'off': 0,\n        'auto': 1,\n        'heat': 2,\n        'cool': 3,\n        'furnace': 4,\n        'fan only': 5,\n        'dry': 6,\n        'emergency heat': 7\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return modes[lowerValue] !== undefined ? modes[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeFanMode(value) {\n    // Encode fan mode\n    const fanModes = {\n        'auto': 0,\n        'on': 1,\n        'low': 2,\n        'medium': 3,\n        'high': 4\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return fanModes[lowerValue] !== undefined ? fanModes[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeSetpoint(value, isCelsius = false) {\n    // Encode temperature setpoint with 0.5°C resolution\n    if (typeof value === 'number') {\n        let tempC = value;\n\n        // Convert Fahrenheit to Celsius if needed\n        if (!isCelsius) {\n            tempC = (value - 32) * 5 / 9;\n        }\n\n        // Apply RV-C encoding: (temp + 40) / 0.5\n        const encodedValue = Math.round((tempC + 40) / 0.5);\n\n        if (encodedValue >= 0 && encodedValue <= 500) {\n            return encodedValue;\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodeScheduleMode(value) {\n    // Encode schedule mode\n    const scheduleModes = {\n        'manual': 0,\n        'program 1': 1,\n        'program 2': 2,\n        'program 3': 3,\n        'program 4': 4,\n        'vacation': 5,\n        'hold': 6\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return scheduleModes[lowerValue] !== undefined ? scheduleModes[lowerValue] : 255; // Default to not available\n}\n\nfunction encodeCommand(value) {\n    // Encode thermostat command\n    const commands = {\n        'no command': 0,\n        'mode change': 1,\n        'setpoint change': 2,\n        'fan change': 3,\n        'schedule change': 4,\n        'reset': 5,\n        'test': 6,\n        'calibrate': 7\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return commands[lowerValue] !== undefined ? commands[lowerValue] : 0; // Default to no command\n}\n\nfunction encodeUint16(value) {\n    // Encode 16-bit value as two bytes (little-endian)\n    if (typeof value === 'number' && value >= 0 && value <= 65535) {\n        return [value & 0xFF, (value >> 8) & 0xFF];\n    }\n    return [0xFF, 0xFF]; // Not available\n}\n\n// === Main Encode Function ===\n\nfunction encodeThermostatCommand(params) {\n    // Default 8-byte payload filled with 0xFF (not available)\n    const payload = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];\n\n    // Byte 0: Instance (required)\n    if (params.instance !== undefined) {\n        const instance = parseInt(params.instance);\n        if (instance >= 0 && instance <= 200) {\n            payload[0] = instance;\n        }\n    }\n\n    // Byte 1: Command\n    if (params.command !== undefined) {\n        payload[1] = encodeCommand(params.command);\n    }\n\n    // Byte 2: Operating Mode\n    if (params.operating_mode !== undefined || params.mode !== undefined) {\n        const mode = params.operating_mode !== undefined ? params.operating_mode : params.mode;\n        payload[2] = encodeOperatingMode(mode);\n    }\n\n    // Byte 3: Fan Mode\n    if (params.fan_mode !== undefined) {\n        payload[3] = encodeFanMode(params.fan_mode);\n    }\n\n    // Bytes 4-5: Heat Setpoint (16-bit, little-endian)\n    if (params.heat_setpoint !== undefined) {\n        const encoded = encodeUint16(encodeSetpoint(params.heat_setpoint, params.celsius || false));\n        payload[4] = encoded[0];\n        payload[5] = encoded[1];\n    }\n\n    // Bytes 6-7: Cool Setpoint (16-bit, little-endian) OR Schedule Mode in byte 6\n    if (params.cool_setpoint !== undefined) {\n        const encoded = encodeUint16(encodeSetpoint(params.cool_setpoint, params.celsius || false));\n        payload[6] = encoded[0];\n        payload[7] = encoded[1];\n    } else if (params.schedule_mode !== undefined) {\n        payload[6] = encodeScheduleMode(params.schedule_mode);\n        // Byte 7 remains 0xFF\n    }\n\n    return payload;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object with command parameters');\n    return null;\n}\n\nconst params = msg.payload;\n\n// Validate required parameters\nif (params.instance === undefined) {\n    node.warn('Missing required parameter: instance');\n    return null;\n}\n\n// At least one command parameter should be provided\nconst hasCommand = params.operating_mode !== undefined ||\n    params.mode !== undefined ||\n    params.fan_mode !== undefined ||\n    params.heat_setpoint !== undefined ||\n    params.cool_setpoint !== undefined ||\n    params.schedule_mode !== undefined;\n\nif (!hasCommand) {\n    node.warn('No command parameters provided (operating_mode, fan_mode, setpoints, etc.)');\n    return null;\n}\n\ntry {\n    // Encode the THERMOSTAT_COMMAND message\n    const dataBytes = encodeThermostatCommand(params);\n\n    // Convert to hex string\n    const dataPayload = dataBytes.map(byte =>\n        byte.toString(16).toUpperCase().padStart(2, '0')\n    ).join('');\n\n    // Default DGN for THERMOSTAT_COMMAND (this should match your RV-C specification)\n    const dgn = '1FEF9'; // Standard DGN for THERMOSTAT_COMMAND\n\n    // Prepare output payload\n    msg.payload = {\n        ...params, // Preserve original parameters\n        dgn: dgn,\n        dataPayload: dataPayload,\n        message_type: 'THERMOSTAT_COMMAND',\n        encoded: true\n    };\n\n    return msg;\n\n} catch (error) {\n    node.error(`Failed to encode THERMOSTAT_COMMAND: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "677051accc16a4a6",
        "type": "function",
        "z": "eb0b5e642ff5aeb2",
        "d": true,
        "name": "Encode WATER_PUMP_COMMAND",
        "func": "// WATER_PUMP_COMMAND Encoder - Complete RV-C Implementation\n// Encodes WATER_PUMP_COMMAND messages per RV-C specification\n// Handles water pump control commands\n// Input: msg.payload with command parameters\n// Output: msg.payload with encoded CAN message ready for transmission\n\n// === Helper Functions ===\n\nfunction encodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1);\n    return (value & mask) << startBit;\n}\n\nfunction encodePumpCommand(value) {\n    // Encode pump command\n    const commands = {\n        'stop': 0,\n        'start': 1,\n        'auto': 2,\n        'manual': 3,\n        'prime': 4,\n        'test': 5,\n        'reset fault': 6\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return commands[lowerValue] !== undefined ? commands[lowerValue] : 255; // Default to not available\n}\n\nfunction encodePumpSpeed(value) {\n    // Encode pump speed as percentage\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 100) {\n            return Math.round(value / 0.5); // 0.5% per step\n        }\n    }\n    return 255; // Not available\n}\n\nfunction encodePressure(value) {\n    // Encode pressure in kPa with 0.5 kPa resolution\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 250) {\n            return Math.round(value / 0.5); // 0.5 kPa per step\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodeFlowRate(value) {\n    // Encode flow rate in L/min with 0.1 L/min resolution\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 650) {\n            return Math.round(value / 0.1); // 0.1 L/min per step\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodeTimer(value) {\n    // Encode timer in minutes\n    if (typeof value === 'number') {\n        if (value >= 0 && value <= 600) {\n            return value;\n        }\n    }\n    return 65535; // Not available\n}\n\nfunction encodeUint16(value) {\n    // Encode 16-bit value as two bytes (little-endian)\n    if (typeof value === 'number' && value >= 0 && value <= 65535) {\n        return [value & 0xFF, (value >> 8) & 0xFF];\n    }\n    return [0xFF, 0xFF]; // Not available\n}\n\nfunction encodePumpMode(value) {\n    // Encode pump operating mode\n    const modes = {\n        'off': 0,\n        'auto': 1,\n        'manual': 2,\n        'prime': 3,\n        'bypass': 4,\n        'test': 5\n    };\n\n    const lowerValue = value.toString().toLowerCase();\n    return modes[lowerValue] !== undefined ? modes[lowerValue] : 255; // Default to not available\n}\n\n// === Main Encode Function ===\n\nfunction encodeWaterPumpCommand(params) {\n    // Default 8-byte payload filled with 0xFF (not available)\n    const payload = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];\n\n    // Byte 0: Instance (required)\n    if (params.instance !== undefined) {\n        const instance = parseInt(params.instance);\n        if (instance >= 0 && instance <= 200) {\n            payload[0] = instance;\n        }\n    }\n\n    // Byte 1: Command\n    if (params.command !== undefined) {\n        payload[1] = encodePumpCommand(params.command);\n    }\n\n    // Byte 2: Mode\n    if (params.mode !== undefined) {\n        payload[2] = encodePumpMode(params.mode);\n    }\n\n    // Byte 3: Speed\n    if (params.speed !== undefined || params.pump_speed !== undefined) {\n        const speed = params.speed !== undefined ? params.speed : params.pump_speed;\n        payload[3] = encodePumpSpeed(speed);\n    }\n\n    // Bytes 4-5: Desired Pressure (16-bit, little-endian)\n    if (params.desired_pressure !== undefined || params.pressure !== undefined) {\n        const pressure = params.desired_pressure !== undefined ? params.desired_pressure : params.pressure;\n        const encoded = encodeUint16(encodePressure(pressure));\n        payload[4] = encoded[0];\n        payload[5] = encoded[1];\n    }\n\n    // Bytes 6-7: Timer or Flow Rate (16-bit, little-endian)\n    if (params.timer !== undefined) {\n        const encoded = encodeUint16(encodeTimer(params.timer));\n        payload[6] = encoded[0];\n        payload[7] = encoded[1];\n    } else if (params.desired_flow_rate !== undefined || params.flow_rate !== undefined) {\n        const flowRate = params.desired_flow_rate !== undefined ? params.desired_flow_rate : params.flow_rate;\n        const encoded = encodeUint16(encodeFlowRate(flowRate));\n        payload[6] = encoded[0];\n        payload[7] = encoded[1];\n    }\n\n    return payload;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object with command parameters');\n    return null;\n}\n\nconst params = msg.payload;\n\n// Validate required parameters\nif (params.instance === undefined) {\n    node.warn('Missing required parameter: instance');\n    return null;\n}\n\n// At least one command parameter should be provided\nconst hasCommand = params.command !== undefined ||\n    params.mode !== undefined ||\n    params.speed !== undefined ||\n    params.pump_speed !== undefined ||\n    params.desired_pressure !== undefined ||\n    params.pressure !== undefined ||\n    params.timer !== undefined ||\n    params.desired_flow_rate !== undefined ||\n    params.flow_rate !== undefined;\n\nif (!hasCommand) {\n    node.warn('No command parameters provided (command, mode, speed, pressure, etc.)');\n    return null;\n}\n\ntry {\n    // Encode the WATER_PUMP_COMMAND message\n    const dataBytes = encodeWaterPumpCommand(params);\n\n    // Convert to hex string\n    const dataPayload = dataBytes.map(byte =>\n        byte.toString(16).toUpperCase().padStart(2, '0')\n    ).join('');\n\n    // Default DGN for WATER_PUMP_COMMAND (this should match your RV-C specification)\n    const dgn = '1FEF6'; // Standard DGN for WATER_PUMP_COMMAND\n\n    // Prepare output payload\n    msg.payload = {\n        ...params, // Preserve original parameters\n        dgn: dgn,\n        dataPayload: dataPayload,\n        message_type: 'WATER_PUMP_COMMAND',\n        encoded: true\n    };\n\n    return msg;\n\n} catch (error) {\n    node.error(`Failed to encode WATER_PUMP_COMMAND: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "d3a13b531babee66",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "MQTT Out",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1050,
        "y": 200,
        "wires": [],
        "l": true
    },
    {
        "id": "7313d7c724d31538",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "DC_DIMMER_STATUS",
        "links": [
            "2f9602cc8a3d1649"
        ],
        "x": 200,
        "y": 140,
        "wires": [
            [
                "828d354cf5dc7635"
            ]
        ],
        "l": true
    },
    {
        "id": "f0083147745c8366",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unique lights",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueLights = flow.get(\"uniqueLights\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.instance);\n\n// Check if it's a new unique message\nif (!uniqueLights.includes(newMsgStr)) {\n    uniqueLights.push(newMsgStr);\n    flow.set(\"uniqueLights\", uniqueLights);\n\n    // Create a new msg with only payload\n    return { payload: msg.payload.instance };\n}\n\n// Return nothing if duplicate\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 260,
        "wires": [
            [
                "25162d774c052102"
            ]
        ]
    },
    {
        "id": "1f628567c4df0138",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "fa3a575e55726ee5",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 790,
        "y": 380,
        "wires": [
            [
                "393fac7ed2755f3a"
            ]
        ]
    },
    {
        "id": "393fac7ed2755f3a",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "fa3a575e55726ee5",
        "name": "Reset function",
        "func": "flow.set(\"uniqueLights\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "828d354cf5dc7635",
        "type": "switch",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 410,
        "y": 140,
        "wires": [
            [
                "df501afdd145a6bb"
            ],
            [
                "bc789673d06d10ac"
            ],
            [
                "f0083147745c8366",
                "48e3b18cb440da52"
            ]
        ]
    },
    {
        "id": "df501afdd145a6bb",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "DC_DIMMER_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 80,
        "wires": []
    },
    {
        "id": "bc789673d06d10ac",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "DC_DIMMER_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 140,
        "wires": []
    },
    {
        "id": "48e3b18cb440da52",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Switch status",
        "func": "/***********************************************************\n * HA Switch Status Updater\n * * Takes a JSON payload as input and sends an ON/OFF status\n * update to the correct Home Assistant MQTT state topic.\n * * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The ID of the light.\n * - msg.payload.load_status (String): Status text, e.g., \"Off (status=0)\".\n ***********************************************************/\n\n\nif (typeof msg.payload.instance !== 'number' || typeof msg.payload.load_status !== 'string') {\n    node.error(\"Input missing 'instance' (number) or 'load_status' (string).\", msg);\n    return null; // Stop the flow\n}\n\nconst instance = msg.payload.instance;\n\nconst haStatus = msg.payload.load_status.includes(\"Off\") ? \"OFF\" : \"ON\";\n\nconst stateTopic = `homeassistant/switch/switch_${instance}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = haStatus; // The payload is just the string \"ON\" or \"OFF\"\nmsg.retain = true;    // Retain the status so HA shows the correct state after a restart\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 200,
        "wires": [
            [
                "d3a13b531babee66"
            ]
        ]
    },
    {
        "id": "25162d774c052102",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create Switch",
        "func": "/***********************************************************\n * Simple Switch MQTT Discovery for Home Assistant\n * * Creates a switch entity based on a numeric input.\n * Expects msg.payload to be a number (e.g., 101).\n * * Example Input: msg.payload = 101\n * Resulting Entity ID: light_101\n ***********************************************************/\n\n\nif (typeof msg.payload !== 'number') {\n    node.error(\"Input payload must be a number.\", msg);\n    return null; // Stop the flow if the input is not a number\n}\n\n\nconst entityId = `switch_${msg.payload}`;\nconst displayName = `Switch ${msg.payload}`;\nconst componentType = \"switch\";\n\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    object_id: entityId,\n    icon: \"mdi:light-recessed\",\n\n    // Topics for Home Assistant to use\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n\n    // Define what \"ON\" and \"OFF\" look like\n    payload_on: \"ON\",\n    payload_off: \"OFF\"\n};\n\n// 5. Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 260,
        "wires": [
            [
                "d3a13b531babee66"
            ]
        ]
    },
    {
        "id": "a1beccb1a2803ca5",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "852597de52df1703",
        "name": "Decode DC_DIMMER_COMMAND_2",
        "func": "// === Main Decode Function (Updated for July 31, 2025 Spec) ===\nfunction decodeDcDimmerCommand2Message(dgn, data) {\n    const result = {};\n    if (data.length < 7) return { error: \"Invalid data length for DGN 1FEDBh\" };\n\n    // Byte 0: Instance\n    result.instance = data[0]; // [cite: 269]\n\n    // Byte 1: Group (bitmap)\n    const groupDetails = getGroupDetails(data[1]); // [cite: 269]\n    result.group_description = groupDetails.description;\n    \n    // Byte 2: Desired Level\n    result.desired_level = decodeDesiredLevel(data[2]); // [cite: 269]\n    \n    // Byte 3: Command\n    result.command = decodeCommand(data[3]); // [cite: 269]\n    \n    // --- UPDATED SECTION ---\n    \n    // Byte 4: Delay/Duration\n    result.delay_duration = decodeDelayDuration(data[4]); // \n    \n    // Byte 5: Interlock\n    const interlockValue = decodeBits(data[5], 0, 1); // \n    const interlocks = { 0: \"No Interlock active\", 1: \"Interlock A\", 2: \"Interlock B\" };\n    result.interlock = interlocks[interlockValue] || \"Invalid\";\n\n    // Byte 6: Ramp Time\n    result.ramp_time = decodeRampTime(data[6]); // \n    \n    // --- END UPDATED SECTION ---\n    \n    return result;\n}\n\n// === Full Node-RED Function (with all helpers) ===\n\n// Helper Functions (assumed to be correct from previous versions)\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\nfunction decodeRampTime(value) {\n    if (value === 0) return 0;\n    if (value >= 1 && value <= 250) return parseFloat((value * 0.1).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\nfunction decodeDesiredLevel(value) {\n    if (value >= 0 && value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value >= 230 && value <= 249) return `Scene ${value - 229}`;\n    if (value === 250) return \"Dimmed Memory\";\n    if (value === 251) return \"Master Memory\";\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\nfunction getGroupDetails(value) {\n    if (value === 0xFF) return { type: 'special', description: 'No data' };\n    if (value & 0x80) return { type: 'non-group', description: 'Non-group or Node Group command' };\n    if (value === 0x00) return { type: 'special', description: 'Member of all groups' };\n    const groups = []; const groupBits = value & 0x7F;\n    for (let bit = 0; bit < 7; bit++) { if (!(groupBits & (1 << bit))) { groups.push(bit + 1); } }\n    return { type: 'standard', groups: groups, description: groups.length > 0 ? `Groups: ${groups.join(', ')}` : \"No group membership\"};\n}\nfunction decodeDelayDuration(value) {\n    if (value >= 0 && value <= 240) return `${value} seconds`;\n    if (value >= 241 && value <= 250) return `${value - 236} minutes`;\n    if (value === 255) return \"Continuous\";\n    return \"Invalid\";\n}\nfunction decodeCommand(value) {\n    const commands = { 0: \"Set Level (Delay)\", 1: \"On (Duration)\", 2: \"On (Delay)\", 3: \"Off (Delay)\", 4: \"Stop\", 5: \"Toggle\", 6: \"Memory Off\", 7: \"Save Scene\", 11: \"Ramp Brightness\", 12: \"Ramp Toggle\", 13: \"Ramp Up\", 14: \"Ramp Down\", 15: \"Ramp Up/Down\", 16: \"Ramp Up/Down Toggle\", 21: \"Lock\", 22: \"Unlock\", 31: \"Flash\", 32: \"Flash Momentary\" };\n    return commands[value] || `unknown command: ${value}`;\n}\n\n// Main Decode Function (Updated for July 31, 2025 Spec)\nfunction decodeDcDimmerCommand2Message(dgn, data) {\n    const result = {};\n    if (data.length < 7) return { error: \"Invalid data length for DGN 1FEDBh\" };\n    result.instance = data[0]; // [cite: 269]\n    const groupDetails = getGroupDetails(data[1]); // [cite: 269]\n    result.group_description = groupDetails.description;\n    result.desired_level = decodeDesiredLevel(data[2]); // [cite: 269]\n    result.command = decodeCommand(data[3]); // [cite: 269]\n    result.delay_duration = decodeDelayDuration(data[4]); // \n    const interlockValue = decodeBits(data[5], 0, 1); // \n    const interlocks = { 0: \"No Interlock active\", 1: \"Interlock A\", 2: \"Interlock B\" };\n    result.interlock = interlocks[interlockValue] || \"Invalid\";\n    result.ramp_time = decodeRampTime(data[6]); // \n    return result;\n}\n\n// === Main Logic ===\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(dataPayload.substring(i, i + 2), 16));\n}\n\nlet decodedData;\nif (dgn === '1FEDB') {\n    decodedData = decodeDcDimmerCommand2Message(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\nmsg.payload = { ...incomingPayload, ...decodedData };\ndelete msg.payload.dataPayload;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 560,
        "wires": [
            [
                "000b002344662b42"
            ]
        ]
    },
    {
        "id": "44947b512cb27b5b",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "852597de52df1703",
        "name": "DC_DIMMER_COMMAND_2",
        "links": [
            "37b11a996fc2757e"
        ],
        "x": 220,
        "y": 560,
        "wires": [
            [
                "a1beccb1a2803ca5"
            ]
        ],
        "l": true
    },
    {
        "id": "25e6f74b216427e5",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "852597de52df1703",
        "name": " DC_DIMMER_COMMAND_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 560,
        "wires": []
    },
    {
        "id": "000b002344662b42",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "852597de52df1703",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "payload.instance",
        "x": 830,
        "y": 560,
        "wires": [
            [
                "25e6f74b216427e5"
            ]
        ]
    },
    {
        "id": "d4ef1d361f084b58",
        "type": "link out",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "MQTT Out",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 970,
        "y": 220,
        "wires": [],
        "l": true
    },
    {
        "id": "61f4573c56915577",
        "type": "link in",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "TANK_STATUS",
        "links": [
            "45ae070eafc9a732"
        ],
        "x": 240,
        "y": 140,
        "wires": [
            [
                "6dc4171b23e1cc2a",
                "240af7ca01aa2041"
            ]
        ],
        "l": true
    },
    {
        "id": "6dc4171b23e1cc2a",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Tank Level",
        "func": "// Only send output if relative_level is available\nif (msg.relative_level === \"Not Available\" || msg.payload?.relative_level === \"Not Available\") {\n    return null;  // stops the flow\n}\n\n// Extract values\nlet type = msg.tank_type || msg.payload?.tank_type;\nlet level = msg.level_percentage ?? msg.payload?.level_percentage;\n\n// Build MQTT message\nmsg.payload = level;\nmsg.topic = `homeassistant/sensor/${type}/state`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 140,
        "wires": [
            [
                "d4ef1d361f084b58"
            ]
        ]
    },
    {
        "id": "f9f5381eb086c0e6",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Create Tank",
        "func": "const displayName = msg.payload;\nconst unit = \"%\"; // Unit for the gauge\n\nconst entityId = displayName.toLowerCase().replace(/\\s+/g, '_'); // normalize name\nconst discoveryTopic = `homeassistant/sensor/${entityId}/config`;\nconst stateTopic = `homeassistant/sensor/${entityId}/state`;\n\nconst payload = {\n    name: displayName,\n    state_topic: stateTopic,\n    unit_of_measurement: unit,\n    // device_class: deviceClass, // optional\n    icon: \"mdi:water-percent\",   // 👈 Custom icon\n    value_template: \"{{ value | float }}\", // Ensure it's parsed as a number\n    unique_id: entityId\n};\n\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 220,
        "wires": [
            [
                "d4ef1d361f084b58"
            ]
        ]
    },
    {
        "id": "bfc3dc28b23b2396",
        "type": "inject",
        "z": "7f95345534f00358",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 300,
        "y": 340,
        "wires": [
            [
                "d574ead42dd36caa"
            ]
        ]
    },
    {
        "id": "d574ead42dd36caa",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset function",
        "func": "flow.set(\"uniqueTanks\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "ea29386f9f8682bc",
        "type": "link out",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "MQTT Out",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1110,
        "y": 660,
        "wires": [],
        "l": true
    },
    {
        "id": "663120adc5ec254f",
        "type": "link in",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS",
        "links": [
            "bff245b2ca47ef79"
        ],
        "x": 260,
        "y": 580,
        "wires": [
            [
                "a1c297b2d8067a0b"
            ]
        ],
        "l": true
    },
    {
        "id": "2c1151c97bb185f2",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "Battery Level",
        "func": "// Only send output if relative_level is available\nif (msg.dc_voltage === \"Not Available\" || msg.payload?.dc_voltage === \"Not Available\") {\n    return null;  // stops the flow\n}\n\n// Extract values\nlet type = msg.dc_instance_id || msg.payload?.dc_instance_id;\nlet level = msg.dc_voltage_V ?? msg.payload?.dc_voltage_V;\n\n// Build MQTT message\nmsg.payload = level;\nmsg.topic = `homeassistant/sensor/battery_${type}/state`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 580,
        "wires": [
            [
                "ea29386f9f8682bc"
            ]
        ]
    },
    {
        "id": "b6d90639c3fc122c",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "Unique batteries",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueBatteries = flow.get(\"uniqueBatteries\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dc_instance_id);\n\n// Check if it's a new unique message\nif (!uniqueBatteries.includes(newMsgStr)) {\n    uniqueBatteries.push(newMsgStr);\n    flow.set(\"uniqueBatteries\", uniqueBatteries);\n\n    // Create a new msg with only payload\n    return { payload: msg.payload.dc_instance_id };\n}\n\n// Return nothing if duplicate\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 660,
        "wires": [
            [
                "86fa588a8393f6de"
            ]
        ]
    },
    {
        "id": "86fa588a8393f6de",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "Create Battery",
        "func": "const unit = \"V\"; // Unit for the gauge\nconst deviceClass = \"voltage\"; // Can be \"battery\", \"humidity\", etc.\n\nconst entityId = `battery_${msg.payload}`;\nconst discoveryTopic = `homeassistant/sensor/${entityId}/config`;\nconst stateTopic = `homeassistant/sensor/${entityId}/state`;\n\nconst payload = {\n    name: entityId,\n    state_topic: stateTopic,\n    unit_of_measurement: unit,\n    device_class: deviceClass,\n    //value_template: \"{{ value | float }}\",\n    value_template: \"{{ value | float | round(2) }}\",\n    unique_id: entityId,\n    icon: \"mdi:home-battery-outline\",\n};\n\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 660,
        "wires": [
            [
                "ea29386f9f8682bc"
            ]
        ]
    },
    {
        "id": "7c04541818436246",
        "type": "inject",
        "z": "7f95345534f00358",
        "g": "d68c2206e3379850",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 290,
        "y": 780,
        "wires": [
            [
                "738718a321d185e7"
            ]
        ]
    },
    {
        "id": "738718a321d185e7",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "d68c2206e3379850",
        "name": "Reset function",
        "func": "flow.set(\"uniqueBatteries\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 780,
        "wires": [
            []
        ]
    },
    {
        "id": "a1c297b2d8067a0b",
        "type": "switch",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DC_SOURCE_STATUS_1",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 450,
        "y": 580,
        "wires": [
            [
                "2c1151c97bb185f2",
                "b6d90639c3fc122c"
            ],
            [
                "2f30b41e1278ef47"
            ]
        ]
    },
    {
        "id": "64578fa414def60a",
        "type": "comment",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS types",
        "info": "DC_SOURCE_STATUS_1: This is the most basic status message. It provides the fundamental electrical readings: \n\nDC Voltage and DC Current. A positive current value indicates the source is discharging (power flowing out), while a negative value indicates it is charging.\n\nDC_SOURCE_STATUS_2: This message adds thermal and capacity information. It reports the \n\nSource Temperature, the battery's State of Charge (SOC) as a percentage, and the estimated Time Remaining until the battery is either full or empty.\n\nDC_SOURCE_STATUS_3: This provides more nuanced details about the battery's long-term health and capacity. It includes the \n\nState of Health (SOH), Capacity Remaining in amp-hours, and Relative Capacity, which is the state of charge adjusted for the state of health.\n\n\nDC_SOURCE_STATUS_5: This message is for high-precision measurement. It reports the \n\nDC Voltage with 0.001 V precision, allowing for more accurate remote voltage sensing without needing dedicated wires.",
        "x": 920,
        "y": 800,
        "wires": []
    },
    {
        "id": "240af7ca01aa2041",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Unique tanks",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueTanks = flow.get(\"uniqueTanks\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.tank_type);\n\n// Check if it's a new unique message\nif (!uniqueTanks.includes(newMsgStr)) {\n    uniqueTanks.push(newMsgStr);\n    flow.set(\"uniqueTanks\", uniqueTanks);\n\n    // Create a new msg with only payload\n    return { payload: msg.payload.tank_type };\n}\n\n// Return nothing if duplicate\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 220,
        "wires": [
            [
                "f9f5381eb086c0e6"
            ]
        ]
    },
    {
        "id": "2f30b41e1278ef47",
        "type": "debug",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "New DC_SOURCE_STATUS",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 680,
        "wires": []
    },
    {
        "id": "9f88f215f3f07227",
        "type": "switch",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DIGITAL_INPUT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WATER_PUMP_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AUTOFILL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "TANK_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_AMBIENT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FLOOR_HEAT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FURNACE_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "GENERATOR_DEMAND_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ATS_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "CHARGER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHARGER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "INVERTER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_DC_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DC_SOURCE_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AC_LOAD_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ATS_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DC_DIMMER_STATUS",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 23,
        "x": 420,
        "y": 220,
        "wires": [
            [],
            [
                "9e8e5609c54fec82"
            ],
            [
                "96c3c21a4dd0b9bd"
            ],
            [
                "2e5425d73a166c9b"
            ],
            [
                "ccec30ad0f32bbdf"
            ],
            [
                "ae9f041c9cd36bb9"
            ],
            [
                "1bb521d55aeb5eba"
            ],
            [
                "cd9d55c23ebcee86"
            ],
            [
                "d76a4a48e1beaed6"
            ],
            [
                "6b27f0f99ea11a72"
            ],
            [
                "f82e60f4adb5e60b"
            ],
            [
                "e5d61c5724c6ed1b"
            ],
            [
                "bacdea9854675b01"
            ],
            [
                "f171dcbe8b5d2e05"
            ],
            [
                "b2bda5ef5e68c98d"
            ],
            [
                "cb64b7a9a87f03cc"
            ],
            [
                "9621acf15d833362"
            ],
            [
                "b91d72f6d383c0d6"
            ],
            [
                "010c5119a7e833b2"
            ],
            [
                "c38d48059f463772"
            ],
            [
                "a0357de00b26b002"
            ],
            [
                "4a6d57460d64c76f"
            ],
            [
                "b797e5a52b6db5b4"
            ]
        ]
    },
    {
        "id": "d4e17993ced2a93b",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AUTOFILL_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 160,
        "wires": []
    },
    {
        "id": "96c3c21a4dd0b9bd",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AUTOFILL_STATUS",
        "func": "// AUTOFILL_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes AUTOFILL_STATUS messages per RV-C specification\n// Handles automatic tank filling system status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === AUTOFILL_STATUS Specific Decoders ===\n\nfunction decodeOperatingStatus(value) {\n    // Operating status from bits 0-1 of byte 0\n    const states = {\n        0: \"AutoFill off\",\n        1: \"AutoFill on\"\n    };\n    return states[value] || `Unknown Status ${value}`;\n}\n\nfunction decodeValveStatus(value) {\n    // Valve status from bits 2-3 of byte 0\n    const states = {\n        0: \"Diverter valve closed\",\n        1: \"Valve open\"\n    };\n    return states[value] || `Unknown Valve Status ${value}`;\n}\n\nfunction decodeLastOperation(value) {\n    // Last operation from bits 4-7 of byte 0\n    const operations = {\n        0: \"Still running\",\n        1: \"Successful fill\",\n        2: \"Fill timed out\",\n        3: \"Fill manually aborted\",\n        4: \"Fill aborted due to error\"\n    };\n    return operations[value] || `Unknown Operation ${value}`;\n}\n\n// Note: AUTOFILL_STATUS only uses bit fields in byte 0\n// All other decoder functions were removed as they're not applicable to this DGN\n\n\n// === Main Decode Function ===\n\nfunction decodeAutofillMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AUTOFILL_STATUS\"\n    };\n\n    // Decode byte 0 based on RV-C spec\n    if (data.length > 0) {\n        const byte0 = data[0];\n\n        // Extract bit fields from byte 0\n        const operatingStatus = decodeBits(byte0, 0, 1);\n        const valveStatus = decodeBits(byte0, 2, 3);\n        const lastOperation = decodeBits(byte0, 4, 7);\n\n        result.operating_status = decodeOperatingStatus(operatingStatus);\n        result.valve_status = decodeValveStatus(valveStatus);\n        result.last_operation = decodeLastOperation(lastOperation);\n\n        // Raw bit values for debugging\n        result.raw_operating_status = operatingStatus;\n        result.raw_valve_status = valveStatus;\n        result.raw_last_operation = lastOperation;\n        result.raw_byte_0 = byte0;\n    }\n\n    // Add convenience fields\n    result.autofill_active = result.operating_status && result.operating_status.includes(\"on\");\n    result.valve_open = result.valve_status && result.valve_status.includes(\"open\");\n    result.has_error = result.last_operation && result.last_operation.includes(\"error\");\n    result.fill_successful = result.last_operation && result.last_operation.includes(\"successful\");\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the AUTOFILL_STATUS message\nconst decodedData = decodeAutofillMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 160,
        "wires": [
            [
                "d4e17993ced2a93b"
            ]
        ]
    },
    {
        "id": "19307edfe4e5bd84",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 880,
        "wires": []
    },
    {
        "id": "b2bda5ef5e68c98d",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_AC_STATUS",
        "func": "// CHARGER_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes CHARGER_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC input status for battery chargers (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_AC_STATUS Specific Decoders ===\n\nfunction decodeChargerACInstance(value) {\n    // Charger AC instance interpretation per RV-C spec\n    // For chargers, this typically indicates the AC input line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    // Special handling for 0xFF (all bits set) - typically means \"Not Available\"\n    if (value === 255) {\n        return {\n            faults: \"No Faults\",\n            open_ground: false,\n            open_neutral: false,\n            reverse_polarity: false,\n            ground_current_fault: false,\n            any_fault: false\n        };\n    }\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeChargerACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.charging_capable = result.ac_available && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_AC_STATUS message\nconst decodedData = decodeChargerACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 880,
        "wires": [
            [
                "19307edfe4e5bd84"
            ]
        ]
    },
    {
        "id": "91cac903d306591a",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 1000,
        "wires": []
    },
    {
        "id": "9621acf15d833362",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_AC_STATUS",
        "func": "// INVERTER_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC output status for inverters (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_AC_STATUS Specific Decoders ===\n\nfunction decodeInverterACInstance(value) {\n    // Inverter AC instance interpretation per RV-C spec\n    // For inverters, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeInverterACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active = result.rms_voltage !== \"Not Available\" &&\n                             typeof result.rms_voltage === 'number' &&\n                             result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.inverter_loaded = result.rms_current !== \"Not Available\" &&\n                            typeof result.rms_current === 'number' &&\n                            result.rms_current > 0.1; // Some current flow\n\n    result.inverter_available = !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_AC_STATUS message\nconst decodedData = decodeInverterACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1000,
        "wires": [
            [
                "91cac903d306591a"
            ]
        ]
    },
    {
        "id": "6bfae4a49e3fdddf",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "WATER_PUMP_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 100,
        "wires": []
    },
    {
        "id": "9e8e5609c54fec82",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WATER_PUMP_STATUS",
        "func": "// WATER_PUMP_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes WATER_PUMP_STATUS messages per RV-C specification\n// Handles water pump operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === WATER_PUMP_STATUS Specific Decoders ===\n\nfunction decodeWaterPumpInstance(value) {\n    // Water pump instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Water pump operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Running\",\n        3: \"Priming\",\n        4: \"Self Test\",\n        5: \"Fault\",\n        6: \"Maintenance Required\",\n        7: \"Pressure Switch Open\",\n        8: \"Low Voltage\",\n        9: \"High Temperature\",\n        10: \"Dry Run Protection\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodePumpCommand(value) {\n    // Pump command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Auto\",\n        3: \"Manual\",\n        4: \"Prime\",\n        5: \"Test\",\n        6: \"Reset Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodePressure(value) {\n    // Pressure in kPa (0.5 kPa resolution)\n    if (value <= 500) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5 kPa per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFlowRate(value) {\n    // Flow rate in liters per minute (0.1 L/min resolution)\n    if (value <= 6500) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1 L/min per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrent(value) {\n    // Current in amperes (0.05A resolution)\n    // Handle special values first\n    if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    } else if (value <= 500) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodePumpSpeed(value) {\n    // Pump speed as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 0) {\n        return \"Standby\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Pump Running\");\n    if (value & 0x02) statusBits.push(\"Pressure OK\");\n    if (value & 0x04) statusBits.push(\"Flow Detected\");\n    if (value & 0x08) statusBits.push(\"Auto Mode\");\n    if (value & 0x10) statusBits.push(\"Prime Mode\");\n    if (value & 0x20) statusBits.push(\"Overtemperature\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overcurrent\",\n        2: \"Overvoltage\",\n        3: \"Undervoltage\",\n        4: \"Overtemperature\",\n        5: \"Dry Run\",\n        6: \"Pressure Switch Fault\",\n        7: \"Motor Fault\",\n        8: \"Communication Error\",\n        9: \"Sensor Fault\",\n        10: \"Flow Sensor Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeWaterPumpMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"WATER_PUMP_STATUS\"\n    };\n\n    // Decode based on water pump format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeWaterPumpInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Command\n        result.command = decodePumpCommand(data[2]);\n\n        // Byte 3: Pump Speed\n        result.pump_speed = decodePumpSpeed(data[3]);\n\n        // Byte 4: Current\n        result.current = decodeCurrent(data[4]);\n\n        // Bytes 5-6: Pressure (uint16, little-endian)\n        const pressureRaw = data[5] | (data[6] << 8);\n        result.pressure = decodePressure(pressureRaw);\n\n        // Byte 7: System Status\n        if (data.length > 7) {\n            result.system_status = decodeSystemStatus(data[7]);\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_command = data[2];\n        result.raw_pump_speed = data[3];\n        result.raw_current = data[4];\n        result.raw_pressure = pressureRaw;\n        if (data.length > 7) {\n            result.raw_system_status = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.pump_running = result.operating_state && result.operating_state.includes(\"Running\");\n    result.pump_active = result.operating_state &&\n        (result.operating_state.includes(\"Running\") ||\n            result.operating_state.includes(\"Priming\") ||\n            result.operating_state.includes(\"On\"));\n    result.pump_available = result.operating_state &&\n        !result.operating_state.includes(\"Fault\") &&\n        !result.operating_state.includes(\"Error\") &&\n        result.operating_state !== \"Not Available\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the WATER_PUMP_STATUS message\nconst decodedData = decodeWaterPumpMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 100,
        "wires": [
            [
                "6bfae4a49e3fdddf"
            ]
        ]
    },
    {
        "id": "b9d5913b9730b3e0",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_AMBIENT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 400,
        "wires": []
    },
    {
        "id": "1bb521d55aeb5eba",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_AMBIENT_STATUS",
        "func": "// THERMOSTAT_AMBIENT_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_AMBIENT_STATUS messages per RV-C specification\n// Handles ambient temperature and humidity sensors\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_AMBIENT_STATUS Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value <= 250) {\n        return \"Out of Range\"; // Values 201-250\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeHumidity(value) {\n    // Humidity as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDewPoint(value, isCelsius = false) {\n    // Dew point temperature with same encoding as ambient temperature\n    return decodeTemperature(value, isCelsius);\n}\n\nfunction decodeAirQuality(value) {\n    // Air quality index\n    const qualityLevels = {\n        0: \"Good\",\n        1: \"Moderate\",\n        2: \"Unhealthy for Sensitive\",\n        3: \"Unhealthy\",\n        4: \"Very Unhealthy\",\n        5: \"Hazardous\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return qualityLevels[value] || `Unknown Quality ${value}`;\n}\n\nfunction decodeSensorStatus(value) {\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 251) {\n        return \"Error\";\n    }\n\n    // Sensor status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Temperature Valid\");\n    if (value & 0x02) statusBits.push(\"Humidity Valid\");\n    if (value & 0x04) statusBits.push(\"Dew Point Valid\");\n    if (value & 0x08) statusBits.push(\"Air Quality Valid\");\n    if (value & 0x10) statusBits.push(\"Sensor Calibrated\");\n    if (value & 0x20) statusBits.push(\"Sensor Fault\");\n    if (value & 0x40) statusBits.push(\"Low Battery\");\n    if (value & 0x80) statusBits.push(\"Communication Error\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_AMBIENT_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'ambient temperature' || param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name.includes('humidity')) {\n            return decodeHumidity(value);\n        }\n        if (param.name === 'dew point' || param.name.includes('dew')) {\n            return decodeDewPoint(value);\n        }\n        if (param.name === 'air quality' || param.name.includes('quality')) {\n            return decodeAirQuality(value);\n        }\n        if (param.name === 'sensor status' || param.name.includes('status')) {\n            return decodeSensorStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatAmbientMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_AMBIENT_STATUS\"\n    };\n\n    // Decode based on THERMOSTAT_AMBIENT_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[1]);\n\n        // Byte 2: Humidity\n        result.humidity = decodeHumidity(data[2]);\n\n        // Byte 3: Dew Point\n        result.dew_point = decodeDewPoint(data[3]);\n\n        // Byte 4: Air Quality Index\n        result.air_quality = decodeAirQuality(data[4]);\n\n        // Byte 5: Sensor Status\n        result.sensor_status = decodeSensorStatus(data[5]);\n\n        // Bytes 6-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_ambient_temperature = data[1];\n        result.raw_humidity = data[2];\n        result.raw_dew_point = data[3];\n        result.raw_air_quality = data[4];\n        result.raw_sensor_status = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    if (result.ambient_temperature !== undefined && typeof result.ambient_temperature === 'number') {\n        result.temperature_fahrenheit = parseFloat(((result.ambient_temperature * 9 / 5) + 32).toFixed(1));\n    }\n\n    result.sensor_available = result.instance !== \"Not Available\" &&\n        result.ambient_temperature !== \"Not Available\";\n\n    result.humidity_available = typeof result.humidity === 'number';\n    result.air_quality_available = result.air_quality !== \"Not Available\" &&\n        result.air_quality !== \"Not Supported\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_AMBIENT_STATUS message\nconst decodedData = decodeThermostatAmbientMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 400,
        "wires": [
            [
                "b9d5913b9730b3e0"
            ]
        ]
    },
    {
        "id": "aefff6ed9ffdb709",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "FLOOR_HEAT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 460,
        "wires": []
    },
    {
        "id": "cd9d55c23ebcee86",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FLOOR_HEAT_STATUS",
        "func": "// FLOOR_HEAT_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes FLOOR_HEAT_STATUS messages per RV-C specification\n// Handles floor heating system control and status\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === FLOOR_HEAT_STATUS Specific Decoders ===\n\nfunction decodeFloorHeatInstance(value) {\n    // Floor heat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Heating\",\n        3: \"Standby\",\n        4: \"Test\",\n        5: \"Fault\",\n        6: \"Maintenance Required\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeHeatingLevel(value) {\n    // Heating level as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding for FLOOR_HEAT_STATUS uint16 values\n    // RV-C spec: 0.03125°C resolution with -273°C offset\n    // Special cases: 0 = Not Available, very low values likely invalid\n    if (value === 0) {\n        return \"Not Available\";\n    } else if (value <= 65530) {\n        const tempK = value * 0.03125; // Kelvin\n        const tempC = tempK - 273.15; // Convert to Celsius\n\n        // Sanity check: if temperature is extremely low, likely invalid data\n        if (tempC < -100) {\n            return \"Invalid Reading\";\n        }\n\n        if (isCelsius) {\n            return parseFloat(tempC.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((tempC * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSetpoint(value, isCelsius = false) {\n    // Temperature setpoint - same format as measured temperature\n    // RV-C spec: 0.03125°C resolution with -273°C offset\n    // Special cases: 0 = Not Available, very low values likely invalid\n    if (value === 0) {\n        return \"Not Available\";\n    } else if (value <= 65530) {\n        const tempK = value * 0.03125; // Kelvin\n        const tempC = tempK - 273.15; // Convert to Celsius\n\n        // Sanity check: if temperature is extremely low, likely invalid data\n        if (tempC < -100) {\n            return \"Invalid Reading\";\n        }\n\n        if (isCelsius) {\n            return parseFloat(tempC.toFixed(1));\n        } else {\n            // Convert to Fahrenheit\n            return parseFloat(((tempC * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTimer(value) {\n    // Timer in minutes\n    if (value <= 600) {\n        return value; // Minutes\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodePower(value) {\n    // Power consumption in watts\n    if (value <= 65000) {\n        return value; // Watts\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 0) {\n        return \"Normal\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Heating Active\");\n    if (value & 0x02) statusBits.push(\"Timer Active\");\n    if (value & 0x04) statusBits.push(\"Temperature Sensor OK\");\n    if (value & 0x08) statusBits.push(\"Overtemperature\");\n    if (value & 0x10) statusBits.push(\"Overcurrent\");\n    if (value & 0x20) statusBits.push(\"Communication Fault\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeFloorHeatMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"FLOOR_HEAT_STATUS\"\n    };\n\n    // Decode based on floor heat format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeFloorHeatInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Heating Level\n        result.heating_level = decodeHeatingLevel(data[2]);\n\n        // Bytes 3-4: Measured Temperature (uint16, little-endian)\n        const tempRaw = data[3] | (data[4] << 8);\n        result.measured_temperature = decodeTemperature(tempRaw);\n\n        // Bytes 5-6: Set Point (uint16, little-endian)\n        const setpointRaw = data[5] | (data[6] << 8);\n        result.set_point = decodeSetpoint(setpointRaw);\n\n        // Byte 7: System Status\n        if (data.length > 7) {\n            result.system_status = decodeSystemStatus(data[7]);\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_heating_level = data[2];\n        result.raw_temperature = tempRaw;\n        result.raw_setpoint = setpointRaw;\n        if (data.length > 7) {\n            result.raw_system_status = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.floor_heat_active = result.operating_state &&\n                              (result.operating_state.includes(\"On\") || result.operating_state.includes(\"Heating\"));\n    result.floor_heat_available = result.system_status &&\n                                 !result.system_status.includes(\"System Fault\") &&\n                                 result.system_status !== \"Not Available\";\n    result.heating_active = result.operating_state && result.operating_state.includes(\"Heating\");\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the FLOOR_HEAT_STATUS message\nconst decodedData = decodeFloorHeatMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 460,
        "wires": [
            [
                "aefff6ed9ffdb709"
            ]
        ]
    },
    {
        "id": "e06ff8584295e0bd",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 340,
        "wires": []
    },
    {
        "id": "ae9f041c9cd36bb9",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_2",
        "func": "// THERMOSTAT_STATUS_2 Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_STATUS_2 messages per RV-C specification\n// Handles thermostat scheduling and advanced features\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_2 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrentScheduleInstance(value) {\n    // Current schedule instance mapping per RV-C spec\n    if (value === 0) {\n        return \"Sleep\";\n    } else if (value === 1) {\n        return \"Wake\";\n    } else if (value === 2) {\n        return \"Away\";\n    } else if (value === 3) {\n        return \"Return\";\n    } else if (value >= 4 && value <= 249) {\n        return `Additional Instance ${value}`;\n    } else if (value === 250) {\n        return \"Storage\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeScheduleInstances(value) {\n    // Number of schedule instances capacity\n    if (value <= 200) {\n        return value; // Direct count\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeReducedNoiseMode(value) {\n    // Reduced noise mode from bit field\n    if (value === 0) {\n        return \"Disabled\";\n    } else if (value === 1) {\n        return \"Enabled\";\n    }\n    return \"Unknown\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_STATUS_2 parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'current schedule instance') {\n            return decodeCurrentScheduleInstance(value);\n        }\n        if (param.name === 'number of schedule instances') {\n            return decodeScheduleInstances(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit' || param.type === 'bit2' || (param.type.startsWith('uint') && param.bit)) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.name === 'reduced noise mode') {\n                return decodeReducedNoiseMode(bitValue);\n            }\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus2Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_2\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_2 format (typically 4-8 bytes)\n    if (data.length > 0) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Current Schedule Instance\n        if (data.length > 1) {\n            result.current_schedule_instance = decodeCurrentScheduleInstance(data[1]);\n        }\n\n        // Byte 2: Number of Schedule Instances\n        if (data.length > 2) {\n            result.number_of_schedule_instances = decodeScheduleInstances(data[2]);\n        }\n\n        // Byte 3: Reduced Noise Mode (bits 0-1)\n        if (data.length > 3) {\n            if (data[3] === 255) {\n                result.reduced_noise_mode = \"Not Available\";\n            } else if (data[3] === 254) {\n                result.reduced_noise_mode = \"Reserved\";\n            } else if (data[3] === 253) {\n                result.reduced_noise_mode = \"Out of Range\";\n            } else {\n                const noiseBits = decodeBits(data[3], 0, 1);\n                result.reduced_noise_mode = decodeReducedNoiseMode(noiseBits);\n            }\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        if (data.length > 1) result.raw_current_schedule = data[1];\n        if (data.length > 2) result.raw_schedule_count = data[2];\n        if (data.length > 3) result.raw_features_byte = data[3];\n        if (data.length > 4) result.raw_byte_4 = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.scheduling_supported = result.number_of_schedule_instances !== \"Not Available\" &&\n        typeof result.number_of_schedule_instances === 'number' &&\n        result.number_of_schedule_instances > 0;\n\n    result.current_mode = result.current_schedule_instance;\n\n    // Determine if in a standard schedule mode\n    if (typeof result.current_schedule_instance === 'string') {\n        const schedule = result.current_schedule_instance.toLowerCase();\n        result.in_sleep_mode = schedule === \"sleep\";\n        result.in_wake_mode = schedule === \"wake\";\n        result.in_away_mode = schedule === \"away\";\n        result.in_return_mode = schedule === \"return\";\n        result.in_standard_schedule = [\"sleep\", \"wake\", \"away\", \"return\"].includes(schedule);\n    }\n\n    result.quiet_mode_active = result.reduced_noise_mode === \"Enabled\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_2 message\nconst decodedData = decodeThermostatStatus2Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 340,
        "wires": [
            [
                "e06ff8584295e0bd"
            ]
        ]
    },
    {
        "id": "6a02f9f3c2b95dcc",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 580,
        "wires": []
    },
    {
        "id": "6b27f0f99ea11a72",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_STATUS",
        "func": "// GENERATOR_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_STATUS messages per RV-C specification\n// Handles generator operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_STATUS Specific Decoders ===\n\nfunction decodeGeneratorInstance(value) {\n    // Generator instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Generator operating state mapping per RV-C specification (extended)\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Cool Down\",\n        5: \"Prime/Pre-Heat\",\n        6: \"Exercise\",\n        7: \"Test\",\n        8: \"Fault\",\n        9: \"Maintenance Required\",\n        10: \"Remote Start\",\n        11: \"Warm Up\",\n        12: \"Load Test\",\n        13: \"Safety Shutdown\",\n        14: \"Over Temperature\",\n        15: \"Low Oil Pressure\",\n        16: \"Over Speed\",\n        17: \"Under Speed\",\n        18: \"Over Voltage\",\n        19: \"Under Voltage\",\n        20: \"Over Current\",\n        21: \"Under Current\",\n        22: \"Auto Start\",\n        23: \"Manual Start\",\n        24: \"Scheduled Start\",\n        25: \"Emergency Start\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeGeneratorCommand(value) {\n    // Generator command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Exercise\",\n        3: \"Test\",\n        4: \"Prime\",\n        5: \"Pre-Heat\",\n        6: \"Reset Fault\",\n        7: \"Clear Maintenance\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Gasoline\",\n        2: \"Diesel\",\n        3: \"Propane\",\n        4: \"Natural Gas\",\n        5: \"Dual Fuel\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeEngineRPM(value) {\n    // Engine RPM (4 RPM resolution)\n    if (value <= 16000) {\n        return value * 4; // 4 RPM per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeRunTime(value) {\n    // Run time in hours (0.1 hour resolution)\n    if (value <= 655300) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1 hour per step\n    } else if (value === 4294967293) {\n        return \"Out of Range\";\n    } else if (value === 4294967294) {\n        return \"Reserved\";\n    } else if (value === 4294967295) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFuelLevel(value) {\n    // Fuel level as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOilPressure(value) {\n    // Oil pressure in kPa (0.5 kPa resolution)\n    if (value <= 500) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5 kPa per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 1.2).toFixed(1)); // 1.2V per step, 0-300V range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 0.4).toFixed(1)); // 0.4A per step, 0-100A range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultStatus(value) {\n    // Fault status bit field\n    const faults = [];\n\n    if (value & 0x01) faults.push(\"Low Oil Pressure\");\n    if (value & 0x02) faults.push(\"High Temperature\");\n    if (value & 0x04) faults.push(\"Low Fuel\");\n    if (value & 0x08) faults.push(\"Overcurrent\");\n    if (value & 0x10) faults.push(\"Overvoltage\");\n    if (value & 0x20) faults.push(\"Undervoltage\");\n    if (value & 0x40) faults.push(\"Service Required\");\n    if (value & 0x80) faults.push(\"System Fault\");\n\n    return faults.length > 0 ? faults.join(\", \") : \"No Faults\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific GENERATOR_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeGeneratorInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeGeneratorCommand(value);\n        }\n        if (param.name === 'fuel type') {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'fuel level') {\n            return decodeFuelLevel(value);\n        }\n        if (param.name === 'oil pressure') {\n            return decodeOilPressure(value);\n        }\n        if (param.name === 'fault status' || param.name === 'faults') {\n            return decodeFaultStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'engine rpm' || param.name === 'rpm') {\n            return decodeEngineRPM(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'run time' || param.name === 'runtime') {\n            return decodeRunTime(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_STATUS\"\n    };\n\n    // Decode based on GENERATOR_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Bytes 3-4: Engine RPM (16-bit, little-endian)\n        const engineRPM = data[3] | (data[4] << 8);\n        result.engine_rpm = decodeEngineRPM(engineRPM);\n\n        // Byte 5: AC Voltage (single byte for generators)\n        result.ac_voltage = decodeACVoltage(data[5]);\n\n        // Byte 6: AC Current (single byte approximation)\n        result.ac_current = decodeACCurrent(data[6]);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_engine_rpm_bytes = [data[3], data[4]];\n        result.raw_ac_voltage = data[5];\n        result.raw_ac_current = data[6];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.generator_running = state === \"running\";\n        result.generator_available = ![\"fault\", \"maintenance required\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_exercising = state === \"exercise\";\n        result.needs_maintenance = state === \"maintenance required\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    // Engine status\n    result.engine_running = typeof result.engine_rpm === 'number' && result.engine_rpm > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_STATUS message\nconst decodedData = decodeGeneratorMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 580,
        "wires": [
            [
                "6a02f9f3c2b95dcc"
            ]
        ]
    },
    {
        "id": "f82e60f4adb5e60b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_AC_STATUS",
        "func": "// GENERATOR_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC output status for generators (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_AC_STATUS Specific Decoders ===\n\nfunction decodeGeneratorACInstance(value) {\n    // Generator AC instance interpretation per RV-C spec\n    // For generators, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active = result.rms_voltage !== \"Not Available\" &&\n                             typeof result.rms_voltage === 'number' &&\n                             result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.generator_loaded = result.rms_current !== \"Not Available\" &&\n                             typeof result.rms_current === 'number' &&\n                             result.rms_current > 0.1; // Some current flow\n\n    result.generator_ac_available = result.ac_output_active && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_AC_STATUS message\nconst decodedData = decodeGeneratorACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 640,
        "wires": [
            [
                "6b903512de37f1ad"
            ]
        ]
    },
    {
        "id": "6b903512de37f1ad",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 640,
        "wires": []
    },
    {
        "id": "bacdea9854675b01",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_AC_STATUS",
        "func": "// ATS_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes ATS_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC input/output status for automatic transfer switches (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_AC_STATUS Specific Decoders ===\n\nfunction decodeATSACInstance(value) {\n    // ATS AC instance interpretation per RV-C spec\n    // For ATS, this typically indicates the AC input/output line being monitored\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7 - ATS-specific fault interpretation\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeATSACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeATSACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields for ATS operations\n    result.ac_source_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.ats_load_present = result.rms_current !== \"Not Available\" &&\n        typeof result.rms_current === 'number' &&\n        result.rms_current > 0.1; // Some current flow\n\n    result.ac_source_qualified = result.ac_source_available &&\n        !result.any_fault &&\n        typeof result.frequency === 'number' &&\n        result.frequency >= 58 && result.frequency <= 62; // Reasonable frequency range\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_AC_STATUS message\nconst decodedData = decodeATSACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 760,
        "wires": [
            [
                "f80a9416a8e18e46"
            ]
        ]
    },
    {
        "id": "f80a9416a8e18e46",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 760,
        "wires": []
    },
    {
        "id": "f171dcbe8b5d2e05",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_STATUS",
        "func": "// CHARGER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes CHARGER_STATUS messages per RV-C specification\n// Handles battery charger operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_STATUS Specific Decoders ===\n\nfunction decodeChargerInstance(value) {\n    // Charger instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Charger operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"Bulk\",\n        2: \"Absorption\",\n        3: \"Overcharge\",\n        4: \"Equalize\",\n        5: \"Float\",\n        6: \"No Charge\",\n        7: \"Constant Voltage\",\n        8: \"Constant Current\",\n        9: \"Fault\",\n        10: \"Unavailable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeChargerCommand(value) {\n    // Charger command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Bulk\",\n        3: \"Absorption\",\n        4: \"Overcharge\",\n        5: \"Equalize\",\n        6: \"Float\",\n        7: \"Auto\",\n        8: \"Reset Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeChargerType(value) {\n    // Charger type mapping\n    const chargerTypes = {\n        0: \"Unknown\",\n        1: \"AC-DC Converter\",\n        2: \"Solar Controller\",\n        3: \"Wind Generator\",\n        4: \"Alternator\",\n        5: \"DC-DC Converter\",\n        6: \"Fuel Cell\",\n        7: \"Shore Power\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return chargerTypes[value] || `Unknown Type ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeEfficiency(value) {\n    // Efficiency as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Charging Active\");\n    if (value & 0x02) statusBits.push(\"AC Input Available\");\n    if (value & 0x04) statusBits.push(\"Battery Connected\");\n    if (value & 0x08) statusBits.push(\"Equalize Mode\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Reverse Polarity\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overvoltage Input\",\n        2: \"Undervoltage Input\",\n        3: \"Overtemperature\",\n        4: \"Fan Failure\",\n        5: \"Communication Error\",\n        6: \"Battery Fault\",\n        7: \"Ground Fault\",\n        8: \"Current Limit\",\n        9: \"Internal Fault\",\n        10: \"Reverse Polarity\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific CHARGER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeChargerInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeChargerCommand(value);\n        }\n        if (param.name === 'charger type' || param.name === 'type') {\n            return decodeChargerType(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'efficiency') {\n            return decodeEfficiency(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeChargerMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_STATUS\"\n    };\n\n    // Decode based on CHARGER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Charger Type\n        result.charger_type = decodeChargerType(data[2]);\n\n        // Bytes 3-4: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[3] | (data[4] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Bytes 5-6: DC Current (16-bit, little-endian)\n        const dcCurrent = data[5] | (data[6] << 8);\n        result.dc_current = decodeDCCurrent(dcCurrent);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_charger_type = data[2];\n        result.raw_dc_voltage_bytes = [data[3], data[4]];\n        result.raw_dc_current_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.charger_active = ![\"off\", \"no charge\", \"fault\", \"unavailable\", \"error\"].includes(state);\n        result.charger_charging = [\"bulk\", \"absorption\", \"float\", \"equalize\"].includes(state);\n        result.charger_available = ![\"fault\", \"unavailable\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.dc_voltage === 'number' && typeof result.dc_current === 'number') {\n        result.dc_power = parseFloat((result.dc_voltage * result.dc_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_STATUS message\nconst decodedData = decodeChargerMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 820,
        "wires": [
            [
                "78904d457471d1b2"
            ]
        ]
    },
    {
        "id": "78904d457471d1b2",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 820,
        "wires": []
    },
    {
        "id": "b91d72f6d383c0d6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_DC_STATUS",
        "func": "// INVERTER_DC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_DC_STATUS messages per RV-C specification\n// Handles DC input status for inverters (DC battery connection monitoring)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_DC_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance interpretation per RV-C spec\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCInstance(value) {\n    // DC Instance mapping per RV-C specification\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC Voltage in volts (0.05V resolution)\n    if (value <= 64000) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    // Handle signed 32-bit value\n    let signedValue = value;\n    if (value > 2147483647) {\n        signedValue = value - 4294967296; // Convert from unsigned to signed\n    }\n\n    if (Math.abs(signedValue) <= MAX_VALID) {\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeInverterState(value) {\n    // Inverter operational state\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Sleep Mode\",\n        5: \"Search Mode\",\n        6: \"Standby\",\n        7: \"Fault\",\n        8: \"Battery Low\",\n        9: \"Overload\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\nfunction decodeUint32(data, startByte) {\n    // Decode 32-bit value (little-endian)\n    if (!data || startByte + 3 >= data.length) {\n        return 4294967295; // Not available\n    }\n    return data[startByte] |\n           (data[startByte + 1] << 8) |\n           (data[startByte + 2] << 16) |\n           (data[startByte + 3] << 24);\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterDCMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_DC_STATUS\"\n    };\n\n    // Decode INVERTER_DC_STATUS message (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Inverter Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: DC Instance (battery bank)\n        result.dc_instance = decodeDCInstance(data[1]);\n\n        // Bytes 2-3: DC Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 2);\n        result.dc_voltage = decodeDCVoltage(voltageRaw);\n\n        // Bytes 4-7: DC Current (uint32, little-endian, signed)\n        const currentRaw = decodeUint32(data, 4);\n        result.dc_current = decodeDCCurrent(currentRaw);\n\n        // Additional bytes if available for extended status\n        if (data.length > 8) {\n            // Byte 8: Inverter State (if available)\n            result.inverter_state = decodeInverterState(data[8]);\n        }\n\n        if (data.length > 9) {\n            // Byte 9: Temperature (if available)\n            result.temperature = decodeTemperature(data[9]);\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n    }\n\n    // Add convenience fields\n    result.dc_input_available = result.dc_voltage !== \"Not Available\" &&\n                               typeof result.dc_voltage === 'number' &&\n                               result.dc_voltage > 10; // Reasonable DC voltage threshold\n\n    result.inverter_drawing_power = result.dc_current !== \"Not Available\" &&\n                                   typeof result.dc_current === 'number' &&\n                                   Math.abs(result.dc_current) > 0.5; // Some current flow\n\n    result.inverter_supplying_power = result.dc_current !== \"Not Available\" &&\n                                     typeof result.dc_current === 'number' &&\n                                     result.dc_current < -0.5; // Negative current = supplying power\n\n    if (result.inverter_state !== undefined) {\n        const state = result.inverter_state.toString().toLowerCase();\n        result.inverter_operational = [\"running\", \"search mode\", \"standby\"].includes(state);\n        result.inverter_faulted = [\"fault\", \"battery low\", \"overload\"].includes(state);\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_DC_STATUS message\nconst decodedData = decodeInverterDCMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1060,
        "wires": [
            [
                "04bc7637ee7139d8"
            ]
        ]
    },
    {
        "id": "04bc7637ee7139d8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_DC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 1060,
        "wires": []
    },
    {
        "id": "2e5425d73a166c9b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode TANK_STATUS",
        "func": "// TANK_STATUS Decoder (Updated with Flat Output) - Complete and Accurate RV-C Implementation\n// Decodes TANK_STATUS messages (1FFB7) per RV-C specification\n// Handles all RV tank types: Fresh Water, Gray Water, Black Water, LPG\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === TANK_STATUS Specific Decoders ===\n\nfunction decodeTankInstance(value) {\n    // Tank instance mapping per RV-C specification\n    const tankTypes = {\n        0: \"Fresh Water\",\n        1: \"Gray Water\",\n        2: \"Black Water\",\n        3: \"LPG\",\n        4: \"Fuel\",\n        5: \"Hot Water\",\n        6: \"Hydraulic Fluid\",\n        7: \"Live Well\",\n        8: \"Ballast\",\n        9: \"Oil\",\n        10: \"Coolant\",\n        11: \"Diesel Exhaust Fluid\",\n        12: \"Compressed Air\",\n        13: \"Fresh Water 2\",\n        14: \"Gray Water 2\",\n        15: \"Black Water 2\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return tankTypes[value] || `Unknown Tank ${value}`;\n}\n\nfunction decodeTankLevel(value) {\n    // Tank level as raw sensor reading (not percentage)\n    // Percentage calculated as: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw sensor reading\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankResolution(value) {\n    // Tank resolution as raw sensor resolution value\n    // Used in calculation: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw resolution value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankStatus(value) {\n    // Tank status bit field decoding\n    const statusBits = {\n        0: \"Tank OK\",\n        1: \"Tank Low\",\n        2: \"Tank Full\",\n        3: \"Tank Overfilled\",\n        4: \"Sensor Fault\",\n        5: \"Tank Disconnected\",\n        6: \"Reserved\",\n        7: \"Reserved\"\n    };\n\n    const activeStatuses = [];\n    for (let bit = 0; bit < 8; bit++) {\n        if (value & (1 << bit)) {\n            activeStatuses.push(statusBits[bit]);\n        }\n    }\n\n    return activeStatuses.length > 0 ? activeStatuses.join(\", \") : \"Tank OK\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    const value = data[byte];\n\n    if (param.type === 'uint8') {\n        // Handle specific TANK_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeTankInstance(value);\n        }\n        if (param.name === 'relative level' || param.name === 'level') {\n            return decodeTankLevel(value);\n        }\n        if (param.name === 'resolution') {\n            return decodeTankResolution(value);\n        }\n        if (param.name === 'temperature') {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'status' || param.name === 'tank status') {\n            return decodeTankStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeTankStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"TANK_STATUS\"\n    };\n\n    // Decode based on TANK_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Tank Instance\n        result.instance = decodeTankInstance(data[0]);\n\n        // Byte 1: Relative Level (0-200)\n        result.relative_level = decodeTankLevel(data[1]);\n\n        // Byte 2: Resolution (tank capacity steps)\n        result.resolution = decodeTankResolution(data[2]);\n\n        // Byte 3: Temperature\n        result.temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Tank Status (bit field)\n        result.status = decodeTankStatus(data[4]);\n\n        // Bytes 5-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_relative_level = data[1];\n        result.raw_resolution = data[2];\n        result.raw_temperature = data[3];\n        result.raw_status = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields for easier consumption\n    // Calculate tank percentage using RV-C formula: (relative_level / resolution) * 100\n    if (result.relative_level !== undefined && result.resolution !== undefined &&\n        typeof result.relative_level === 'number' && typeof result.resolution === 'number' &&\n        result.resolution > 0) {\n        result.level_percentage = Math.round((result.relative_level / result.resolution) * 100);\n    } else if (result.relative_level !== undefined && typeof result.relative_level === 'number') {\n        // Fallback if resolution is not available (direct percentage)\n        result.level_percentage = Math.round(result.relative_level * 0.5); // 0.5% per step\n    }\n\n    if (result.instance !== undefined) {\n        // Extract just the tank type for easier filtering\n        const instanceStr = result.instance.toString();\n        if (instanceStr.includes(\"Fresh\")) result.tank_type = \"fresh\";\n        else if (instanceStr.includes(\"Gray\")) result.tank_type = \"gray\";\n        else if (instanceStr.includes(\"Black\")) result.tank_type = \"black\";\n        else if (instanceStr.includes(\"LPG\")) result.tank_type = \"lpg\";\n        else result.tank_type = \"other\";\n    }\n\n    // Tank level status\n    if (typeof result.level_percentage === 'number') {\n        result.tank_empty = result.level_percentage <= 5;\n        result.tank_low = result.level_percentage <= 25;\n        result.tank_full = result.level_percentage >= 95;\n        result.tank_level_available = true;\n    } else {\n        result.tank_level_available = false;\n    }\n\n    // Temperature status\n    result.temperature_available = typeof result.temperature === 'number';\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the TANK_STATUS message\nconst decodedData = decodeTankStatusMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 220,
        "wires": [
            [
                "45ae070eafc9a732"
            ]
        ]
    },
    {
        "id": "e5d61c5724c6ed1b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_DEMAND_STATUS",
        "func": "// GENERATOR_DEMAND_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_DEMAND_STATUS messages per RV-C specification\n// Handles automatic generator start (AGS) demand status and control flags\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_DEMAND_STATUS Specific Decoders ===\n\nfunction decodeDemandStatus(value) {\n    // Decode demand status bits (2-bit fields)\n    const states = {\n        0: \"No Demand\",\n        1: \"Demand Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeOverrideStatus(value) {\n    // Decode override/activity status bits (2-bit fields)\n    const states = {\n        0: \"Normal Operation\",\n        1: \"Override/Activity Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeTime(hour, minute) {\n    // Convert hour and minute to readable time format\n    if (hour === 255 || minute === 255) {\n        return \"Not Available\";\n    }\n    if (hour > 23 || minute > 59) {\n        return \"Invalid Time\";\n    }\n\n    // Format as 24-hour time\n    const hourStr = hour.toString().padStart(2, '0');\n    const minStr = minute.toString().padStart(2, '0');\n    return `${hourStr}:${minStr}`;\n}\n\nfunction decodeMinimumCycleTime(value) {\n    // Minimum cycle time in minutes\n    if (value === 0) {\n        return \"No Minimum\";\n    } else if (value <= 250) {\n        return `${value} minutes`;\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorDemandMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_DEMAND_STATUS\"\n    };\n\n    if (data.length >= 7) {\n        // Byte 0: Demand status bits\n        const byte0 = data[0];\n        result.generator_demand = decodeDemandStatus(decodeBits(byte0, 0, 1));\n        result.internal_demand = decodeDemandStatus(decodeBits(byte0, 2, 3));\n        result.network_demand = decodeDemandStatus(decodeBits(byte0, 4, 5));\n        result.external_activity_detected = decodeOverrideStatus(decodeBits(byte0, 6, 7));\n\n        // Byte 1: Override and control status bits\n        const byte1 = data[1];\n        result.manual_override_detected = decodeOverrideStatus(decodeBits(byte1, 0, 1));\n        result.quiet_time = decodeOverrideStatus(decodeBits(byte1, 2, 3));\n        result.quiet_time_override = decodeOverrideStatus(decodeBits(byte1, 4, 5));\n        result.generator_lock = decodeOverrideStatus(decodeBits(byte1, 6, 7));\n\n        // Bytes 2-3: Quiet time begin (DEPRECATED but still decoded)\n        result.quiet_time_begin = decodeTime(data[2], data[3]);\n\n        // Bytes 4-5: Quiet time end (DEPRECATED but still decoded)\n        if (data.length >= 6) {\n            result.quiet_time_end = decodeTime(data[4], data[5]);\n        }\n\n        // Byte 6: Minimum cycle time\n        if (data.length >= 7) {\n            result.minimum_cycle_time = decodeMinimumCycleTime(data[6]);\n        }\n\n        // Raw values for debugging\n        result.raw_demand_byte = byte0;\n        result.raw_control_byte = byte1;\n    }\n\n    // Add convenience fields for easier automation logic\n    result.generator_should_run = result.generator_demand === \"Demand Active\" ||\n        result.internal_demand === \"Demand Active\" ||\n        result.network_demand === \"Demand Active\";\n\n    result.automatic_start_allowed = result.external_activity_detected !== \"Override/Activity Active\" &&\n        result.generator_lock !== \"Override/Activity Active\";\n\n    result.quiet_time_active = result.quiet_time === \"Override/Activity Active\" &&\n        result.quiet_time_override !== \"Override/Activity Active\";\n\n    result.manual_control_active = result.manual_override_detected === \"Override/Activity Active\";\n\n    // Overall status assessment\n    result.demand_summary = result.generator_should_run ? \"Generator Requested\" : \"No Generator Demand\";\n\n    if (result.generator_lock === \"Override/Activity Active\") {\n        result.demand_summary = \"Generator Locked\";\n    } else if (result.external_activity_detected === \"Override/Activity Active\") {\n        result.demand_summary = \"External Activity Blocking\";\n    } else if (result.quiet_time_active) {\n        result.demand_summary = \"Quiet Time Active\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_DEMAND_STATUS message\nconst decodedData = decodeGeneratorDemandMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 700,
        "wires": [
            [
                "51e87f869d6aa2c5"
            ]
        ]
    },
    {
        "id": "51e87f869d6aa2c5",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_DEMAND_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 700,
        "wires": []
    },
    {
        "id": "cb64b7a9a87f03cc",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_STATUS",
        "func": "// INVERTER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_STATUS messages per RV-C specification\n// Handles inverter operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Inverter operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Inverting\",\n        3: \"Charging\",\n        4: \"Passthrough\",\n        5: \"Standby\",\n        6: \"Fault\",\n        7: \"Equalize\",\n        8: \"Bulk Charge\",\n        9: \"Absorption\",\n        10: \"Float\",\n        11: \"Search Mode\",\n        12: \"Sleep Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeInverterCommand(value) {\n    // Inverter command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Invert Only\",\n        3: \"Charge Only\",\n        4: \"Auto\",\n        5: \"Search Mode\",\n        6: \"Reset Fault\",\n        7: \"Equalize\",\n        8: \"Shore Power Priority\",\n        9: \"Battery Priority\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    if (value <= MAX_VALID) {\n        // Handle signed values for charging (positive) vs discharging (negative)\n        const signedValue = value > 2147483647 ? value - 4294967296 : value;\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency in Hz (0.1Hz resolution)\n    if (value <= 700) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1Hz per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"AC Output On\");\n    if (value & 0x02) statusBits.push(\"Charging Active\");\n    if (value & 0x04) statusBits.push(\"AC Input Available\");\n    if (value & 0x08) statusBits.push(\"Overload\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Low Battery\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overload\",\n        2: \"Overvoltage Input\",\n        3: \"Undervoltage Input\",\n        4: \"Overvoltage Output\",\n        5: \"Undervoltage Output\",\n        6: \"Overtemperature\",\n        7: \"Fan Failure\",\n        8: \"Ground Fault\",\n        9: \"DC Ripple\",\n        10: \"AC Frequency Error\",\n        11: \"Internal Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific INVERTER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeInverterInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeInverterCommand(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name === 'frequency') {\n            return decodeFrequency(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_STATUS\"\n    };\n\n    // Decode based on INVERTER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: AC Voltage\n        result.ac_voltage = decodeACVoltage(data[2]);\n\n        // Bytes 3-4: AC Current (16-bit, little-endian)\n        const acCurrent = data[3] | (data[4] << 8);\n        result.ac_current = decodeACCurrent(acCurrent);\n\n        // Bytes 5-6: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[5] | (data[6] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Byte 7: Temperature or Frequency\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_ac_voltage = data[2];\n        result.raw_ac_current_bytes = [data[3], data[4]];\n        result.raw_dc_voltage_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.inverter_active = state === \"inverting\";\n        result.charger_active = state === \"charging\";\n        result.inverter_available = ![\"fault\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_passthrough = state === \"passthrough\";\n        result.is_in_standby = state === \"standby\" || state === \"search mode\" || state === \"sleep mode\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_STATUS message\nconst decodedData = decodeInverterMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 940,
        "wires": [
            [
                "9f3a9fd8a4506e74"
            ]
        ]
    },
    {
        "id": "9f3a9fd8a4506e74",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 940,
        "wires": []
    },
    {
        "id": "010c5119a7e833b2",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_SOURCE_STATUS",
        "func": "// Corrected RV-C DC_SOURCE_STATUS Decoder for Node-RED\n// Decodes DC_SOURCE_STATUS messages 1, 2, and 3 based on their DGN.\n// Input: msg.payload with {dgn, dataPayload}\n// Output: msg.payload with decoded fields\n\n// === Helper Functions (Largely from your original code) ===\n\n// Decodes a bitfield from within a byte\nfunction decodeBits(byte, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (byte & mask) >> startBit;\n}\n\n// Decodes the DC Instance (Byte 0)\nfunction decodeDCInstance(value) {\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\"\n    };\n    // Per the spec, 5-250 are valid \"Other\" instances \n    if (value >= 5 && value <= 250) {\n        return `Other DC Instance ${value}`;\n    }\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\n// Decodes the Device Priority (Byte 1)\nfunction decodeDevicePriority(value) {\n    const priorities = {\n        20: \"Voltmeter\",\n        40: \"Voltmeter/Ammeter\",\n        60: \"Inverter\",\n        80: \"Charger\",\n        100: \"Inverter/Charger\",\n        120: \"Battery SOC/BMS Device\"\n    };\n    return priorities[value] || `Unknown Priority ${value}`;\n}\n\n// Decodes DC Voltage (uint16)\nfunction decodeDCVoltage(value) {\n    // NOTE: This logic is based on your original function, assuming a 0.05V resolution\n    // from the unprovided \"Table 5.3\" referenced in the spec.\n    if (value <= 64000) return parseFloat((value * 0.05).toFixed(2));\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes DC Current (32-bit signed)\nfunction decodeDCCurrent32bit(value) {\n    // First, check for the special \"Not Available\" value (0xFFFFFFFF)\n    if (value === 4294967295) {\n        return \"Not Available\";\n    }\n\n    // NOTE: This logic assumes a 0.05A resolution from the unprovided \"Table 5.3\"\n    // referenced in the spec.\n\n    // Convert 32-bit unsigned to signed for calculation\n    if (value > 2147483647) {\n        value = value - 4294967296;\n    }\n\n    return parseFloat((value * 0.05).toFixed(2));\n}\n\n// Decodes Temperature (uint16)\nfunction decodeTemperature(value) {\n    // This is for the uint16 version in STATUS_2 [cite: 72]\n    // The spec does not define the scaling for this field, assuming offset of -40 C.\n    if (value <= 64000) return (value * 0.03125) - 273; // Example scaling\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes State of Charge / Health / Relative Capacity (uint8)\nfunction decodePercentage(value) {\n    // 0.5% per step from your original function.\n    if (value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\n\n\n// === DGN-Specific Decoders ===\n\nfunction decodeDCSourceStatus1(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_1\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_1\" };\n\n    result.dc_instance = decodeDCInstance(data[0]);\n    result.dc_instance_id = data[0]; // <-- ADD THIS LINE\n\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const voltage = (data[3] << 8) | data[2];\n    result.dc_voltage_V = decodeDCVoltage(voltage);\n\n    const current = (((data[7] << 24) | (data[6] << 16) | (data[5] << 8) | data[4]) >>> 0);\n    result.dc_current_A = decodeDCCurrent32bit(current);\n\n    return result;\n}\n\nfunction decodeDCSourceStatus2(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_2\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_2\" };\n\n    result.dc_instance = decodeDCInstance(data[0]);\n    result.dc_instance_id = data[0]; // <-- ADD THIS LINE\n\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const temp = (data[3] << 8) | data[2];\n    result.source_temp_C = decodeTemperature(temp);\n\n    result.state_of_charge_percent = decodePercentage(data[4]);\n\n    const time = (data[6] << 8) | data[5];\n    result.time_remaining_min = (time <= 64000) ? time : \"Not Available\";\n\n    const interp = decodeBits(data[7], 0, 1);\n    const interpMap = { 0: \"Time to Empty\", 1: \"Time to Full\", 3: \"Not Available\" };\n    result.time_remaining_interpretation = interpMap[interp] || \"Reserved\";\n\n    return result;\n}\n\nfunction decodeDCSourceStatus3(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_3\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_3\" };\n\n    result.dc_instance = decodeDCInstance(data[0]);\n    result.dc_instance_id = data[0]; // <-- ADD THIS LINE\n\n    result.device_priority = decodeDevicePriority(data[1]);\n    result.state_of_health_percent = decodePercentage(data[2]);\n\n    const cap = (data[4] << 8) | data[3];\n    result.capacity_remaining_Ah = (cap <= 64000) ? cap : \"Not Available\";\n\n    result.relative_capacity_percent = decodePercentage(data[5]);\n\n    const ripple = (data[7] << 8) | data[6];\n    result.ac_rms_ripple_mV = (ripple <= 65530) ? ripple : \"Not Available\";\n\n    return result;\n}\n\n// === Main Router Function ===\n\nfunction decodeDCSourceMessage(dgn, data) {\n    switch (dgn) {\n        case '1FFFD':\n            return decodeDCSourceStatus1(data);\n        case '1FFFC':\n            return decodeDCSourceStatus2(data);\n        case '1FFFB':\n            return decodeDCSourceStatus3(data);\n        default:\n            return {\n                dgn: dgn,\n                error: `Unsupported DGN for DC_SOURCE_STATUS decoding.`\n            };\n    }\n}\n\n// === Main Node-RED Logic ===\n\nconst incomingPayload = msg.payload;\nif (!incomingPayload || !incomingPayload.dgn || !incomingPayload.dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Convert hex payload to byte array\nconst dataBytes = [];\nfor (let i = 0; i < incomingPayload.dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(incomingPayload.dataPayload.substring(i, i + 2), 16));\n}\n\n// Decode the message by routing to the correct function based on DGN\nconst decodedData = decodeDCSourceMessage(incomingPayload.dgn, dataBytes);\n\n// Merge the original payload and the newly decoded data\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up by removing the raw hex payload\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1120,
        "wires": [
            [
                "bff245b2ca47ef79"
            ]
        ]
    },
    {
        "id": "c38d48059f463772",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AC_LOAD_STATUS",
        "func": "// AC_LOAD_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes AC_LOAD_STATUS messages per RV-C specification\n// Handles generic AC circuit loads with load management capabilities\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === AC_LOAD_STATUS Specific Decoders ===\n\nfunction decodeLoadInstance(value) {\n    // Load instance interpretation per RV-C spec\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << (i - 1); // Group 1 = bit 0, Group 2 = bit 1, etc.\n        if (!(value & groupBit)) { // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingLevel(value) {\n    // Operating status/level (0-100% for dimmable, or special values)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 252) {\n        return \"Load Delay Active\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return modes[value] || \"Unknown\";\n}\n\nfunction decodeVariableCapability(value) {\n    // Variable level capability (2-bit field)\n    const capabilities = {\n        0: \"Not Variable (Not Dimmable)\",\n        1: \"Variable (Dimmable)\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return capabilities[value] || \"Unknown\";\n}\n\nfunction decodePriority(value) {\n    // Load priority (4-bit field)\n    if (value <= 13) {\n        return `Priority ${value} (${value === 0 ? \"Highest\" : value === 13 ? \"Lowest\" : \"Medium\"})`;\n    } else if (value === 14) {\n        return \"Error\";\n    } else if (value === 15) {\n        return \"No Data\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDelay(value) {\n    // Delay before load activation\n    if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrent(value) {\n    // Current in amperes per Table 5.3 (0.05A resolution for small values)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeACLoadMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AC_LOAD_STATUS\"\n    };\n\n    // Determine if this is AC_LOAD_STATUS or AC_LOAD_STATUS_2\n    const dgnHex = dgn.toUpperCase();\n\n    if (dgnHex === \"1FFBF\") {\n        // AC_LOAD_STATUS (standard status)\n        result.status_type = \"AC_LOAD_STATUS\";\n\n        if (data.length >= 8) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Group membership bitmap\n            result.group_membership = decodeGroupBitmap(data[1]);\n\n            // Byte 2: Operating status (level)\n            result.operating_level = decodeOperatingLevel(data[2]);\n\n            // Byte 3: Mode, capability, and priority bits\n            const byte3 = data[3];\n            result.operating_mode = decodeOperatingMode(decodeBits(byte3, 0, 1));\n            result.variable_capability = decodeVariableCapability(decodeBits(byte3, 2, 3));\n            result.load_priority = decodePriority(decodeBits(byte3, 4, 7));\n\n            // Byte 4: Delay\n            result.activation_delay = decodeDelay(data[4]);\n\n            // Byte 5: Demanded current\n            result.demanded_current = decodeCurrent(data[5]);\n\n            // Bytes 6-7: Present current (uint16, little-endian)\n            const presentCurrentRaw = decodeUint16(data, 6);\n            result.present_current = decodeCurrent(Math.min(presentCurrentRaw, 255)); // Scale down if needed\n\n            // Raw values for debugging\n            result.raw_present_current = presentCurrentRaw;\n            result.raw_control_byte = byte3;\n        }\n\n    } else if (dgnHex === \"1FEDD\") {\n        // AC_LOAD_STATUS_2 (extended status)\n        result.status_type = \"AC_LOAD_STATUS_2\";\n\n        if (data.length >= 4) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Status bits\n            const byte1 = data[1];\n            const lockStatus = decodeBits(byte1, 0, 1);\n            const overcurrentStatus = decodeBits(byte1, 2, 3);\n            const overrideStatus = decodeBits(byte1, 4, 5);\n            const enableStatus = decodeBits(byte1, 6, 7);\n\n            const statusStates = [\"Normal\", \"Active/Fault\", \"Reserved\", \"Not Supported\"];\n            result.lock_status = lockStatus === 0 ? \"Unlocked\" : statusStates[lockStatus] || \"Unknown\";\n            result.overcurrent_status = statusStates[overcurrentStatus] || \"Unknown\";\n            result.override_status = statusStates[overrideStatus] || \"Unknown\";\n            result.enable_status = enableStatus === 0 ? \"Enabled\" : statusStates[enableStatus] || \"Unknown\";\n\n            // Byte 2: Last command\n            result.last_command = data[2]; // Command code - would need command lookup table for name\n\n            // Byte 3: Interlock status\n            if (data.length > 3) {\n                const interlockStatus = decodeBits(data[3], 0, 1);\n                result.interlock_status = interlockStatus === 0 ? \"Not Active\" :\n                    interlockStatus === 1 ? \"Active\" : \"Not Supported\";\n            }\n\n            // Raw values for debugging\n            result.raw_status_byte = byte1;\n        }\n    }\n\n    // Add convenience fields\n    if (result.operating_level !== undefined) {\n        result.load_active = typeof result.operating_level === 'number' && result.operating_level > 0;\n    }\n\n    if (result.variable_capability !== undefined) {\n        result.is_dimmable = result.variable_capability.includes(\"Dimmable\");\n    }\n\n    if (result.operating_mode !== undefined) {\n        result.can_auto_control = result.operating_mode === \"Automatic\";\n    }\n\n    // Load health assessment\n    result.load_healthy = true;\n    if (result.overcurrent_status === \"Active/Fault\") result.load_healthy = false;\n    if (result.enable_status === \"Active/Fault\") result.load_healthy = false;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the AC_LOAD_STATUS message\nconst decodedData = decodeACLoadMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1180,
        "wires": [
            [
                "77e3defd386ce8a8"
            ]
        ]
    },
    {
        "id": "77e3defd386ce8a8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AC_LOAD_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1180,
        "wires": []
    },
    {
        "id": "a0357de00b26b002",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_STATUS",
        "func": "// ATS_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes ATS_STATUS messages per RV-C specification\n// Handles automatic transfer switch status and source selection\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_STATUS Specific Decoders ===\n\nfunction decodeATSInstance(value) {\n    // ATS instance interpretation per RV-C spec\n    if (value >= 1 && value <= 6) {\n        return value; // Valid instances\n    } else if (value === 0 || value >= 7) {\n        return \"Invalid Instance\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSourceInUse(value) {\n    // Source currently in use\n    if (value === 0) {\n        return \"Primary\";\n    } else if (value >= 1 && value <= 6) {\n        return `Source ${value}`;\n    } else if (value === 253) {\n        return \"No Source Active\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid Source\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return modes[value] || \"Unknown\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeATSMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_STATUS\"\n    };\n\n    if (data.length >= 3) {\n        // Byte 0: ATS Instance\n        result.instance = decodeATSInstance(data[0]);\n\n        // Byte 1: Source in use\n        result.source_in_use = decodeSourceInUse(data[1]);\n\n        // Byte 2: Operating mode (bits 0-1)\n        const byte2 = data[2];\n        result.operating_mode = decodeOperatingMode(decodeBits(byte2, 0, 1));\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_source = data[1];\n        result.raw_mode_byte = byte2;\n    }\n\n    // Add convenience fields\n    result.has_active_source = result.source_in_use !== \"No Source Active\" &&\n        result.source_in_use !== \"Not Available\" &&\n        !result.source_in_use.includes(\"Invalid\");\n\n    result.is_automatic_mode = result.operating_mode === \"Automatic\";\n    result.is_manual_mode = result.operating_mode === \"Manual\";\n\n    result.using_primary_source = result.source_in_use === \"Primary\";\n\n    // Overall status assessment\n    if (result.has_active_source) {\n        result.transfer_switch_status = `Active on ${result.source_in_use}`;\n    } else {\n        result.transfer_switch_status = \"No Active Source\";\n    }\n\n    if (result.operating_mode === \"Manual\") {\n        result.transfer_switch_status += \" (Manual Mode)\";\n    } else if (result.operating_mode === \"Automatic\") {\n        result.transfer_switch_status += \" (Automatic Mode)\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_STATUS message\nconst decodedData = decodeATSMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1240,
        "wires": [
            [
                "fa30f6cf9bede7e9"
            ]
        ]
    },
    {
        "id": "fa30f6cf9bede7e9",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 1240,
        "wires": []
    },
    {
        "id": "4a6d57460d64c76f",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_DIMMER_STATUS",
        "func": "// DC_DIMMER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes DC_DIMMER_STATUS_1/2/3 messages per RV-C specification\n// Handles RGB/RGBW dimmer loads with brightness, current, and fault monitoring\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === DC_DIMMER_STATUS Specific Decoders ===\n\nfunction decodeDimmerInstance(value) {\n    // Dimmer instance interpretation per RV-C spec\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeBrightnessLevel(value) {\n    // Brightness level (0-200% per Table 5.3)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Value Changing (Ramp)\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current per Table 5.3 (0.05A resolution for small currents)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeChannelFault(value) {\n    // Channel fault status (2-bit field)\n    const faultStates = {\n        0: \"No Fault\",\n        1: \"Undercurrent (Open Circuit)\",\n        2: \"Overcurrent\",\n        3: \"Reserved\"\n    };\n    return faultStates[value] || \"Unknown\";\n}\n\nfunction decodeFaultByte(value) {\n    // Decode fault bits from byte 5 (STATUS_2)\n    const masterFault = decodeBits(value, 0, 1);\n    const redFault = decodeBits(value, 2, 3);\n    const greenFault = decodeBits(value, 4, 5);\n    const blueFault = decodeBits(value, 6, 7);\n\n    const faults = [];\n    if (masterFault > 0) faults.push(`Master: ${decodeChannelFault(masterFault)}`);\n    if (redFault > 0) faults.push(`Red: ${decodeChannelFault(redFault)}`);\n    if (greenFault > 0) faults.push(`Green: ${decodeChannelFault(greenFault)}`);\n    if (blueFault > 0) faults.push(`Blue: ${decodeChannelFault(blueFault)}`);\n\n    return {\n        fault_summary: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        master_fault: decodeChannelFault(masterFault),\n        red_fault: decodeChannelFault(redFault),\n        green_fault: decodeChannelFault(greenFault),\n        blue_fault: decodeChannelFault(blueFault),\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << i;\n        if (!(value & groupBit)) { // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingStatus(value) {\n    // Operating status for STATUS_3\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step\n    } else if (value === 251) {\n        return \"Value Changing (Ramp)\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeStatus3Byte3(value) {\n    // Decode status bits from byte 3 (STATUS_3)\n    const lockStatus = decodeBits(value, 0, 1);\n    const overcurrentStatus = decodeBits(value, 2, 3);\n    const overrideStatus = decodeBits(value, 4, 5);\n    const enableStatus = decodeBits(value, 6, 7);\n\n    const lockStates = [\"Unlocked\", \"Locked\", \"Reserved\", \"Not Supported\"];\n    const statusStates = [\"Normal/Inactive\", \"Active/Abnormal\", \"Reserved\", \"Not Supported\"];\n    const enableStates = [\"Enabled\", \"Disabled\", \"Reserved\", \"Not Supported\"];\n\n    return {\n        lock_status: lockStates[lockStatus] || \"Unknown\",\n        overcurrent_status: statusStates[overcurrentStatus] || \"Unknown\",\n        override_status: statusStates[overrideStatus] || \"Unknown\",\n        enable_status: enableStates[enableStatus] || \"Unknown\"\n    };\n}\n\nfunction decodeLastCommand(value) {\n    // Last executed command (STATUS_3)\n    const commands = {\n        0: \"Set Brightness\",\n        1: \"ON\",\n        2: \"ON Delay\",\n        3: \"OFF\",\n        4: \"Stop\",\n        5: \"Toggle\",\n        6: \"Memory OFF\",\n        7: \"Save Scene\",\n        11: \"Ramp Brightness\",\n        12: \"Ramp Toggle\",\n        13: \"Ramp Up\",\n        14: \"Ramp Down\",\n        15: \"Ramp Up/Down\",\n        16: \"Ramp Up/Down Toggle\",\n        21: \"Lock\",\n        22: \"Unlock\",\n        31: \"Flash\",\n        32: \"Flash Momentary\",\n        33: \"Flash Pattern\",\n        34: \"Scene Recall\",\n        35: \"Scene Store\",\n        36: \"Group Command\",\n        37: \"Reset\",\n        38: \"Factory Reset\",\n        39: \"Calibrate\",\n        40: \"Test Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeDelayDuration(value) {\n    // Delay/Duration field (STATUS_3)\n    if (value === 0) {\n        return \"Expired\";\n    } else if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 252) {\n        return \"Flashing\";\n    } else if (value === 253) {\n        return \">240 seconds\";\n    } else if (value === 255) {\n        return \"No delay active\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeStatus3Byte6(value) {\n    // Decode status bits from byte 6 (STATUS_3)\n    const interlockStatus = decodeBits(value, 0, 1);\n    const loadStatus = decodeBits(value, 2, 3);\n    const undercurrentStatus = decodeBits(value, 6, 7);\n\n    const interlockStates = [\"Not Active\", \"Active\", \"Reserved\", \"Not Supported\"];\n    const loadStates = [\"Off (status=0)\", \"On (status>0 or flashing)\", \"Reserved\", \"Reserved\"];\n    const undercurrentStates = [\"Normal\", \"Active\", \"Timeout Error\", \"Not Supported\"];\n\n    return {\n        interlock_status: interlockStates[interlockStatus] || \"Unknown\",\n        load_status: loadStates[loadStatus] || \"Unknown\",\n        undercurrent_status: undercurrentStates[undercurrentStatus] || \"Unknown\"\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeDCDimmerMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"DC_DIMMER_STATUS\"\n    };\n\n    // Determine which STATUS message based on DGN and decode accordingly\n    const dgnHex = dgn.toUpperCase();\n\n    if (dgnHex === \"1FFBB\") {\n        // DC_DIMMER_STATUS_1 - Brightness levels and timing\n        result.status_type = \"STATUS_1\";\n\n        if (data.length >= 7) {\n            result.instance = decodeDimmerInstance(data[0]);\n            result.master_brightness = decodeBrightnessLevel(data[1]);\n            result.red_brightness = decodeBrightnessLevel(data[2]);\n            result.green_brightness = decodeBrightnessLevel(data[3]);\n            result.blue_brightness = decodeBrightnessLevel(data[4]);\n\n            // Byte 5: On/Off Duration (4 bits each)\n            result.on_duration = decodeBits(data[5], 0, 3); // 0-14 seconds\n            result.off_duration = decodeBits(data[5], 4, 7); // 0-14 seconds\n\n            if (data.length > 6) {\n                result.white_brightness = decodeBrightnessLevel(data[6]);\n            }\n        }\n\n    } else if (dgnHex === \"1FFBA\") {\n        // DC_DIMMER_STATUS_2 - Current measurements and faults\n        result.status_type = \"STATUS_2\";\n\n        if (data.length >= 8) {\n            result.instance = decodeDimmerInstance(data[0]);\n            result.master_current = decodeDCCurrent(data[1]);\n            result.red_current = decodeDCCurrent(data[2]);\n            result.green_current = decodeDCCurrent(data[3]);\n            result.blue_current = decodeDCCurrent(data[4]);\n\n            // Byte 5: Fault bits\n            const faultInfo = decodeFaultByte(data[5]);\n            Object.assign(result, faultInfo);\n\n            if (data.length > 6) {\n                result.white_current = decodeDCCurrent(data[6]);\n            }\n\n            if (data.length > 7) {\n                // Byte 7: White fault (bits 0-1)\n                const whiteFault = decodeBits(data[7], 0, 1);\n                result.white_fault = decodeChannelFault(whiteFault);\n            }\n        }\n\n    } else if (dgnHex === \"1FEDA\") {\n        // DC_DIMMER_STATUS_3 - Comprehensive operational status\n        result.status_type = \"STATUS_3\";\n\n        if (data.length >= 8) {\n            result.instance = decodeDimmerInstance(data[0]);\n            result.group_membership = decodeGroupBitmap(data[1]);\n            result.operating_status = decodeOperatingStatus(data[2]);\n\n            // Byte 3: Status bits\n            const status3Info = decodeStatus3Byte3(data[3]);\n            Object.assign(result, status3Info);\n\n            result.delay_duration = decodeDelayDuration(data[4]);\n            result.last_command = decodeLastCommand(data[5]);\n\n            // Byte 6: More status bits\n            const status6Info = decodeStatus3Byte6(data[6]);\n            Object.assign(result, status6Info);\n\n            result.master_memory_value = decodeBrightnessLevel(data[7]);\n        }\n    }\n\n    // Add convenience fields\n    if (result.master_brightness !== undefined) {\n        result.dimmer_on = typeof result.master_brightness === 'number' && result.master_brightness > 0;\n    }\n\n    if (result.operating_status !== undefined) {\n        result.dimmer_active = typeof result.operating_status === 'number' && result.operating_status > 0;\n    }\n\n    if (result.any_fault !== undefined) {\n        result.dimmer_healthy = !result.any_fault;\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the DC_DIMMER_STATUS message\nconst decodedData = decodeDCDimmerMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1300,
        "wires": [
            [
                "2f9602cc8a3d1649"
            ]
        ]
    },
    {
        "id": "d76a4a48e1beaed6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FURNACE_STATUS",
        "func": "// FURNACE_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes FURNACE_STATUS messages per RV-C specification\n// Handles gas/diesel furnace operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === FURNACE_STATUS Specific Decoders ===\n\nfunction decodeFurnaceInstance(value) {\n    // Furnace instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Furnace operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Pre-Purge\",\n        3: \"Ignition\",\n        4: \"Flame Established\",\n        5: \"Running\",\n        6: \"Post-Purge\",\n        7: \"Shutdown\",\n        8: \"Lockout\",\n        9: \"Fault\",\n        10: \"Safety Check\",\n        11: \"Cool Down\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeFurnaceCommand(value) {\n    // Furnace command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Reset Fault\",\n        3: \"Test\",\n        4: \"Service Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Propane\",\n        2: \"Diesel\",\n        3: \"Gasoline\",\n        4: \"Natural Gas\",\n        5: \"Electric\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeAirFlow(value) {\n    // Air flow in CFM (Cubic Feet per Minute)\n    if (value <= 65000) {\n        return value; // Direct CFM value\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Ignition Failure\",\n        2: \"Flame Loss\",\n        3: \"High Temperature\",\n        4: \"Low Gas Pressure\",\n        5: \"High Gas Pressure\",\n        6: \"Fan Failure\",\n        7: \"Igniter Failure\",\n        8: \"Flame Sensor Failure\",\n        9: \"Control Board Fault\",\n        10: \"Safety Lockout\",\n        11: \"Overheat\",\n        12: \"Airflow Problem\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Flame Present\");\n    if (value & 0x02) statusBits.push(\"Igniter On\");\n    if (value & 0x04) statusBits.push(\"Gas Valve Open\");\n    if (value & 0x08) statusBits.push(\"Fan Running\");\n    if (value & 0x10) statusBits.push(\"Safety Circuit OK\");\n    if (value & 0x20) statusBits.push(\"High Limit OK\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific FURNACE_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeFurnaceInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeFurnaceCommand(value);\n        }\n        if (param.name === 'fuel type') {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'fan speed') {\n            return decodeFanSpeed(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'air flow' || param.name.includes('flow')) {\n            return decodeAirFlow(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeFurnaceMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"FURNACE_STATUS\"\n    };\n\n    // Decode based on FURNACE_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeFurnaceInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Byte 3: Exhaust Temperature\n        result.exhaust_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Intake Temperature\n        result.intake_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[5]);\n\n        // Bytes 6-7: Air Flow (16-bit, little-endian)\n        const airFlow = data[6] | (data[7] << 8);\n        result.air_flow = decodeAirFlow(airFlow);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_exhaust_temperature = data[3];\n        result.raw_intake_temperature = data[4];\n        result.raw_fan_speed = data[5];\n        result.raw_air_flow_bytes = [data[6], data[7]];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.furnace_running = state === \"running\";\n        result.furnace_heating = [\"flame established\", \"running\"].includes(state);\n        result.furnace_available = ![\"fault\", \"lockout\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"lockout\") || state.includes(\"error\");\n        result.is_starting = [\"starting\", \"pre-purge\", \"ignition\"].includes(state);\n        result.is_shutting_down = [\"post-purge\", \"shutdown\", \"cool down\"].includes(state);\n    }\n\n    // Temperature status\n    result.exhaust_temp_available = typeof result.exhaust_temperature === 'number';\n    result.intake_temp_available = typeof result.intake_temperature === 'number';\n\n    // Fan status\n    result.fan_running = typeof result.fan_speed === 'number' && result.fan_speed > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the FURNACE_STATUS message\nconst decodedData = decodeFurnaceMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 520,
        "wires": [
            [
                "9d90b7163a12d5ed"
            ]
        ]
    },
    {
        "id": "9d90b7163a12d5ed",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "FURNACE_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 520,
        "wires": []
    },
    {
        "id": "fbc5efde2c447eda",
        "type": "link in",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS in",
        "links": [
            "02bdfc59de71b5a5"
        ],
        "x": 220,
        "y": 80,
        "wires": [
            [
                "9f88f215f3f07227"
            ]
        ],
        "l": true
    },
    {
        "id": "ffd5bc5ca5695602",
        "type": "inject",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 660,
        "wires": [
            [
                "09640adb1fd08fbb"
            ]
        ]
    },
    {
        "id": "09640adb1fd08fbb",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecodedStatus\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "b797e5a52b6db5b4",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Unique STATUS",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecodedStatus = flow.get(\"uniqueDecodedStatus\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgnName);\n\n// Check if it's a new unique message\nif (!uniqueDecodedStatus.includes(newMsgStr)) {\n    uniqueDecodedStatus.push(newMsgStr);\n    flow.set(\"uniqueDecodedStatus\", uniqueDecodedStatus);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 140,
        "y": 720,
        "wires": [
            [
                "48e6dda2b2d9575e"
            ]
        ]
    },
    {
        "id": "48e6dda2b2d9575e",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "New Unique Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 720,
        "wires": []
    },
    {
        "id": "d0e2cc417cf65b90",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 280,
        "wires": []
    },
    {
        "id": "ccec30ad0f32bbdf",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_1",
        "func": "// THERMOSTAT_STATUS_1 Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_STATUS_1 messages per RV-C specification\n// Handles primary thermostat control and status information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_1 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode mapping per RV-C specification (extended)\n    const modes = {\n        0: \"Off\",\n        1: \"Auto\",\n        2: \"Heat\",\n        3: \"Cool\",\n        4: \"Furnace\",\n        5: \"Fan Only\",\n        6: \"Dry\",\n        7: \"Emergency Heat\",\n        8: \"Heat Pump\",\n        9: \"Defrost\",\n        10: \"Aux Heat\",\n        11: \"Eco Mode\",\n        12: \"Sleep Mode\",\n        13: \"Away Mode\",\n        14: \"Manual Override\",\n        15: \"Vacation Mode\",\n        16: \"Schedule Mode\",\n        17: \"Temperature Hold\",\n        18: \"Energy Save\",\n        19: \"Quick Heat\",\n        20: \"Quick Cool\",\n        21: \"System Test\",\n        22: \"Calibration\",\n        23: \"Service Mode\",\n        24: \"Installation Mode\",\n        25: \"Demo Mode\",\n        26: \"Lock Mode\",\n        27: \"Filter Mode\",\n        28: \"Humidity Control\",\n        29: \"Dehumidify\",\n        30: \"Humidify\",\n        31: \"Air Quality Mode\",\n        32: \"Zone Control\",\n        33: \"Multi-Stage Heat\",\n        34: \"Multi-Stage Cool\",\n        35: \"Heat Recovery\",\n        36: \"Ventilation Mode\",\n        37: \"Fresh Air Mode\",\n        38: \"Recirculate Mode\",\n        39: \"Purge Mode\",\n        40: \"Startup Mode\",\n        41: \"Shutdown Mode\",\n        42: \"Fault Recovery\",\n        43: \"Performance Test\",\n        44: \"Efficiency Mode\",\n        45: \"Comfort Mode\",\n        46: \"Advanced Auto\",\n        47: \"Smart Mode\",\n        48: \"Remote Control\",\n        49: \"Mobile App Control\",\n        50: \"Voice Control\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return modes[value] || `Unknown Mode ${value}`;\n}\n\nfunction decodeFanMode(value) {\n    // Fan mode mapping\n    const fanModes = {\n        0: \"Auto\",\n        1: \"On\",\n        2: \"Low\",\n        3: \"Medium\",\n        4: \"High\",\n        5: \"Variable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fanModes[value] || `Unknown Fan Mode ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset (-40°C to +170°C range)\n    if (value <= 210) {\n        const temp = value - 40; // Offset by 40 degrees\n        if (isCelsius) {\n            return parseFloat(temp.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Heating Active\");\n    if (value & 0x02) statusBits.push(\"Cooling Active\");\n    if (value & 0x04) statusBits.push(\"Fan Running\");\n    if (value & 0x08) statusBits.push(\"Aux Heat Active\");\n    if (value & 0x10) statusBits.push(\"Defrost Active\");\n    if (value & 0x20) statusBits.push(\"System Fault\");\n    if (value & 0x40) statusBits.push(\"Filter Change Required\");\n    if (value & 0x80) statusBits.push(\"Service Required\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage (0-100%)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus1Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_1\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_1 format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Operating Mode\n        result.operating_mode = decodeOperatingMode(data[1]);\n\n        // Byte 2: Fan Mode\n        result.fan_mode = decodeFanMode(data[2]);\n\n        // Byte 3: Set Point Temperature\n        result.set_point_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: System Status\n        result.system_status = decodeSystemStatus(data[5]);\n\n        // Byte 6: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[6]);\n\n        // Byte 7: Reserved/Future use\n        // Typically 0xFF in current implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_mode = data[1];\n        result.raw_fan_mode = data[2];\n        result.raw_set_point_temperature = data[3];\n        result.raw_ambient_temperature = data[4];\n        result.raw_system_status = data[5];\n        result.raw_fan_speed = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.thermostat_available = result.instance !== \"Not Available\" &&\n                                  result.operating_mode !== \"Not Available\";\n\n    result.temperature_available = typeof result.ambient_temperature === 'number' &&\n                                   typeof result.set_point_temperature === 'number';\n\n    // Calculate temperature difference if both temps available\n    if (result.temperature_available) {\n        result.temperature_difference = parseFloat((result.ambient_temperature - result.set_point_temperature).toFixed(1));\n        result.needs_heating = result.temperature_difference < -1; // More than 1°F below setpoint\n        result.needs_cooling = result.temperature_difference > 1;  // More than 1°F above setpoint\n    }\n\n    // System operating status\n    if (typeof result.system_status === 'string' && result.system_status !== \"Not Available\") {\n        result.heating_active = result.system_status.includes(\"Heating Active\");\n        result.cooling_active = result.system_status.includes(\"Cooling Active\");\n        result.fan_running = result.system_status.includes(\"Fan Running\");\n        result.aux_heat_active = result.system_status.includes(\"Aux Heat Active\");\n        result.defrost_active = result.system_status.includes(\"Defrost Active\");\n        result.system_fault = result.system_status.includes(\"System Fault\");\n        result.filter_change_required = result.system_status.includes(\"Filter Change Required\");\n        result.service_required = result.system_status.includes(\"Service Required\");\n        result.system_active = result.heating_active || result.cooling_active || result.defrost_active;\n    } else {\n        result.heating_active = false;\n        result.cooling_active = false;\n        result.fan_running = false;\n        result.aux_heat_active = false;\n        result.defrost_active = false;\n        result.system_fault = false;\n        result.filter_change_required = false;\n        result.service_required = false;\n        result.system_active = false;\n    }\n\n    // Operating mode status\n    result.is_off = result.operating_mode === \"Off\";\n    result.is_auto_mode = result.operating_mode === \"Auto\";\n    result.is_heating_mode = result.operating_mode === \"Heat\" || result.operating_mode === \"Furnace\" ||\n                             result.operating_mode === \"Heat Pump\" || result.operating_mode === \"Emergency Heat\";\n    result.is_cooling_mode = result.operating_mode === \"Cool\";\n\n    // Fan status\n    result.fan_auto_mode = result.fan_mode === \"Auto\";\n    result.fan_on_mode = result.fan_mode === \"On\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_1 message\nconst decodedData = decodeThermostatStatus1Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 280,
        "wires": [
            [
                "d0e2cc417cf65b90"
            ]
        ]
    },
    {
        "id": "45ae070eafc9a732",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "TANK_STATUS",
        "mode": "link",
        "links": [
            "61f4573c56915577"
        ],
        "x": 1200,
        "y": 220,
        "wires": [],
        "l": true
    },
    {
        "id": "2f9602cc8a3d1649",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS",
        "mode": "link",
        "links": [
            "7313d7c724d31538"
        ],
        "x": 1230,
        "y": 1300,
        "wires": [],
        "l": true
    },
    {
        "id": "bff245b2ca47ef79",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_SOURCE_STATUS",
        "mode": "link",
        "links": [
            "663120adc5ec254f"
        ],
        "x": 1230,
        "y": 1120,
        "wires": [],
        "l": true
    },
    {
        "id": "7e609140970f546c",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Load on Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 200,
        "y": 80,
        "wires": [
            [
                "74c7e4a6cc2508eb"
            ]
        ]
    },
    {
        "id": "74c7e4a6cc2508eb",
        "type": "file in",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Read DGN table",
        "filename": "/config/projects/rv-link/rvc/dgn-summary-table.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "allProps": false,
        "x": 400,
        "y": 80,
        "wires": [
            [
                "c78420a075d43408"
            ]
        ]
    },
    {
        "id": "cd670f6465b6374b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Store dgnTable",
        "func": "// Convert the data to a Map when initially storing it\nconst dgnMap = new Map(\n    msg.payload.map(entry => [\n        entry.Hex.toString().toUpperCase(),\n        entry.DGN\n    ])\n);\n\n// Add the special case for FECA\n//if (dgnMap.has('FECA')) {\n//    dgnMap.set('1FECA', dgnMap.get('FECA'));\n//}\n\n// Store the Map in global context\nglobal.set('dgnMap', dgnMap);\n\n// Count the number of records\nconst decoderCount = dgnMap.size;\n\n// Update the node status to indicate success\nnode.status({ fill: 'green', shape: 'dot', text: `Config loaded, ${decoderCount} records` });\nreturn null;",
        "outputs": 0,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 80,
        "wires": []
    },
    {
        "id": "c78420a075d43408",
        "type": "json",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 610,
        "y": 80,
        "wires": [
            [
                "cd670f6465b6374b"
            ]
        ]
    },
    {
        "id": "19e68bc19dddefb9",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "Encode CAN message",
        "func": "// RV-C CAN Message Encoder - Complete and Accurate Implementation\n// Constructs a complete RV-C CAN message from DGN and data payload per RV-C specification\n// Supports 29-bit CAN ID construction with proper priority, DGN, and source address handling\n//\n// Input: msg.payload object with encoding parameters\n// Output: msg.payload string with complete CAN message ready for transmission\n\n// === Configuration ===\n\nconst CONFIG = {\n    // Default source address for this Node-RED instance\n    // Using high dynamic address range (240-253) to avoid conflicts\n    DEFAULT_SOURCE_ADDRESS: 0xF5, // 245 decimal - high unused dynamic address\n\n    // Default priority for different message types\n    DEFAULT_PRIORITY: {\n        COMMAND: 3,        // High priority for commands\n        STATUS: 6,         // Standard priority for status messages\n        CONFIGURATION: 6,  // Standard priority for configuration\n        DATA: 6           // Standard priority for general data\n    },\n\n    // Default MQTT topic for CAN transmission\n    DEFAULT_MQTT_TOPIC: \"can/send\",\n\n    // Message validation limits\n    MAX_DATA_LENGTH: 16,  // 8 bytes = 16 hex characters\n    MIN_DATA_LENGTH: 2,   // At least 1 byte = 2 hex characters\n    MAX_DGN_VALUE: 0x1FFFF, // 18-bit maximum\n    MAX_PRIORITY: 7,      // 3-bit maximum\n    MAX_SOURCE_ADDRESS: 255 // 8-bit maximum\n};\n\n// === Input Validation Functions ===\n\nfunction validateHexString(value, name, minLength = 1, maxLength = Infinity) {\n    if (!value || typeof value !== 'string') {\n        throw new Error(`${name} must be a non-empty string`);\n    }\n\n    if (!/^[0-9A-Fa-f]+$/.test(value)) {\n        throw new Error(`${name} must contain only hexadecimal characters (0-9, A-F)`);\n    }\n\n    if (value.length < minLength || value.length > maxLength) {\n        throw new Error(`${name} length must be between ${minLength} and ${maxLength} characters`);\n    }\n\n    return true;\n}\n\nfunction validateNumericRange(value, name, min, max) {\n    if (typeof value !== 'number' || isNaN(value)) {\n        throw new Error(`${name} must be a number`);\n    }\n\n    if (value < min || value > max) {\n        throw new Error(`${name} must be between ${min} and ${max}`);\n    }\n\n    return true;\n}\n\nfunction determinePriority(dgn, messageType) {\n    // Determine priority based on DGN and message type\n    if (messageType) {\n        const upperType = messageType.toUpperCase();\n        if (CONFIG.DEFAULT_PRIORITY[upperType] !== undefined) {\n            return CONFIG.DEFAULT_PRIORITY[upperType];\n        }\n    }\n\n    // Priority based on DGN characteristics\n    const dgnNum = parseInt(dgn, 16);\n\n    // Command messages typically have higher priority\n    if ((dgnNum >= 0x1FEDB && dgnNum <= 0x1FEDC) || // DC_DIMMER commands\n        (dgnNum >= 0x1FFB9 && dgnNum <= 0x1FFBC) || // DC_DIMMER/LOAD commands\n        (dgn.toLowerCase().includes('command'))) {\n        return CONFIG.DEFAULT_PRIORITY.COMMAND;\n    }\n\n    // Status messages use standard priority\n    return CONFIG.DEFAULT_PRIORITY.STATUS;\n}\n\n// === CAN ID Construction ===\n\nfunction constructCANId(priority, dgn, sourceAddress) {\n    const dgnNum = parseInt(dgn, 16);\n\n    // Validate ranges\n    validateNumericRange(priority, 'Priority', 0, CONFIG.MAX_PRIORITY);\n    validateNumericRange(dgnNum, 'DGN', 0, CONFIG.MAX_DGN_VALUE);\n    validateNumericRange(sourceAddress, 'Source Address', 0, CONFIG.MAX_SOURCE_ADDRESS);\n\n    // Construct 29-bit CAN ID per RV-C specification:\n    // [Priority:3][Reserved:1][Data Page:1][DGN:18][Source Address:8]\n    // Note: Reserved and Data Page bits are typically 0 for RV-C\n    const canId = (priority << 26) | (dgnNum << 8) | sourceAddress;\n\n    // Ensure we don't exceed 29-bit limit\n    if (canId > 0x1FFFFFFF) {\n        throw new Error('Constructed CAN ID exceeds 29-bit limit');\n    }\n\n    return canId;\n}\n\n// === Main Logic ===\n\ntry {\n    // Validate input payload structure\n    if (!msg.payload || typeof msg.payload !== 'object') {\n        throw new Error('msg.payload must be an object');\n    }\n\n    const input = msg.payload;\n\n    // Extract required fields\n    const dgn = input.dgn;\n    const dataPayload = input.dataPayload || input.data;\n\n    if (!dgn) {\n        throw new Error('msg.payload.dgn is required');\n    }\n\n    if (!dataPayload) {\n        throw new Error('msg.payload.dataPayload (or msg.payload.data) is required');\n    }\n\n    // Validate DGN\n    validateHexString(dgn, 'DGN', 1, 5); // 1-5 hex chars for DGN\n\n    // Validate data payload\n    validateHexString(dataPayload, 'Data Payload', CONFIG.MIN_DATA_LENGTH, CONFIG.MAX_DATA_LENGTH);\n\n    // Data payload must be even length (complete bytes)\n    if (dataPayload.length % 2 !== 0) {\n        throw new Error('Data payload must have even length (complete hex bytes)');\n    }\n\n    // Extract optional parameters with defaults\n    const priority = input.priority !== undefined ?\n        input.priority :\n        determinePriority(dgn, input.messageType);\n\n    const sourceAddress = input.sourceAddress !== undefined ?\n        input.sourceAddress :\n        CONFIG.DEFAULT_SOURCE_ADDRESS;\n\n    // Construct the CAN ID\n    const canIdNum = constructCANId(priority, dgn, sourceAddress);\n\n    // Format CAN ID as 8-character uppercase hex string\n    const canIdHex = canIdNum.toString(16).toUpperCase().padStart(8, '0');\n\n    // Construct the complete CAN message\n    const canMessage = `${canIdHex}#${dataPayload.toUpperCase()}`;\n\n    // Set output topic and payload\n    msg.topic = input.topic || msg.topic || CONFIG.DEFAULT_MQTT_TOPIC;\n    msg.payload = canMessage;\n\n    // Add metadata for debugging/logging\n    msg.canMetadata = {\n        dgn: dgn.toUpperCase(),\n        dgnDecimal: parseInt(dgn, 16),\n        priority: priority,\n        sourceAddress: sourceAddress,\n        sourceAddressHex: sourceAddress.toString(16).toUpperCase().padStart(2, '0'),\n        canIdHex: canIdHex,\n        canIdDecimal: canIdNum,\n        dataLength: dataPayload.length / 2,\n        originalInput: input\n    };\n\n    // Status indication for successful encoding\n    node.status({\n        fill: 'green',\n        shape: 'dot',\n        text: `Encoded DGN:${dgn} SA:${sourceAddress.toString(16).toUpperCase()}`\n    });\n\n    return msg;\n\n} catch (error) {\n    // Handle all validation and encoding errors\n    node.error(`CAN encoding failed: ${error.message}`, msg);\n    node.status({\n        fill: 'red',\n        shape: 'ring',\n        text: `Error: ${error.message.substring(0, 20)}...`\n    });\n\n    // Return error details for debugging\n    msg.encodingError = {\n        message: error.message,\n        timestamp: new Date().toISOString(),\n        input: msg.payload\n    };\n\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 540,
        "wires": [
            [
                "e7ae35364ce60f3f",
                "cacf35b859af22a9"
            ]
        ]
    },
    {
        "id": "cacf35b859af22a9",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 630,
        "y": 480,
        "wires": []
    },
    {
        "id": "e7ae35364ce60f3f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 540,
        "wires": []
    },
    {
        "id": "4fce77126a105df2",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN out",
        "links": [],
        "x": 160,
        "y": 540,
        "wires": [
            [
                "19e68bc19dddefb9"
            ]
        ],
        "l": true
    },
    {
        "id": "f658418a7b9b4857",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "links": [
            "d4ef1d361f084b58",
            "1bf17ae955275cf0",
            "d3a13b531babee66",
            "ea29386f9f8682bc",
            "d38c75bc1474be23"
        ],
        "x": 160,
        "y": 480,
        "wires": [
            [
                "cacf35b859af22a9"
            ]
        ],
        "l": true
    },
    {
        "id": "b86f82e84d961549",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/+/+/set",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 360,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "64c5e5cfd4382453",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "mode": "link",
        "links": [
            "a3b957142479c075"
        ],
        "x": 610,
        "y": 360,
        "wires": [],
        "l": true
    },
    {
        "id": "2110ea4d0b85f784",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "topic": "can/raw",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 300,
        "wires": [
            [
                "32add109922d428a",
                "4ad3b304d4f1e27b"
            ]
        ]
    },
    {
        "id": "958fed9f12301f59",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "mode": "link",
        "links": [
            "2fcbc4d630144362"
        ],
        "x": 620,
        "y": 300,
        "wires": [],
        "l": true
    },
    {
        "id": "8d7d5d3ea117cf79",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "CAN decode",
        "func": "// RVC CAN Message Parser\n// Decodes a raw RVC CAN message string into a structured object.\n// Input: msg.payload (string) - e.g., \"19FEDA8C#3AFF00FDFF2100FF\"\n// Output: msg.payload (object) with decoded CAN message components\n\nconst originalMessage = msg.payload;\n\n// Validate input\nif (!originalMessage || typeof originalMessage !== 'string') {\n    node.warn(\"Invalid message payload: expected string, got \" + typeof originalMessage);\n    return null;\n}\n\n// Retrieve the DGN map from global context\nconst dgnMap = global.get('dgnMap');\nif (!dgnMap) {\n    node.error(\"dgnMap not found in global context. Ensure the map is initialized before this node receives messages.\");\n    return null;\n}\n\n// Parse CAN message format: CANID#PAYLOAD\nconst parts = originalMessage.split('#');\nif (parts.length !== 2) {\n    node.warn(\"Invalid CAN message format received: \" + originalMessage + \". Expected format: CANID#PAYLOAD\");\n    return null;\n}\n\nconst canId = parts[0];\nconst dataPayload = parts[1];\n\n// Validate CAN ID length (should be 8 hex characters for 29-bit CAN ID)\nif (canId.length < 3 || canId.length > 8) {\n    node.warn(\"Invalid CAN ID length: \" + canId + \". Expected 3-8 hex characters.\");\n    return null;\n}\n\n// Validate CAN ID is valid hexadecimal\nconst canIdNum = parseInt(canId, 16);\nif (isNaN(canIdNum)) {\n    node.warn(\"Invalid CAN ID format: \" + canId + \". Must be hexadecimal.\");\n    return null;\n}\n\n// Validate data payload is even length (hex bytes)\nif (dataPayload.length % 2 !== 0) {\n    node.warn(\"Invalid data payload length: \" + dataPayload + \". Must be even number of hex characters.\");\n    return null;\n}\n\n// Extract CAN ID fields using proper bitwise operations for 29-bit CAN ID\n// CAN ID structure: [Priority:3][Reserved:1][Data Page:1][PDU Format:8][PDU Specific:8][Source Address:8]\n\n// Extract Priority (top 3 bits of the 29-bit ID)\nconst priority = (canIdNum >> 26) & 0x7;\n\n// Extract Source Address (lowest 8 bits)\nconst sourceAddress = (canIdNum & 0xFF).toString(16).toUpperCase().padStart(2, '0');\n\n// Extract DGN (Parameter Group Number - 18 bits: bits 8-25)\nconst dgnRaw = (canIdNum >> 8) & 0x1FFFF;\nconst dgn = dgnRaw.toString(16).toUpperCase().padStart(5, '0');\n\n// Prepare DGN for lookup - remove leading zeros but keep at least one digit\nconst lookupDgn = dgn.replace(/^0+/, '') || '0';\n\n// Look up DGN name\nconst dgnName = dgnMap.get(lookupDgn) || \"UNKNOWN\";\n\n// Create structured output\nmsg.payload = {\n    originalMessage: originalMessage,\n    dgn: dgn,\n    dgnName: dgnName,\n    sourceAddress: sourceAddress,\n    priority: priority,\n    dataPayload: dataPayload,\n    // Additional fields for debugging/analysis\n    canIdHex: canId,\n    canIdDecimal: canIdNum,\n    lookupDgn: lookupDgn,\n    dataLength: dataPayload.length / 2 // Number of data bytes\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 860,
        "wires": [
            [
                "ac47ce53a9fc3f21",
                "698efabc308fece6",
                "a16ce99da6a2a88f",
                "2e131d4d25819c93",
                "a2dad25eb05117f7",
                "fc66c16576e28548",
                "c6fb02a17f709e08",
                "a6594a9464d8fe4e"
            ]
        ]
    },
    {
        "id": "ac47ce53a9fc3f21",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decoded",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 980,
        "wires": []
    },
    {
        "id": "698efabc308fece6",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dataPayload",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dataPayload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 940,
        "wires": []
    },
    {
        "id": "a16ce99da6a2a88f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgn",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgn",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 740,
        "wires": []
    },
    {
        "id": "2e131d4d25819c93",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgnName",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgnName",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 780,
        "wires": []
    },
    {
        "id": "a2dad25eb05117f7",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "originalMessage",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.originalMessage",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 700,
        "wires": []
    },
    {
        "id": "fc66c16576e28548",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "sourceAddress",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.sourceAddress",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 820,
        "wires": []
    },
    {
        "id": "c6fb02a17f709e08",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "priority",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.priority",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 900,
        "wires": []
    },
    {
        "id": "2fcbc4d630144362",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "CAN in",
        "links": [
            "958fed9f12301f59"
        ],
        "x": 150,
        "y": 860,
        "wires": [
            [
                "8d7d5d3ea117cf79"
            ]
        ],
        "l": true
    },
    {
        "id": "a6594a9464d8fe4e",
        "type": "switch",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DM-RV",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DATE_TIME_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "UNKNOWN",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_COMMAND_2",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 6,
        "x": 890,
        "y": 860,
        "wires": [
            [],
            [],
            [
                "02bdfc59de71b5a5"
            ],
            [
                "c781b519a9f9b156"
            ],
            [
                "37b11a996fc2757e"
            ],
            [
                "d0150fd6556514e6"
            ]
        ]
    },
    {
        "id": "32add109922d428a",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "can/raw",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 240,
        "wires": []
    },
    {
        "id": "1e93f7b73c40091a",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1420,
        "y": 940,
        "wires": [
            [
                "38606e245b70b98e"
            ]
        ]
    },
    {
        "id": "38606e245b70b98e",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecoded\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1680,
        "y": 940,
        "wires": [
            []
        ]
    },
    {
        "id": "d0150fd6556514e6",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Unique decoded messages",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecoded = flow.get(\"uniqueDecoded\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload);\n\n// Check if it's a new unique message\nif (!uniqueDecoded.includes(newMsgStr)) {\n    uniqueDecoded.push(newMsgStr);\n    flow.set(\"uniqueDecoded\", uniqueDecoded);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 1000,
        "wires": [
            [
                "8f7381d08bf2b8a8"
            ]
        ]
    },
    {
        "id": "8f7381d08bf2b8a8",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "New Unique",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1670,
        "y": 1000,
        "wires": []
    },
    {
        "id": "a4028527eb23fa04",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset uniqueDecoded",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1440,
        "y": 700,
        "wires": [
            [
                "092c751dcdd12270"
            ]
        ]
    },
    {
        "id": "092c751dcdd12270",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset function",
        "func": "flow.set(\"uniqueUNKNOWN\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1680,
        "y": 700,
        "wires": [
            []
        ]
    },
    {
        "id": "c781b519a9f9b156",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Unique UNKNOWN",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueUNKNOWN = flow.get(\"uniqueUNKNOWN\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload);\n\n// Check if it's a new unique message\nif (!uniqueUNKNOWN.includes(newMsgStr)) {\n    uniqueUNKNOWN.push(newMsgStr);\n    flow.set(\"uniqueUNKNOWN\", uniqueUNKNOWN);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 760,
        "wires": [
            [
                "eea1641469efb23f"
            ]
        ]
    },
    {
        "id": "eea1641469efb23f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "New UNKNOWN",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1690,
        "y": 760,
        "wires": []
    },
    {
        "id": "c6fd91cf9695813b",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "Open/Close",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "control",
        "payload": "toggle",
        "payloadType": "str",
        "x": 190,
        "y": 240,
        "wires": [
            [
                "4ad3b304d4f1e27b"
            ]
        ]
    },
    {
        "id": "4ad3b304d4f1e27b",
        "type": "gate",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "",
        "controlTopic": "control",
        "defaultState": "closed",
        "openCmd": "open",
        "closeCmd": "close",
        "toggleCmd": "toggle",
        "defaultCmd": "default",
        "statusCmd": "status",
        "persist": false,
        "x": 370,
        "y": 300,
        "wires": [
            [
                "958fed9f12301f59"
            ]
        ]
    },
    {
        "id": "02bdfc59de71b5a5",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "STATUS out",
        "mode": "link",
        "links": [
            "fbc5efde2c447eda"
        ],
        "x": 1070,
        "y": 740,
        "wires": [],
        "l": true
    },
    {
        "id": "d34a8c1fd2cc4320",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 610,
        "y": 420,
        "wires": []
    },
    {
        "id": "37b11a996fc2757e",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "DC_DIMMER_COMMAND_2",
        "mode": "link",
        "links": [
            "44947b512cb27b5b"
        ],
        "x": 1420,
        "y": 840,
        "wires": [],
        "l": true
    },
    {
        "id": "802228bc8d89d80a",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "a2d2ed96ff4615f9",
        "type": "function",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${type}_${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 160,
        "wires": [
            [
                "d38c75bc1474be23"
            ]
        ]
    },
    {
        "id": "d38c75bc1474be23",
        "type": "link out",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "MQTT Out",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 590,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "abd1e06a1927df6d",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "switch",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "235",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 200,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "80011a285355da55",
        "type": "link in",
        "z": "ee904ab46f56578e",
        "name": "HomeKit In",
        "links": [],
        "x": 160,
        "y": 120,
        "wires": [
            [
                "6e4cdf00d6531664"
            ]
        ],
        "l": true
    },
    {
        "id": "6e4cdf00d6531664",
        "type": "function",
        "z": "ee904ab46f56578e",
        "name": "HomeKit IN",
        "func": "let State;\nif (msg.state == \"ON\") {\n    State = true;\n} else if (msg.state == \"OFF\") {\n    State = false;\n}\nmsg = {\n    \"payload\": {\n        \"On\": State\n    }\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 120,
        "wires": [
            [
                "352f4c207b613014"
            ]
        ]
    },
    {
        "id": "352f4c207b613014",
        "type": "homekit-service",
        "z": "ee904ab46f56578e",
        "d": true,
        "isParent": true,
        "hostType": "0",
        "bridge": "481f3f804361a6fd",
        "accessoryId": "",
        "parentService": "",
        "name": "4_state_Entry_Lights",
        "serviceName": "Switch",
        "topic": "4_state_Entry_Lights",
        "filter": false,
        "manufacturer": "NRCHKB",
        "model": "1.7.3",
        "serialNo": "Default Serial Number",
        "firmwareRev": "1.7.3",
        "hardwareRev": "1.7.3",
        "softwareRev": "1.7.3",
        "cameraConfigVideoProcessor": "ffmpeg",
        "cameraConfigSource": "",
        "cameraConfigStillImageSource": "",
        "cameraConfigMaxStreams": 2,
        "cameraConfigMaxWidth": 1280,
        "cameraConfigMaxHeight": 720,
        "cameraConfigMaxFPS": 10,
        "cameraConfigMaxBitrate": 300,
        "cameraConfigVideoCodec": "libx264",
        "cameraConfigAudioCodec": "libfdk_aac",
        "cameraConfigAudio": false,
        "cameraConfigPacketSize": 1316,
        "cameraConfigVerticalFlip": false,
        "cameraConfigHorizontalFlip": false,
        "cameraConfigMapVideo": "0:0",
        "cameraConfigMapAudio": "0:1",
        "cameraConfigVideoFilter": "scale=1280:720",
        "cameraConfigAdditionalCommandLine": "-tune zerolatency",
        "cameraConfigDebug": false,
        "cameraConfigSnapshotOutput": "disabled",
        "cameraConfigInterfaceName": "",
        "characteristicProperties": "{}",
        "waitForSetupMsg": false,
        "outputs": 2,
        "adaptiveLightingOptionsEnable": false,
        "adaptiveLightingOptionsCustomTemperatureAdjustment": "",
        "x": 550,
        "y": 120,
        "wires": [
            [
                "cb7cb161a1362911"
            ],
            []
        ]
    },
    {
        "id": "cb7cb161a1362911",
        "type": "link out",
        "z": "ee904ab46f56578e",
        "name": "HomeKit out",
        "mode": "link",
        "links": [
            "9428382ab57f3f5d"
        ],
        "x": 760,
        "y": 120,
        "wires": [],
        "l": true
    },
    {
        "id": "faf503bfdd48519a",
        "type": "function",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "command_dc_dimmer",
        "func": "// Initialize global status if it doesn't exist\nif (!global.get('status')) {\n    global.set('status', { lights: {} });\n}\n\n// Get or initialize the lights status\nlet status = global.get('status') || { lights: {} };\nif (!status.lights) {\n    status.lights = {};\n}\n\n// Log incoming message for debugging\n//node.warn(\"Incoming message: \" + JSON.stringify(msg));\n\n// Parse the topic to get the instance number\nlet instance = parseInt(msg.topic.split('_')[0]);\nlet command = msg.payload;\n\n// Determine brightness based on command\nlet brightness = 0;\nif (command === 'ON') {\n    brightness = 100;\n} else if (command === 'dim') {\n    // If dim command, use previous brightness or default to 50%\n    brightness = (status.lights[instance] && status.lights[instance].brightness) || 50;\n} else if (command === 'OFF') {\n    brightness = 0;\n}\n\n// Initialize the light instance if it doesn't exist\nif (!status.lights[instance]) {\n    status.lights[instance] = {\n        state: command,\n        brightness: brightness\n    };\n}\n\n// Update global status\nstatus.lights[instance].state = command;\nstatus.lights[instance].brightness = brightness;\nglobal.set('status', status);\n\n// Prepare CAN message\nconst prio = 6;\nconst dgnhi = '1FE';\nconst dgnlo = 'DB';\nconst srcAD = 99;\n\n// Convert brightness to RV-C format (0-200)\nlet rvcBrightness = Math.min(Math.max(brightness * 2, 0), 200);\nlet rvcCommand = 0; // Set Level(delay)\nlet duration = 255;\n\ntry {\n    // Calculate CAN ID\n    const binCanId = parseInt(prio).toString(2).padStart(3, '0') +\n                     parseInt(dgnhi, 16).toString(2).padStart(16, '0') +\n                     parseInt(dgnlo, 16).toString(2).padStart(8, '0') +\n                     parseInt(srcAD).toString(2).padStart(8, '0');\n\n    const hexCanId = parseInt(binCanId, 2).toString(16).toUpperCase().padStart(8, '0');\n\n    // Prepare data bytes\n    const hexData = `${instance.toString(16).padStart(2, '0')}FF${\n        rvcBrightness.toString(16).padStart(2, '0')}${\n        rvcCommand.toString(16).padStart(2, '0')}${\n        duration.toString(16).padStart(2, '0')}00FFFF`;\n\n    // Create the command string for socketcan\n    const canCommand = `${hexCanId}#${hexData}`;\n\n    // Log the outgoing command for debugging\n    //node.warn(\"Outgoing CAN command: \" + canCommand);\n    msg.payload = canCommand;\n    return msg;\n\n} catch (error) {\n    node.error(\"Error processing CAN message: \" + error.message);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 380,
        "wires": [
            [
                "7c30a3bc33fa2315",
                "1bf17ae955275cf0"
            ]
        ]
    },
    {
        "id": "107cff91357ef6da",
        "type": "function",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "HomeKit Out",
        "func": "msg = {\n    \"topic\": msg.topic,\n    \"payload\": msg.payload.On ? \"ON\" : \"OFF\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 380,
        "wires": [
            [
                "9104e3fb894083ee",
                "faf503bfdd48519a"
            ]
        ]
    },
    {
        "id": "9104e3fb894083ee",
        "type": "debug",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "Homekit Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 440,
        "wires": []
    },
    {
        "id": "b7cc11c60eb56768",
        "type": "link in",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "RVC In",
        "links": [
            "6aa079d768e1571c",
            "7dc76fed7cb91e49"
        ],
        "x": 500,
        "y": 320,
        "wires": [
            [
                "faf503bfdd48519a"
            ]
        ],
        "l": true
    },
    {
        "id": "7c30a3bc33fa2315",
        "type": "debug",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "command_dc_dimmer",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 440,
        "wires": []
    },
    {
        "id": "9428382ab57f3f5d",
        "type": "link in",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "HomeKit out v2",
        "links": [
            "cb7cb161a1362911"
        ],
        "x": 190,
        "y": 380,
        "wires": [
            [
                "107cff91357ef6da"
            ]
        ],
        "l": true
    },
    {
        "id": "1bf17ae955275cf0",
        "type": "link out",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "MQTT Out",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 930,
        "y": 380,
        "wires": [],
        "l": true
    }
]