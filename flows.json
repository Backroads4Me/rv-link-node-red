[
    {
        "id": "b3d80c5dc947ec88",
        "type": "tab",
        "label": "HA Commands",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3470febb2cd6e952",
        "type": "tab",
        "label": "HA Entities",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3e5f038a4f5a8b9a",
        "type": "tab",
        "label": "Status",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "292e70a6ba25b323",
        "type": "tab",
        "label": "Config",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "222c995b7790b8de",
        "type": "tab",
        "label": "Delete HA Entity",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "9cfcca5efde78052",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "Load RV-C Dgn Names",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7e609140970f546c",
            "74c7e4a6cc2508eb",
            "cd670f6465b6374b",
            "c78420a075d43408"
        ],
        "x": 134,
        "y": 1539,
        "w": 852,
        "h": 82
    },
    {
        "id": "aea9d97e0563bd83",
        "type": "group",
        "z": "b3d80c5dc947ec88",
        "name": "Home Assistant message encoding",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a37da245aba53b96",
            "a3b957142479c075",
            "6aa079d768e1571c",
            "89946e1c7a570ed0",
            "927786f8f3f21075",
            "c19a749621bffe0c",
            "58d9a2789e4a1391",
            "8a5082e9f29a8080",
            "d367ea017bd41347",
            "778971897d2a7fdc",
            "1521d3d47869af7c",
            "32c25c048171f507",
            "86a191e1f24d802a",
            "ed9920dce79a233a",
            "fe452143fd95f1d7"
        ],
        "x": 34,
        "y": 59,
        "w": 1372,
        "h": 422
    },
    {
        "id": "3c819b7900145438",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "MQTT",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "cacf35b859af22a9",
            "e7ae35364ce60f3f",
            "f658418a7b9b4857",
            "b86f82e84d961549",
            "64c5e5cfd4382453",
            "2110ea4d0b85f784",
            "958fed9f12301f59",
            "d34a8c1fd2cc4320",
            "74329f13cbbc528a",
            "1ac6e0fa1cbb3852",
            "0e65ff3bc0a0795c",
            "9e9b11b9441e51db",
            "54cd7e4a8959a77c",
            "32add109922d428a"
        ],
        "x": 134,
        "y": 59,
        "w": 732,
        "h": 482
    },
    {
        "id": "f09f79586501cb0b",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "CAN message routing",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "8d7d5d3ea117cf79",
            "ac47ce53a9fc3f21",
            "698efabc308fece6",
            "a16ce99da6a2a88f",
            "2e131d4d25819c93",
            "a2dad25eb05117f7",
            "fc66c16576e28548",
            "c6fb02a17f709e08",
            "2fcbc4d630144362",
            "a6594a9464d8fe4e",
            "9dd6a98018824be9",
            "02bdfc59de71b5a5",
            "45414bacecada477",
            "8f99241c9a1cfbde",
            "081183d6c363e792",
            "01b53bba61cb7227",
            "03744ec33f2e6776",
            "c781b519a9f9b156",
            "463dfbbef66b51c2",
            "9c4e4196e56cc471",
            "3d5ce3e925ee2f04",
            "c4216c430d06083f"
        ],
        "x": 954,
        "y": 159,
        "w": 1738,
        "h": 788
    },
    {
        "id": "eb51c1f2d0d389d1",
        "type": "group",
        "z": "3e5f038a4f5a8b9a",
        "name": "Reset unique STATUS list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ffd5bc5ca5695602",
            "09640adb1fd08fbb",
            "b797e5a52b6db5b4",
            "48e6dda2b2d9575e"
        ],
        "x": 34,
        "y": 739,
        "w": 492,
        "h": 142
    },
    {
        "id": "e2dc4d711cc9dc94",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Switches",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d3a13b531babee66",
            "7313d7c724d31538",
            "f0083147745c8366",
            "48e3b18cb440da52",
            "25162d774c052102",
            "32ec19602e928185",
            "52e43edcfad810dd",
            "2d6bf3e8aa77a8c6",
            "4d7e38077918190f",
            "85dabd5afaf4b17d",
            "9c61a141b8525561",
            "bc185e54ce871b11",
            "a9779b1f38edf18d"
        ],
        "x": 114,
        "y": 39,
        "w": 1092,
        "h": 408
    },
    {
        "id": "04e375b0c463df72",
        "type": "group",
        "z": "222c995b7790b8de",
        "name": "Delete Home Assistant Entity",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "802228bc8d89d80a",
            "a2d2ed96ff4615f9",
            "d38c75bc1474be23",
            "abd1e06a1927df6d"
        ],
        "x": 94,
        "y": 79,
        "w": 672,
        "h": 162
    },
    {
        "id": "8ef86a1c4b59d8e1",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "Claim CAN source address",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "515386b6b0d01893",
            "b846bc1605dae821",
            "55071115a3fe7c2c",
            "4e46ba83df00a31b",
            "f01db5ebc3ae2e18",
            "a2334b77d3764815",
            "6423c433e099d2a5",
            "73abad3deeed31e8",
            "695ef0ed6d78a244",
            "3f5eb271f702c8f3",
            "1e244bad0304bb74",
            "07b8bcce03f19e8f",
            "d3cc901dd2fbd359",
            "ba0c52ff61838986"
        ],
        "x": 134,
        "y": 1079,
        "w": 1652,
        "h": 362
    },
    {
        "id": "97615854748deb3d",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Locks",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ec1d9a742ca6e420",
            "c853244d3f2e753d",
            "1d2d33ef4e57dd39",
            "f9f3986645a75789",
            "d5b86b351963235f",
            "b94bb12a8c0a7027",
            "942c2aa2bb3167c9"
        ],
        "x": 114,
        "y": 479,
        "w": 1112,
        "h": 328
    },
    {
        "id": "da39e5020d511fa6",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Shades",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "05ad1b190633010c",
            "ad388870b71549ef",
            "f9a04003db7d8e4a",
            "fa9fcf7b64a31948",
            "927340668e7942e4",
            "ac41981e9754eca5",
            "8eb8085bb7cfee43"
        ],
        "x": 114,
        "y": 839,
        "w": 1112,
        "h": 328
    },
    {
        "id": "067069104a82b459",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Tanks",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d4ef1d361f084b58",
            "61f4573c56915577",
            "6dc4171b23e1cc2a",
            "f9f5381eb086c0e6",
            "b6d3cd6d2e6fbc66",
            "240af7ca01aa2041",
            "da2041e2faba86a3"
        ],
        "x": 114,
        "y": 1199,
        "w": 1112,
        "h": 368
    },
    {
        "id": "5d1ecae7ac09586c",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Batteries",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ea29386f9f8682bc",
            "663120adc5ec254f",
            "2c1151c97bb185f2",
            "b6d90639c3fc122c",
            "86fa588a8393f6de",
            "d68c2206e3379850",
            "64578fa414def60a",
            "0d54f0db9a010394"
        ],
        "x": 114,
        "y": 1619,
        "w": 1112,
        "h": 368
    },
    {
        "id": "84183171172657f8",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Water pump",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "bc627a6a37117bc0",
            "efb5c968a0a43c7d",
            "5a307ecdca9415b1",
            "c3c4a8bcea0243e9",
            "141bdcfc9aec9232",
            "77cecc17525bec45",
            "81de1ec667d84484"
        ],
        "x": 114,
        "y": 2039,
        "w": 1092,
        "h": 348
    },
    {
        "id": "ad77b71440e42dc4",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Autofill",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "cff02a511add6887",
            "93a2783b5bb8d93d",
            "2f36862dec231b98",
            "5004281b11ec3bd7",
            "89855c1c4c586196",
            "2a121d2dbd94eecd",
            "dd0bc2a54fe2a072"
        ],
        "x": 114,
        "y": 2419,
        "w": 1092,
        "h": 348
    },
    {
        "id": "8da591d6205a352e",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Floor heat",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "f0ba2779795efdae",
            "bd2d1b59183b99bb",
            "aa518caf7366cec9",
            "f183a66e28426985",
            "b3e18602b6affaf5",
            "1f7fde87c1ab1f51",
            "6e53b4f33db9f29c",
            "ee5f54f521f5ecda",
            "cd4ce201cf6c3c35",
            "5aa079ea85cca5b0",
            "1a10fdc6f9970a2f"
        ],
        "x": 1434,
        "y": -1,
        "w": 1092,
        "h": 622
    },
    {
        "id": "9dd6a98018824be9",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique UNKNOWN",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a4028527eb23fa04",
            "092c751dcdd12270",
            "eea1641469efb23f"
        ],
        "x": 2134,
        "y": 599,
        "w": 532,
        "h": 142
    },
    {
        "id": "32ec19602e928185",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "886a33cd8776ba5a",
            "6e2b753c50d28b2b",
            "e8b62c33eab8e3ac"
        ],
        "x": 694,
        "y": 279,
        "w": 472,
        "h": 142
    },
    {
        "id": "01b53bba61cb7227",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique CAN decode list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "1e93f7b73c40091a",
            "38606e245b70b98e",
            "8f7381d08bf2b8a8",
            "d0150fd6556514e6"
        ],
        "x": 2134,
        "y": 779,
        "w": 532,
        "h": 142
    },
    {
        "id": "ec1d9a742ca6e420",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d37e08438396819b",
            "d240e935bd38ebd0",
            "54c6beb1daaa00bb"
        ],
        "x": 694,
        "y": 639,
        "w": 472,
        "h": 142
    },
    {
        "id": "05ad1b190633010c",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "779a4359a0980b2c",
            "81bed51dd2f37032",
            "84e908d542084d74"
        ],
        "x": 694,
        "y": 999,
        "w": 472,
        "h": 142
    },
    {
        "id": "b6d3cd6d2e6fbc66",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "bfc3dc28b23b2396",
            "d574ead42dd36caa",
            "21799a7e71f6c5b4"
        ],
        "x": 694,
        "y": 1399,
        "w": 472,
        "h": 142
    },
    {
        "id": "d68c2206e3379850",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "5d1ecae7ac09586c",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7c04541818436246",
            "738718a321d185e7",
            "b9f27aaa32da92c0"
        ],
        "x": 694,
        "y": 1819,
        "w": 472,
        "h": 142
    },
    {
        "id": "081183d6c363e792",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique COMMAND",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "b2cbbdbaab1fc227",
            "f96e5b3b013a2b8f",
            "bc59e15bf069f17d"
        ],
        "x": 2134,
        "y": 239,
        "w": 532,
        "h": 142
    },
    {
        "id": "77cecc17525bec45",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "3e1cb0098e246ca4",
            "876c4f2ff7fb1ae4",
            "99381e18a0d5f318"
        ],
        "x": 694,
        "y": 2219,
        "w": 472,
        "h": 142
    },
    {
        "id": "2a121d2dbd94eecd",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "4119a569e77d3350",
            "f6151272dcfe1559",
            "d192b275aac0824e"
        ],
        "x": 694,
        "y": 2599,
        "w": 472,
        "h": 142
    },
    {
        "id": "9c4e4196e56cc471",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique Proprietary",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "17b175c97c0551d4",
            "9f47dc231ecd50cd",
            "5968e8ee034f8751"
        ],
        "x": 2134,
        "y": 419,
        "w": 512,
        "h": 142
    },
    {
        "id": "1f7fde87c1ab1f51",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a9069efd6410088f",
            "7a0956cdace18b52",
            "893d80d1125057e8"
        ],
        "x": 2014,
        "y": 219,
        "w": 472,
        "h": 142
    },
    {
        "id": "ee5f54f521f5ecda",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Reset floor levels (Don't do this)",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "56aa8b5c045b391d",
            "870bf91817db9d08"
        ],
        "x": 1494,
        "y": 279,
        "w": 412,
        "h": 82
    },
    {
        "id": "80727e60a251c36c",
        "type": "mqtt-broker",
        "name": "Mosquitto",
        "broker": "127.0.0.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a37da245aba53b96",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Decode HA command",
        "func": "// decode_ha_command.js (Updated for 2-Entity Solution)\n//\n// Parse Home Assistant MQTT command topics\n\n// --- Cover (Shade) entities ---\nconst rvcTopicMatch = msg.topic.match(/^homeassistant\\/cover\\/shade_(\\d+)\\/set$/);\nif (rvcTopicMatch) {\n    const instance = parseInt(rvcTopicMatch[1], 10);\n    const command = String(msg.payload).toUpperCase();\n    msg.routingKey = \"cover\";\n    msg.instance = instance;\n    msg.command = command;\n    msg.entityType = \"cover\";\n    msg.entityId = `shade_${instance}`;\n    return msg;\n}\n\n// --- Lock entities ---\nconst lockTopicMatch = msg.topic.match(/^homeassistant\\/lock\\/lock_(\\d+)\\/set$/);\nif (lockTopicMatch) {\n    const instance = parseInt(lockTopicMatch[1], 10);\n    const command = String(msg.payload).toUpperCase();\n    msg.routingKey = \"lock\";\n    msg.instance = instance;\n    msg.command = command;\n    msg.entityType = \"lock\";\n    msg.entityId = `lock_${instance}`;\n    return msg;\n}\n\n// --- Floor Heat Schedule Switch ---\n// Matches 'homeassistant/switch/floor_heat_1_schedule/set'\nconst scheduleSwitchMatch = msg.topic.match(/^homeassistant\\/switch\\/floor_heat_(\\d+)_schedule\\/set$/);\nif (scheduleSwitchMatch) {\n    const instance = parseInt(scheduleSwitchMatch[1], 10);\n    msg.routingKey = \"floor_heat_schedule\"; // <-- NEW Routing Key\n    msg.instance = instance;\n    msg.command = String(msg.payload).toUpperCase(); // \"ON\" or \"OFF\"\n    msg.entityType = \"switch\";\n    msg.entityId = `floor_heat_${instance}_schedule`;\n    return msg;\n}\n\n// --- Climate (Floor Heat) Preset entities ---\nconst climatePresetMatch = msg.topic.match(/^homeassistant\\/climate\\/floor_heat_(\\d+)\\/set_preset_mode$/);\nif (climatePresetMatch) {\n    const instance = parseInt(climatePresetMatch[1], 10);\n    msg.routingKey = \"floor_heat\";\n    msg.instance = instance;\n    msg.entityType = \"climate\";\n    msg.entityId = `floor_heat_${instance}`;\n    msg.command = \"SET_PRESET\"; \n    msg.value = String(msg.payload); // e.g., \"Level 5\"\n    return msg;\n}\n\n// --- Climate (Floor Heat) Mode entities ---\nconst climateTopicMatch = msg.topic.match(/^homeassistant\\/climate\\/floor_heat_(\\d+)\\/set_mode$/);\nif (climateTopicMatch) {\n    const instance = parseInt(climateTopicMatch[1], 10);\n    msg.routingKey = \"floor_heat\";\n    msg.instance = instance;\n    msg.entityType = \"climate\";\n    msg.entityId = `floor_heat_${instance}`;\n    msg.command = String(msg.payload).toUpperCase(); // \"HEAT\" or \"OFF\"\n    return msg;\n}\n\n// --- Switch and Light entities (Fallback) ---\nconst topicParts = msg.topic.split('/');\nif (topicParts.length === 4 &&\n    topicParts[0] === 'homeassistant' &&\n    (topicParts[1] === 'switch' || topicParts[1] === 'light') &&\n    topicParts[3] === 'set') {\n\n    const entityId = topicParts[2];\n    const command = String(msg.payload).toUpperCase();\n    msg.entityType = topicParts[1];\n    msg.entityId = entityId;\n    msg.command = command;\n\n    if (entityId === 'water_pump' || entityId === 'autofill') {\n        msg.instance = entityId;\n        msg.routingKey = entityId;\n    } else {\n        const entityIdParts = entityId.split('_');\n        const instanceStr = entityIdParts[entityIdParts.length - 1];\n        const instanceNum = parseInt(instanceStr, 10);\n        if (isNaN(instanceNum)) {\n             node.warn(`Could not parse instance number from entityId: ${entityId}`);\n             return null;\n        }\n        msg.instance = instanceNum;\n        msg.routingKey = entityIdParts.slice(0, -1).join('_');\n    }\n    return msg;\n}\n\nnode.warn(`Unhandled MQTT topic: ${msg.topic}`);\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 200,
        "wires": [
            [
                "89946e1c7a570ed0",
                "32c25c048171f507"
            ]
        ]
    },
    {
        "id": "a3b957142479c075",
        "type": "link in",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA in",
        "links": [
            "64c5e5cfd4382453"
        ],
        "x": 110,
        "y": 200,
        "wires": [
            [
                "a37da245aba53b96",
                "1521d3d47869af7c"
            ]
        ],
        "l": true
    },
    {
        "id": "6aa079d768e1571c",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 1270,
        "y": 180,
        "wires": [],
        "l": true
    },
    {
        "id": "89946e1c7a570ed0",
        "type": "switch",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "",
        "property": "routingKey",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "switch",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "water_pump",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "cover",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "lock",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "autofill",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "floor_heat",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "floor_heat_schedule",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 570,
        "y": 200,
        "wires": [
            [
                "86a191e1f24d802a"
            ],
            [
                "927786f8f3f21075"
            ],
            [
                "58d9a2789e4a1391"
            ],
            [
                "8a5082e9f29a8080"
            ],
            [
                "d367ea017bd41347"
            ],
            [
                "ed9920dce79a233a"
            ],
            [
                "fe452143fd95f1d7"
            ],
            [
                "778971897d2a7fdc"
            ]
        ]
    },
    {
        "id": "927786f8f3f21075",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode water pump command",
        "func": "// Encodes a simple HA ON/OFF command to an RV-C WATER_PUMP_COMMAND.\n// This function is for a standard, single-instance water pump.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FFB2\"; // WATER_PUMP_COMMAND DGN\n\n// 1. Get the command from the input message\nconst state = msg.command; // Expects \"ON\" or \"OFF\"\n\n// 2. Determine the command value based on the state\nlet pumpCommandValue;\nswitch (state) {\n    case 'ON':\n        pumpCommandValue = 1; // 01b = Enable pump (standby)\n        break;\n    case 'OFF':\n        pumpCommandValue = 0; // 00b = Disable pump\n        break;\n    default:\n        node.warn(`[encode_pump_command] Invalid command: \"${state}\". Expected \"ON\" or \"OFF\".`);\n        return null;\n}\n\n// 3. Build the 8-byte data payload\n// Byte 0 contains the command. All other bytes are set to 0xFF (Not Available)\n// as we are not setting pressure or other parameters.\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = pumpCommandValue;\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID from Priority, DGN, and Source Address\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in 'can/send' format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\n// Debug output\nnode.warn(`[encode_pump_command] State: ${state} | CAN: ${msg.payload}`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 160,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "c19a749621bffe0c",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA command",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 120,
        "wires": []
    },
    {
        "id": "58d9a2789e4a1391",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode shade command",
        "func": "// Encodes HA cover commands (OPEN/CLOSE/STOP) to RV-C WINDOW_SHADE_CONTROL_COMMAND\n// Outputs in standard CAN bus format for 'can/send' topic.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEDF\";\n\n// 1. Get pre-parsed instance and command from the decoder function\nconst instance = msg.instance;\nconst haCommand = msg.command; // Will be \"OPEN\", \"CLOSE\", or \"STOP\"\n\nif (typeof instance !== 'number' || instance < 1 || instance > 250) {\n    node.warn(`Invalid or missing instance number in msg.instance: ${instance}`);\n    return null;\n}\n\n// 2. Determine RV-C command code and parameters\nlet command;\nlet duration = 30; // 30 seconds duration (matches switch panel)\n\nswitch (haCommand) {\n    case 'OPEN':\n        command = 0x85; // Toggle Forward (Raise/Open) - if off, turn on forward; if on, toggles\n        break;\n    case 'CLOSE':\n        command = 0x45; // Toggle Reverse (Lower/Close) - if off, turn on reverse; if on, toggles\n        break;\n    case 'STOP':\n        command = 0x04; // Stop\n        duration = 0;   // Duration is ignored for STOP, but set for clarity\n        break;\n    default:\n        node.warn('Unknown shade command from cover entity: ' + haCommand);\n        return null;\n}\n\n// 3. Build the 8-byte data payload\nconst motorDuty = 200; // Use 200% motor duty (matches switch panel)\nconst dataBytes = new Array(8).fill(0xFF);\n\ndataBytes[0] = instance;            // Instance Number\ndataBytes[1] = 0xFF;                // Group (Non-group command)\ndataBytes[2] = motorDuty;           // Motor Duty Cycle\ndataBytes[3] = command;             // Command Code\ndataBytes[4] = duration;            // Duration\ndataBytes[5] = 0x00;                // Interlock (No Interlock)\ndataBytes[6] = 0xFF;                // Not Available\ndataBytes[7] = 0xFF;                // Not Available\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 200,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "8a5082e9f29a8080",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode lock command",
        "func": "// Encodes HA lock entity commands to RV-C LOCK_COMMAND (DGN 1FEE4)\n// Handles lock entity LOCK/UNLOCK commands only\n// Outputs in standard CAN bus format for 'can/send' topic.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEE4\";\n\n// 1. Get pre-parsed instance and command from the decoder function\nconst instance = msg.instance;\nconst haCommand = msg.command; // Will be \"LOCK\" or \"UNLOCK\"\n\n// Accept Instance 0 (broadcast to all locks) per RV-C spec section 6.40.1\nif (typeof instance !== 'number' || instance < 0 || instance > 250) {\n    node.warn(`Invalid or missing instance number in msg.instance: ${instance}`);\n    return null;\n}\n\n// 2. Parse command from lock entity\nlet lockCommand;\n\nswitch (haCommand) {\n    case 'UNLOCK':\n        lockCommand = 0; // Unlock\n        break;\n    case 'LOCK':\n        lockCommand = 1; // Lock\n        break;\n    default:\n        node.warn('Unknown lock command from lock entity: ' + haCommand);\n        return null;\n}\n\n// 3. Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xFF);\n\ndataBytes[0] = instance;            // Instance Number\ndataBytes[1] = lockCommand;         // Lock Command (0=unlock, 1=lock)\ndataBytes[2] = 0;                   // Additional Command (0=no action)\ndataBytes[3] = 0xFF;                // Byte 4 (Not Available)\ndataBytes[4] = 0xFF;                // Byte 5 (Not Available)\ndataBytes[5] = 0xFF;                // Byte 6 (Not Available)\ndataBytes[6] = 0xFF;                // Byte 7 (Not Available)\ndataBytes[7] = 0xFF;                // Byte 8 (Not Available)\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 240,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "d367ea017bd41347",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode autofill command",
        "func": "// Encodes an HA ON/OFF command to a universal RV-C AUTOFILL_COMMAND.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FFB0\"; // AUTOFILL_COMMAND\n\n// 1. Get command from the HA parser\nconst state = msg.command; // Will be \"ON\" or \"OFF\"\nlet commandValue;\n\nswitch (state) {\n    case 'ON':\n        // Universal ON command that works on standard and non-standard systems\n        commandValue = 0xFD;\n        break;\n    case 'OFF':\n        // Universal OFF command\n        commandValue = 0xFC;\n        break;\n    default:\n        node.warn(`[encode_autofill_command] Invalid command: \"${state}\".`);\n        return null;\n}\n\n// 2. Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = commandValue;\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 3. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 4. Construct the final output message\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 280,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "778971897d2a7fdc",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "otherwise",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 440,
        "wires": []
    },
    {
        "id": "1521d3d47869af7c",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA in",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 230,
        "y": 100,
        "wires": []
    },
    {
        "id": "32c25c048171f507",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Decode HA command",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 500,
        "y": 100,
        "wires": []
    },
    {
        "id": "86a191e1f24d802a",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode dc_dimmer_command_2",
        "func": "// Encodes HA switch commands to the specific toggle format required by the dimmer.\n// Implements two-message sequence: UNLOCK + TOGGLE\n// Returns null after sequential transmission\n\n// --- Configuration ---\nconst RVC_COMMAND = 0x05; // The specific command type for the toggle.\nconst CMD_UNLOCK = 0x22;  // Remove lock condition\nconst LEVEL_ON = 250;     // The brightness level sent by the physical switch (0xFA).\nconst NON_GROUP = 0xFF;\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEDB\";\n\nconst instance = msg.instance;\nconst state = msg.command; // \"ON\" or \"OFF\"\n\nif (typeof instance !== 'number' || instance < 1 || instance > 250) {\n    node.warn(`[encode_switch_command] Invalid instance: ${instance}`);\n    return null;\n}\n\n// Helper function to build CAN message\nfunction buildCanMessage(instance, desiredLevel, commandCode) {\n    // Build the 8-byte data payload to EXACTLY match the physical switch\n    const dataBytes = new Array(8).fill(0xFF);\n    dataBytes[0] = instance;\n    dataBytes[1] = NON_GROUP;\n    dataBytes[2] = desiredLevel;\n    dataBytes[3] = commandCode;\n    dataBytes[4] = 0xFF; // Delay/Duration\n    dataBytes[5] = 0x00; // Interlock\n    dataBytes[6] = 0xFF; // Ramp Time\n    dataBytes[7] = 0xFF; // Reserved\n\n    const dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n    // Construct the CAN ID\n    const dgnInt = parseInt(DGN, 16);\n    const canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\n    const canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n    return `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n}\n\n// This is a toggle command. The payload is the same for both ON and OFF.\n// The desiredLevel is always the 'ON' level (250) sent by the physical switch.\nconst desiredLevel = LEVEL_ON;\n\n// Build Message 1: UNLOCK\nconst unlockMessage = {\n    topic: \"can/send\",\n    payload: buildCanMessage(instance, desiredLevel, CMD_UNLOCK)\n};\n\n// Build Message 2: TOGGLE\nconst toggleMessage = {\n    topic: \"can/send\",\n    payload: buildCanMessage(instance, desiredLevel, RVC_COMMAND)\n};\n\n// Send both messages sequentially using node.send()\n// This ensures both messages go to the same output port in order\nnode.send(unlockMessage);\nnode.send(toggleMessage);\n\n// Return null to prevent duplicate sending\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 120,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "ed9920dce79a233a",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode floor heat command",
        "func": "// encode_floor_heat_command.js\n//\n// Reads level map and schedule state from GLOBAL context.\n// Corrected: OFF command no longer resets the schedule state.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEFB\";\n\n// --- Input ---\nconst instance = msg.instance;\nconst command = msg.command;\n\nif (typeof instance !== 'number') {\n    node.warn(`[encode_floor_heat] Invalid instance: ${instance}`);\n    return null;\n}\n\n// --- Get Context ---\nconst levelMap = global.get(\"floorHeatLevelMap\", \"file\");\nconst scheduleContextKey = `floorHeat_${instance}_ScheduleOn`;\nconst isScheduleOn = global.get(scheduleContextKey, \"file\") || false;\n\nif (!levelMap && command !== 'OFF') { // Allow OFF even if map isn't ready\n    node.warn(\"[encode_floor_heat] Floor heat level map not found. Levels must be discovered first.\");\n    // Only block if it's not an OFF command\n    if (command !== 'OFF') {\n        return null;\n    }\n}\n\n// 1. Build Payload\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = instance;\n\n// 2. Parse Command\nif (command === 'OFF') {\n    dataBytes[1] = 0xC0;\n    dataBytes[2] = 0x00;\n    dataBytes[3] = 0x00;\n    // *** THE FIX: Removed the line below ***\n    // global.set(scheduleContextKey, false, \"file\"); // <-- REMOVED\n\n} else if (command === 'HEAT') {\n    // Send D4 or C4 based on the *saved* schedule state\n    dataBytes[1] = isScheduleOn ? 0xD4 : 0xC4;\n\n} else if (command === 'SET_PRESET') {\n    // This check requires the levelMap, handle potential error if map still missing\n    if (!levelMap) {\n        node.error(\"[encode_floor_heat] Cannot set preset, level map is missing.\");\n        return null;\n    }\n\n    const presetName = msg.value;\n    const rawValue = levelMap[presetName];\n\n    if (typeof rawValue === 'undefined') {\n        node.warn(`[encode_floor_heat] Unknown preset name: ${presetName}`);\n        return null;\n    }\n\n    if (presetName === \"Store\") {\n        dataBytes[1] = 0xC4;\n        // When setting to Store, we DO force schedule off\n        global.set(scheduleContextKey, false, \"file\");\n    } else {\n        // For other levels, send D4 or C4 based on saved state\n        dataBytes[1] = isScheduleOn ? 0xD4 : 0xC4;\n    }\n\n    dataBytes[2] = rawValue & 0xFF;\n    dataBytes[3] = (rawValue >> 8) & 0xFF;\n\n} else {\n    node.warn('[encode_floor_heat] Unknown command: ' + command);\n    return null;\n}\n\n// 3. Format CAN message\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 320,
        "wires": [
            [
                "c19a749621bffe0c",
                "6aa079d768e1571c"
            ]
        ]
    },
    {
        "id": "fe452143fd95f1d7",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode floor heat schedule",
        "func": "// encode_floor_heat_schedule.js (New Node)\n//\n// Handles the \"ON\" / \"OFF\" commands from the schedule switch.\n// Sends the schedule-only CAN message and updates PERSISTENT context.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEFB\";\n\n// --- Input ---\nconst instance = msg.instance;\nconst command = msg.command; // \"ON\" or \"OFF\"\n\nif (typeof instance !== 'number') {\n    node.warn(`[encode_schedule] Invalid instance: ${instance}`);\n    return null;\n}\n\nconst scheduleContextKey = `floorHeat_${instance}_ScheduleOn`;\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = instance;\n\n// 2. Parse Command\nif (command === 'ON') {\n    // Use the 'Schedule On' command from your logs\n    dataBytes[1] = 0xD7;\n    global.set(scheduleContextKey, true, \"file\");\n\n} else if (command === 'OFF') {\n    // Use the 'Schedule Off' command from your logs\n    dataBytes[1] = 0xCF;\n    global.set(scheduleContextKey, false, \"file\");\n\n} else {\n    node.warn('[encode_schedule] Unknown command: ' + command);\n    return null;\n}\n\n// 3. Format CAN message\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 360,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "d3a13b531babee66",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1070,
        "y": 140,
        "wires": [],
        "l": true
    },
    {
        "id": "7313d7c724d31538",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "DC_DIMMER_STATUS_3",
        "links": [
            "7af7fb2178a714cf"
        ],
        "x": 250,
        "y": 140,
        "wires": [
            [
                "f0083147745c8366",
                "48e3b18cb440da52",
                "4d7e38077918190f"
            ]
        ],
        "l": true
    },
    {
        "id": "f0083147745c8366",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unique dc_dimmer",
        "func": "const uniqueKey = \"uniqueDcDimmers\";\n\n// Retrieve existing instances from flow context, or initialize as empty array\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (instanceId != null && !uniqueList.includes(instanceId)) {\n    uniqueList.push(instanceId);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance ID to the next function\n    return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 200,
        "wires": [
            [
                "25162d774c052102"
            ]
        ]
    },
    {
        "id": "48e3b18cb440da52",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Dc_dimmer status",
        "func": "// status_dc_dimmer_3.js\n\n// Validate basic input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst statusValue = msg.payload.load_status;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof statusValue !== 'string') {\n    node.error(\"DC_DIMMER_STATUS_3 missing 'load_status' (string).\", msg);\n    return null;\n}\n\n// DC Dimmer: Check if load_status contains \"Off\"\nconst haStatus = statusValue.includes(\"Off\") ? \"OFF\" : \"ON\";\n\n// Get the override list to determine the correct component type\nconst overrides = global.get('entityOverrides') || {};\nconst componentType = overrides[instance] || 'light'; // Default to 'light'\n\n// Construct the MQTT topic with the correct component type\nconst stateTopic = `homeassistant/${componentType}/switch_${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\n// Format the payload based on the component type\nif (componentType === 'fan') {\n    // Fans expect a JSON payload because of the state_value_template\n    msg.payload = { \"state\": haStatus };\n} else {\n    // Lights and switches work with a simple string\n    msg.payload = haStatus;\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 140,
        "wires": [
            [
                "d3a13b531babee66",
                "85dabd5afaf4b17d"
            ]
        ]
    },
    {
        "id": "25162d774c052102",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create dc_dimmer",
        "func": "// create_dc_dimmer_3.js\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (instance < 1 || instance > 250) {\n    if (instance >= 251 && instance <= 255) {\n        return null;\n    }\n    node.warn(`Instance ${instance} is outside the valid RV-C instance range (1-250) for a switch. Entity will not be created.`);\n    return null;\n}\n\n// Device configuration\nconst prefix = \"switch\";\nconst displayPrefix = \"Switch\";\nconst icon = 'mdi:light-recessed';\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\nconst displayName = `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/light/${entityId}/config`;\nconst stateTopic = `homeassistant/light/${entityId}/state`;\nconst commandTopic = `homeassistant/light/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n    name: displayName,\n    unique_id: entityId,\n    icon: icon,\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n    state_value_template: \"{{ value_json.state }}\",\n    payload_on: \"ON\",\n    payload_off: \"OFF\"\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\nmsg.retain = true;\n\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\nmsg.entityId = entityId;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 200,
        "wires": [
            [
                "d3a13b531babee66",
                "52e43edcfad810dd"
            ]
        ]
    },
    {
        "id": "886a33cd8776ba5a",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 380,
        "wires": [
            [
                "6e2b753c50d28b2b"
            ]
        ]
    },
    {
        "id": "6e2b753c50d28b2b",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDcDimmers\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "e8b62c33eab8e3ac",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset dc_dimmerss",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 810,
        "y": 320,
        "wires": [
            [
                "6e2b753c50d28b2b"
            ]
        ],
        "l": true
    },
    {
        "id": "f9f3986645a75789",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Create Lock",
        "func": "/***********************************************************\n * Lock MQTT Discovery for Home Assistant\n * Creates a lock entity for each lock instance\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The lock instance ID (1-250)\n * - msg.payload.device_type (String): Device type (\"lock\")\n ***********************************************************/\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst deviceType = msg.payload.device_type;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof deviceType !== 'string') {\n    node.error(\"Input missing 'device_type' (string).\", msg);\n    return null;\n}\n\n// Verify device type is lock\nif (deviceType !== 'lock') {\n    node.error(`Expected device_type 'lock', got '${deviceType}'.`, msg);\n    return null;\n}\n\n// RV-C valid instance range: 0-250\n// Instance 0 = \"All Locks\" broadcast entity per RV-C spec section 6.40.1\n// Instances 1-250 = Individual locks\n// Special values: 251=Error, 252=Not Supported, 253=Out of Range, 254=Reserved, 255=Not Available\nif (instance < 0 || instance > 250) {\n    // Silently ignore special RV-C status values - these aren't real devices\n    if (instance >= 251 && instance <= 255) {\n        return null;\n    }\n    node.warn(`Instance ${instance} is outside the valid RV-C instance range (0-250) for a lock. Entity will not be created.`);\n    return null;\n}\n\nconst prefix = \"lock\";\nconst displayPrefix = \"Lock\";\nconst componentType = \"lock\";\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\n// Special name for Instance 0 (broadcast to all locks)\nconst displayName = instance === 0 ? \"All Locks\" : `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    default_entity_id: `${componentType}.${entityId}`,\n    icon: \"mdi:lock\",\n\n    // Topics for Home Assistant to use\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n\n    // Define what \"LOCK\" and \"UNLOCK\" commands look like (simple strings)\n    payload_lock: \"LOCK\",\n    payload_unlock: \"UNLOCK\",\n\n    // State values that will be received from status updates\n    state_locked: \"LOCKED\",\n    state_unlocked: \"UNLOCKED\",\n\n    // Instance 0 (All Locks) uses optimistic mode since it's broadcast-only (no status feedback)\n    // Instances 1-250 use non-optimistic mode to show real status from RV-C bus\n    optimistic: instance === 0\n\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\nmsg.entityId = entityId;\nmsg.deviceType = deviceType;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 580,
        "wires": [
            [
                "b94bb12a8c0a7027",
                "942c2aa2bb3167c9"
            ]
        ]
    },
    {
        "id": "c853244d3f2e753d",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Lock status",
        "func": "/***********************************************************\n * HA Lock Status Updater\n * Takes a JSON payload as input and sends lock/unlock status\n * to the correct Home Assistant MQTT state topic for lock entities.\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The ID of the lock (1-250).\n * - msg.payload.is_locked (Boolean): Whether lock is locked.\n * - msg.payload.is_unlocked (Boolean): Whether lock is unlocked.\n * - msg.payload.lock_status (String): Lock status text.\n ***********************************************************/\n\n// Validate instance - must be a valid number (1-250)\n// Special values (0, 251-255) are decoded as strings and should be ignored\nif (typeof msg.payload.instance !== 'number') {\n    // Silently ignore messages with invalid instance values\n    return null;\n}\n\nconst instance = msg.payload.instance;\n\n// Additional validation: only process instances 0-250\n// Instance 0 is accepted but won't publish state (optimistic entity)\nif (instance < 0 || instance > 250) {\n    return null;\n}\n\n// Skip state publishing for Instance 0 (broadcast \"All Locks\" entity)\n// Instance 0 uses optimistic mode and doesn't have individual status\nif (instance === 0) {\n    return null;\n}\n\n// Determine the lock state\nlet haStatus = \"UNKNOWN\";\n\n// Check boolean flags first (most reliable)\nif (msg.payload.is_locked === true) {\n    haStatus = \"LOCKED\";\n} else if (msg.payload.is_unlocked === true) {\n    haStatus = \"UNLOCKED\";\n} else if (typeof msg.payload.lock_status === 'string') {\n    // Fall back to parsing lock_status string\n    const lockStatusLower = msg.payload.lock_status.toLowerCase();\n    if (lockStatusLower.includes(\"locked\") && !lockStatusLower.includes(\"unlocked\")) {\n        haStatus = \"LOCKED\";\n    } else if (lockStatusLower.includes(\"unlocked\")) {\n        haStatus = \"UNLOCKED\";\n    }\n}\n\n// Create the state topic for this lock instance\nconst stateTopic = `homeassistant/lock/lock_${instance}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = haStatus; // The payload is the lock state string\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 520,
        "wires": [
            [
                "b94bb12a8c0a7027"
            ]
        ]
    },
    {
        "id": "1d2d33ef4e57dd39",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "LOCK_STATUS",
        "links": [
            "f00adfe38f0e26b5"
        ],
        "x": 220,
        "y": 520,
        "wires": [
            [
                "c853244d3f2e753d",
                "d5b86b351963235f"
            ]
        ],
        "l": true
    },
    {
        "id": "d5b86b351963235f",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Unique lock",
        "func": "// Retrieve existing lock instances from flow context, or initialize as empty array\nlet uniqueLocks = flow.get(\"uniqueLocks\") || [];\n\n// Track by numeric instance ID for true uniqueness\n// Instance 0 = \"All Locks\" broadcast entity (per RV-C spec 6.40.1)\n// Instances 1-250 = Individual lock entities\nlet instanceId = msg.payload.instance;\nlet messagesToSend = [];\n\n// Ensure instance 0 is always initialized on first run\nif (!uniqueLocks.includes(0)) {\n    uniqueLocks.push(0);\n    flow.set(\"uniqueLocks\", uniqueLocks);\n\n    // Send instance 0 for initialization\n    messagesToSend.push({\n        payload: {\n            instance: 0,\n            device_type: \"lock\"\n        }\n    });\n}\n\n// Check if the current instance ID has been seen before\nif (!uniqueLocks.includes(instanceId)) {\n    uniqueLocks.push(instanceId);\n    flow.set(\"uniqueLocks\", uniqueLocks);\n\n    // Add the current instance to messages to send\n    messagesToSend.push({\n        payload: {\n            instance: instanceId,\n            device_type: \"lock\"\n        }\n    });\n}\n\n// Return messages (instance 0 if needed, current instance if new)\n// Returns null if no new instances detected\n// Node-RED will send each message in the array sequentially to the next node\nreturn messagesToSend.length > 0 ? messagesToSend : null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 580,
        "wires": [
            [
                "f9f3986645a75789"
            ]
        ]
    },
    {
        "id": "b94bb12a8c0a7027",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1090,
        "y": 520,
        "wires": [],
        "l": true
    },
    {
        "id": "d37e08438396819b",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "ec1d9a742ca6e420",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 740,
        "wires": [
            [
                "d240e935bd38ebd0"
            ]
        ]
    },
    {
        "id": "d240e935bd38ebd0",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ec1d9a742ca6e420",
        "name": "Reset function",
        "func": "flow.set(\"uniqueLocks\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "54c6beb1daaa00bb",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "ec1d9a742ca6e420",
        "name": "Reset locks",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 790,
        "y": 680,
        "wires": [
            [
                "d240e935bd38ebd0"
            ]
        ],
        "l": true
    },
    {
        "id": "779a4359a0980b2c",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "05ad1b190633010c",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 1100,
        "wires": [
            [
                "81bed51dd2f37032"
            ]
        ]
    },
    {
        "id": "81bed51dd2f37032",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "05ad1b190633010c",
        "name": "Reset function",
        "func": "flow.set(\"uniqueShades\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1100,
        "wires": [
            []
        ]
    },
    {
        "id": "84e908d542084d74",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "05ad1b190633010c",
        "name": "Reset shades",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 790,
        "y": 1040,
        "wires": [
            [
                "81bed51dd2f37032"
            ]
        ],
        "l": true
    },
    {
        "id": "ad388870b71549ef",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Shade status",
        "func": "// Assumes the input msg.payload is the decoded RV-C status message for a shade\n// e.g., { instance: 5, motor_status: 1, forward_status: 1, reverse_status: 0 }\n// NOTE: operating_status is motor duty cycle (power %), NOT physical position\n\nconst instance = msg.payload.instance;\nconst motorStatus = msg.payload.motor_status;\nconst forwardStatus = msg.payload.forward_status;\nconst reverseStatus = msg.payload.reverse_status;\n\n// Ignore invalid instances\nif (typeof instance !== 'number' || instance < 1 || instance > 250) {\n    return null;\n}\n\nlet haState;\nlet position;\n\nif (motorStatus === 1 && forwardStatus === 1) {\n    haState = \"opening\";\n    position = 50; // Arbitrary position while moving\n} else if (motorStatus === 1 && reverseStatus === 1) {\n    haState = \"closing\";\n    position = 50; // Arbitrary position while moving\n} else {\n    // Motor stopped - report as open with 50% position\n    // This keeps both open and close buttons enabled in HA\n    haState = \"open\";\n    position = 50; // Always report 50% when stopped (keeps both buttons active)\n}\n\nmsg.topic = `homeassistant/cover/shade_${instance}/state`;\nmsg.payload = JSON.stringify({\n    state: haState,\n    position: position\n});\nmsg.retain = true;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 880,
        "wires": [
            [
                "927340668e7942e4"
            ]
        ]
    },
    {
        "id": "f9a04003db7d8e4a",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "SHADE_STATUS",
        "links": [
            "4ab29d3dd1da32a5"
        ],
        "x": 220,
        "y": 880,
        "wires": [
            [
                "ad388870b71549ef",
                "fa9fcf7b64a31948"
            ]
        ],
        "l": true
    },
    {
        "id": "fa9fcf7b64a31948",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Unique shade",
        "func": "const uniqueKey = \"uniqueShades\";\n\n// Retrieve existing instances from flow context, or initialize as empty array\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (instanceId != null && !uniqueList.includes(instanceId)) {\n    uniqueList.push(instanceId);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance ID to the next function\n    return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 940,
        "wires": [
            [
                "ac41981e9754eca5"
            ]
        ]
    },
    {
        "id": "927340668e7942e4",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1090,
        "y": 880,
        "wires": [],
        "l": true
    },
    {
        "id": "ac41981e9754eca5",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Create Shade",
        "func": "/***********************************************************\n * Create Home Assistant MQTT Discovery for RV-C Shades\n * Creates a dedicated 'cover' entity for each shade instance.\n *\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The shade instance ID (1-250)\n ***********************************************************/\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object' || typeof msg.payload.instance !== 'number') {\n    node.error(\"Input payload must be an object with a numeric 'instance' property.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\n\n// RV-C valid instance range: 1-250\n// Silently ignore special RV-C status/error values (251-255)\nif (instance < 1 || instance > 250) {\n    if (instance < 251) { // Only warn for invalid user-range instances\n        node.warn(`Instance ${instance} is outside the valid RV-C range (1-250). Cover will not be created.`);\n    }\n    return null;\n}\n\n// --- MQTT Discovery Configuration for a Cover Entity ---\n\nconst entityId = `shade_${instance}`;\nconst discoveryTopic = `homeassistant/cover/${entityId}/config`;\nconst commandTopic = `homeassistant/cover/${entityId}/set`; // Topic HA will send commands to\n\nconst stateTopic = `homeassistant/cover/${entityId}/state`;\n\nconst discoveryPayload = {\n    name: `Shade ${instance}`,\n    unique_id: `shade_${instance}`,\n    default_entity_id: `cover.${entityId}`,\n    icon: \"mdi:window-shutter\",\n    command_topic: commandTopic,\n    payload_open: \"OPEN\",\n    payload_close: \"CLOSE\",\n    payload_stop: \"STOP\",\n    state_topic: stateTopic,\n    position_topic: stateTopic,\n    // Cover entity states\n    state_opening: \"opening\",\n    state_closing: \"closing\",\n    state_open: \"open\",\n    state_closed: \"closed\",\n    // Position support (keeps both buttons enabled)\n    value_template: \"{{ value_json.state }}\",\n    position_template: \"{{ value_json.position | int }}\",\n    optimistic: false\n};\n\n// Return the discovery message\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(discoveryPayload);\nmsg.retain = true;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 940,
        "wires": [
            [
                "927340668e7942e4",
                "8eb8085bb7cfee43"
            ]
        ]
    },
    {
        "id": "d4ef1d361f084b58",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1090,
        "y": 1240,
        "wires": [],
        "l": true
    },
    {
        "id": "61f4573c56915577",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "TANK_STATUS",
        "links": [
            "45ae070eafc9a732"
        ],
        "x": 220,
        "y": 1240,
        "wires": [
            [
                "6dc4171b23e1cc2a",
                "240af7ca01aa2041"
            ]
        ],
        "l": true
    },
    {
        "id": "6dc4171b23e1cc2a",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Tank Level",
        "func": "/***********************************************************\n * HA Tank Status Updater\n * Takes a JSON payload as input and sends tank level updates\n * to the correct Home Assistant MQTT state topic for tank sensor entities.\n * Expects input msg.payload to be an object with:\n * - msg.payload.tank_type (String): The type of the tank (\"fresh\", \"gray\", \"black\", \"lpg\").\n * - msg.payload.level_percentage (Number): Tank level 0-100%.\n * - msg.payload.relative_level (String): Availability indicator.\n ***********************************************************/\n\n// Validate input and availability\nif (msg.payload?.relative_level === \"Not Available\" || msg.relative_level === \"Not Available\") {\n    return null; // Stop the flow if level data not available\n}\n\n// Extract values with fallback support (preserving original working logic)\nconst tankType = msg.payload?.tank_type ?? msg.tank_type;\nconst levelPercentage = msg.payload?.level_percentage ?? msg.level_percentage;\n\n// Validate tank type\nif (!tankType) {\n    node.error(\"Input missing 'tank_type'.\", msg);\n    return null; // Stop the flow\n}\n\n// Validate level percentage\nif (typeof levelPercentage !== 'number') {\n    node.error(\"Input missing 'level_percentage' (number).\", msg);\n    return null; // Stop the flow\n}\n\n// Ensure level is within valid range\nconst level = Math.max(0, Math.min(100, Math.round(levelPercentage)));\n\n// Create the state topic for this tank instance\nconst stateTopic = `homeassistant/sensor/tank_${tankType}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = level; // The payload is the numeric level percentage\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\n// Add debug information for troubleshooting\nmsg.debug_info = {\n    original_tank_type: tankType,\n    calculated_level: level,\n    raw_level_percentage: levelPercentage,\n    raw_relative_level: msg.payload?.relative_level ?? msg.relative_level\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 1240,
        "wires": [
            [
                "d4ef1d361f084b58"
            ]
        ]
    },
    {
        "id": "f9f5381eb086c0e6",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Create Tank",
        "func": "/***********************************************************\n * Tank MQTT Discovery for Home Assistant\n * Creates a sensor entity based on tank type input.\n * Expects msg.payload to be a tank type string (e.g., \"fresh\", \"gray\", \"black\", \"lpg\").\n * Example Input: msg.payload = \"fresh\"\n * Resulting Entity ID: tank_fresh\n ***********************************************************/\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\n// Map instance ID to single-word tank type and display name\nconst tankTypeMap = {\n    0: { type: \"fresh\", name: \"Fresh Water\" },\n    1: { type: \"gray\", name: \"Gray Water\" },\n    2: { type: \"black\", name: \"Black Water\" },\n    3: { type: \"lpg\", name: \"LPG\" },\n    4: { type: \"fuel\", name: \"Fuel\" },\n    5: { type: \"hot\", name: \"Hot Water\" },\n    6: { type: \"hydraulic\", name: \"Hydraulic Fluid\" },\n    7: { type: \"livewell\", name: \"Live Well\" },\n    8: { type: \"ballast\", name: \"Ballast\" },\n    9: { type: \"oil\", name: \"Oil\" },\n    10: { type: \"coolant\", name: \"Coolant\" },\n    11: { type: \"def\", name: \"DEF\" },\n    12: { type: \"air\", name: \"Air\" },\n    13: { type: \"fresh2\", name: \"Fresh Water 2\" },\n    14: { type: \"gray2\", name: \"Gray Water 2\" },\n    15: { type: \"black2\", name: \"Black Water 2\" },\n    251: { type: \"error\", name: \"Error\" },\n    252: { type: \"notsupported\", name: \"Not Supported\" },\n    253: { type: \"outofrange\", name: \"Out of Range\" },\n    254: { type: \"reserved\", name: \"Reserved\" },\n    255: { type: \"notavailable\", name: \"Not Available\" }\n};\n\nconst tankInfo = tankTypeMap[instance] || { type: \"other\", name: `Unknown Tank ${instance}` };\nconst tankType = tankInfo.type;\nconst displayName = tankInfo.name;\n\nconst entityId = `tank_${tankType}`;\nconst componentType = \"sensor\";\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    default_entity_id: `sensor.${entityId}`,\n    icon: \"mdi:water-percent\",\n\n    // Topics for Home Assistant to use\n    state_topic: stateTopic,\n\n    // Sensor configuration\n    unit_of_measurement: \"%\",\n    value_template: \"{{ value | float }}\" // Ensure it's parsed as a number\n\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 1320,
        "wires": [
            [
                "d4ef1d361f084b58",
                "da2041e2faba86a3"
            ]
        ]
    },
    {
        "id": "bfc3dc28b23b2396",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 1500,
        "wires": [
            [
                "d574ead42dd36caa"
            ]
        ]
    },
    {
        "id": "d574ead42dd36caa",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset function",
        "func": "flow.set(\"uniqueTanks\", []);\n\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1500,
        "wires": [
            []
        ]
    },
    {
        "id": "21799a7e71f6c5b4",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset tanks",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 790,
        "y": 1440,
        "wires": [
            [
                "d574ead42dd36caa"
            ]
        ],
        "l": true
    },
    {
        "id": "240af7ca01aa2041",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Unique tanks",
        "func": "const uniqueKey = \"uniqueTanks\";\n\n// Retrieve existing instances from flow context, or initialize as empty array\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (instanceId != null && !uniqueList.includes(instanceId)) {\n    uniqueList.push(instanceId);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance ID to the next function\n    return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 1320,
        "wires": [
            [
                "f9f5381eb086c0e6"
            ]
        ]
    },
    {
        "id": "da2041e2faba86a3",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Create tank",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 1320,
        "wires": []
    },
    {
        "id": "ea29386f9f8682bc",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1090,
        "y": 1660,
        "wires": [],
        "l": true
    },
    {
        "id": "663120adc5ec254f",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS_1",
        "links": [
            "bff245b2ca47ef79"
        ],
        "x": 250,
        "y": 1660,
        "wires": [
            [
                "2c1151c97bb185f2",
                "b6d90639c3fc122c"
            ]
        ],
        "l": true
    },
    {
        "id": "2c1151c97bb185f2",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Battery status",
        "func": "/***********************************************************\n * HA Battery Status Updater\n * Takes a JSON payload as input and sends battery voltage updates\n * to the correct Home Assistant MQTT state topic for battery sensor entities.\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The numeric battery instance ID.\n * - msg.payload.dc_voltage_V (Number): Battery voltage in volts.\n ***********************************************************/\n\n// Validate voltage availability - if it's \"Not Available\" string, skip\nif (msg.payload?.dc_voltage_V === \"Not Available\" || msg.dc_voltage_V === \"Not Available\") {\n    return null; // Stop the flow if voltage data not available\n}\n\n// Extract values with fallback support\nconst dcInstanceId = msg.payload?.instance ?? msg.instance;\nconst voltageValue = msg.payload?.dc_voltage_V ?? msg.dc_voltage_V;\n\n// Validate DC instance ID\nif (dcInstanceId === undefined || dcInstanceId === null) {\n    node.error(\"Input missing 'instance'.\", msg);\n    return null; // Stop the flow\n}\n\n// Map instance ID to entity suffix (must match create_battery.js)\nconst batteryMap = {\n    0: \"0\",\n    1: \"house\",\n    2: \"chassis\",\n    3: \"house2\",\n    4: \"generator\"\n};\n\n// For instances 5-250, use numeric suffix\nlet entitySuffix;\nif (dcInstanceId >= 5 && dcInstanceId <= 250) {\n    entitySuffix = dcInstanceId.toString();\n} else {\n    entitySuffix = batteryMap[dcInstanceId] || dcInstanceId.toString();\n}\n\n// Validate voltage value\nif (typeof voltageValue !== 'number') {\n    node.error(\"Input missing 'dc_voltage_V' (number).\", msg);\n    return null; // Stop the flow\n}\n\n// Ensure voltage is within reasonable range and round to 2 decimal places\nconst voltage = Math.max(0, Math.min(50, Math.round(voltageValue * 100) / 100));\n\n// Create the state topic for this battery instance\nconst stateTopic = `homeassistant/sensor/battery_${entitySuffix}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = voltage; // The payload is the numeric voltage value\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\n// Add debug information for troubleshooting\nmsg.debug_info = {\n    instance: dcInstanceId,\n    entity_suffix: entitySuffix,\n    calculated_voltage: voltage,\n    raw_voltage_V: voltageValue\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1660,
        "wires": [
            [
                "ea29386f9f8682bc"
            ]
        ]
    },
    {
        "id": "b6d90639c3fc122c",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Unique batteries",
        "func": "const uniqueKey = \"uniqueBatteries\";\n\n// Retrieve existing instances from flow context, or initialize as empty array\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (instanceId != null && !uniqueList.includes(instanceId)) {\n    uniqueList.push(instanceId);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance ID to the next function\n    return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1740,
        "wires": [
            [
                "86fa588a8393f6de"
            ]
        ]
    },
    {
        "id": "86fa588a8393f6de",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Create Battery",
        "func": "/***********************************************************\n * Battery MQTT Discovery for Home Assistant\n * Creates a sensor entity based on battery instance input.\n * Expects msg.payload to be a number (e.g., 1) or DC instance string (e.g., \"Main House Battery Bank\").\n * Example Input: msg.payload = 1 or msg.payload = \"Main House Battery Bank\"\n * Resulting Entity ID: battery_1, battery_2, etc.\n ***********************************************************/\n\n// Accept numeric instance ID from unique_batteries.js\nif (typeof msg.payload !== 'number') {\n    node.error(\"Input payload must be a number (instance ID).\", msg);\n    return null;\n}\n\nconst instanceId = msg.payload;\n\n// Map instance ID to entity suffix and display name per RV-C specification\nconst batteryMap = {\n    0: { suffix: \"0\", name: \"Invalid\" },\n    1: { suffix: \"house\", name: \"Main House Battery\" },\n    2: { suffix: \"chassis\", name: \"Chassis Battery\" },\n    3: { suffix: \"house2\", name: \"Secondary House Battery\" },\n    4: { suffix: \"generator\", name: \"Generator Battery\" }\n};\n\n// For instances 5-250, use generic \"battery_X\" naming\nlet entitySuffix;\nlet displayName;\nif (instanceId >= 5 && instanceId <= 250) {\n    entitySuffix = instanceId.toString();\n    displayName = `Battery ${instanceId}`;\n} else {\n    const batteryInfo = batteryMap[instanceId] || { suffix: instanceId.toString(), name: `Unknown Battery ${instanceId}` };\n    entitySuffix = batteryInfo.suffix;\n    displayName = batteryInfo.name;\n}\n\nconst entityId = `battery_${entitySuffix}`;\nconst componentType = \"sensor\";\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    default_entity_id: `sensor.${entityId}`,\n    icon: \"mdi:home-battery-outline\",\n\n    // Topics for Home Assistant to use\n    state_topic: stateTopic,\n\n    // Sensor configuration\n    unit_of_measurement: \"V\",\n    device_class: \"voltage\",\n    value_template: \"{{ value | float | round(2) }}\"\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 1740,
        "wires": [
            [
                "ea29386f9f8682bc",
                "0d54f0db9a010394"
            ]
        ]
    },
    {
        "id": "7c04541818436246",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 1920,
        "wires": [
            [
                "738718a321d185e7"
            ]
        ]
    },
    {
        "id": "738718a321d185e7",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset function",
        "func": "flow.set(\"uniqueBatteries\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1920,
        "wires": [
            []
        ]
    },
    {
        "id": "b9f27aaa32da92c0",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "d68c2206e3379850",
        "name": "Reset batteries",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 820,
        "y": 1860,
        "wires": [
            [
                "738718a321d185e7"
            ]
        ],
        "l": true
    },
    {
        "id": "64578fa414def60a",
        "type": "comment",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS types",
        "info": "DC_SOURCE_STATUS_1: This is the most basic status message. It provides the fundamental electrical readings: \n\nDC Voltage and DC Current. A positive current value indicates the source is discharging (power flowing out), while a negative value indicates it is charging.\n\nDC_SOURCE_STATUS_2: This message adds thermal and capacity information. It reports the \n\nSource Temperature, the battery's State of Charge (SOC) as a percentage, and the estimated Time Remaining until the battery is either full or empty.\n\nDC_SOURCE_STATUS_3: This provides more nuanced details about the battery's long-term health and capacity. It includes the \n\nState of Health (SOH), Capacity Remaining in amp-hours, and Relative Capacity, which is the state of charge adjusted for the state of health.\n\n\nDC_SOURCE_STATUS_5: This message is for high-precision measurement. It reports the \n\nDC Voltage with 0.001 V precision, allowing for more accurate remote voltage sensing without needing dedicated wires.",
        "x": 300,
        "y": 1820,
        "wires": []
    },
    {
        "id": "0d54f0db9a010394",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "5d1ecae7ac09586c",
        "name": "Create battery",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 1740,
        "wires": []
    },
    {
        "id": "8eb8085bb7cfee43",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Create shade",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 940,
        "wires": []
    },
    {
        "id": "942c2aa2bb3167c9",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Create lock",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 580,
        "wires": []
    },
    {
        "id": "52e43edcfad810dd",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 200,
        "wires": []
    },
    {
        "id": "bc627a6a37117bc0",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1070,
        "y": 2080,
        "wires": [],
        "l": true
    },
    {
        "id": "efb5c968a0a43c7d",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "WATER_PUMP_STATUS",
        "links": [
            "295d4bc9058dab71"
        ],
        "x": 250,
        "y": 2080,
        "wires": [
            [
                "5a307ecdca9415b1",
                "c3c4a8bcea0243e9"
            ]
        ],
        "l": true
    },
    {
        "id": "5a307ecdca9415b1",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Unique water pump",
        "func": "const uniqueKey = \"uniqueWaterPumps\";\n\n// Retrieve existing instances from flow context\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Get instance name from message payload\nconst instanceName = msg.payload.instance;\n\n// Check if this instance name has been seen before\nif (instanceName && !uniqueList.includes(instanceName)) {\n    uniqueList.push(instanceName);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance name to the creation function\n    return { payload: { instance: instanceName } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 2140,
        "wires": [
            [
                "141bdcfc9aec9232"
            ]
        ]
    },
    {
        "id": "c3c4a8bcea0243e9",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Water Pump Status",
        "func": "/***********************************************************\n * HA Status Updater for Water Pump\n * Publishes the pre-calculated status from the upstream decoder.\n *\n * Expects input msg.payload with:\n * - msg.payload.instance (String): The device instance name (e.g., \"water_pump\")\n * - msg.payload.status (String): The final status, \"on\" or \"off\"\n ***********************************************************/\n\nif (!msg.payload || typeof msg.payload.instance !== 'string' || typeof msg.payload.status !== 'string') {\n    node.error(\"Input missing 'instance' (string) or 'status' (string).\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst haStatus = msg.payload.status.toUpperCase(); // Ensure payload is \"ON\" or \"OFF\"\n\n// Construct the MQTT state topic\nconst stateTopic = `homeassistant/switch/${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus;\nmsg.retain = true; // Retain the status for HA restarts\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 2080,
        "wires": [
            [
                "bc627a6a37117bc0"
            ]
        ]
    },
    {
        "id": "141bdcfc9aec9232",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Create water pump",
        "func": "/***********************************************************\n * MQTT Discovery for Water Pump\n * Creates a switch entity based on a string instance name.\n *\n * Expects input msg.payload with:\n * - msg.payload.instance (String): The device instance name (e.g., \"water_pump\")\n ***********************************************************/\n\nif (!msg.payload || typeof msg.payload.instance !== 'string') {\n    node.error(\"Input must be an object with a string 'instance' property.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance; // e.g., \"water_pump\"\n\n// Device configuration\nconst displayName = \"Water Pump\"; // Simplified display name\nconst icon = \"mdi:water-pump\";\nconst componentType = \"switch\";\n\n// Generate entity identifiers directly from the instance string\nconst entityId = instance;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload for Home Assistant\nconst payload = {\n    name: displayName,\n    unique_id: entityId,\n    icon: icon,\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n    payload_on: \"ON\",\n    payload_off: \"OFF\"\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\nmsg.retain = true;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 2140,
        "wires": [
            [
                "bc627a6a37117bc0",
                "81de1ec667d84484"
            ]
        ]
    },
    {
        "id": "3e1cb0098e246ca4",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "77cecc17525bec45",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 2320,
        "wires": [
            [
                "876c4f2ff7fb1ae4"
            ]
        ]
    },
    {
        "id": "876c4f2ff7fb1ae4",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "77cecc17525bec45",
        "name": "Reset function",
        "func": "flow.set(\"uniqueWaterPumps\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 2320,
        "wires": [
            []
        ]
    },
    {
        "id": "99381e18a0d5f318",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "77cecc17525bec45",
        "name": "Reset water pump",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 810,
        "y": 2260,
        "wires": [
            [
                "876c4f2ff7fb1ae4"
            ]
        ],
        "l": true
    },
    {
        "id": "cff02a511add6887",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1070,
        "y": 2460,
        "wires": [],
        "l": true
    },
    {
        "id": "93a2783b5bb8d93d",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "AUTOFILL_STATUS",
        "links": [
            "b87fcd5e60905824"
        ],
        "x": 230,
        "y": 2460,
        "wires": [
            [
                "2f36862dec231b98",
                "5004281b11ec3bd7"
            ]
        ],
        "l": true
    },
    {
        "id": "2f36862dec231b98",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Unique autofill",
        "func": "const uniqueKey = \"uniqueAutofill\";\n\n// Retrieve existing instances from flow context\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Get instance name from message payload\nconst instanceName = msg.payload.instance;\n\n// Check if this instance name has been seen before\nif (instanceName && !uniqueList.includes(instanceName)) {\n    uniqueList.push(instanceName);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance name to the creation function\n    return { payload: { instance: instanceName } };\n}\n\n// Return nothing if duplicate instance\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 2520,
        "wires": [
            [
                "89855c1c4c586196"
            ]
        ]
    },
    {
        "id": "5004281b11ec3bd7",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Autofill status",
        "func": "/***********************************************************\n * HA Status Updater for AutoFill\n * Publishes the pre-calculated status from the upstream decoder.\n *\n * Expects input msg.payload with:\n * - msg.payload.instance (String): The device instance name (\"autofill\")\n * - msg.payload.status (String): The final status, \"on\" or \"off\"\n ***********************************************************/\n\nif (!msg.payload || typeof msg.payload.instance !== 'string' || typeof msg.payload.status !== 'string') {\n    node.error(\"Input missing 'instance' (string) or 'status' (string).\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst haStatus = msg.payload.status.toUpperCase(); // Ensure payload is \"ON\" or \"OFF\"\n\n// Construct the MQTT state topic to match the entity creator\nconst stateTopic = `homeassistant/switch/${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus;\nmsg.retain = true; // Retain the status for HA restarts\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 2460,
        "wires": [
            [
                "cff02a511add6887"
            ]
        ]
    },
    {
        "id": "89855c1c4c586196",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Create autofill",
        "func": "/***********************************************************\n * MQTT Discovery for AutoFill\n * Creates a switch entity based on the string instance \"autofill\".\n ***********************************************************/\nif (!msg.payload || typeof msg.payload.instance !== 'string') {\n    node.error(\"Input must be an object with a string 'instance' property.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance; // e.g., \"autofill\"\n\n// Device configuration\nconst displayName = \"Autofill\";\nconst icon = \"mdi:water-plus-outline\";\nconst componentType = \"switch\";\n\n// Generate entity identifiers directly from the instance string\nconst entityId = instance;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n    name: displayName,\n    unique_id: entityId,\n    icon: icon,\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n    payload_on: \"ON\",\n    payload_off: \"OFF\"\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\nmsg.retain = true;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 2520,
        "wires": [
            [
                "cff02a511add6887",
                "dd0bc2a54fe2a072"
            ]
        ]
    },
    {
        "id": "4119a569e77d3350",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "2a121d2dbd94eecd",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 2700,
        "wires": [
            [
                "f6151272dcfe1559"
            ]
        ]
    },
    {
        "id": "f6151272dcfe1559",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "2a121d2dbd94eecd",
        "name": "Reset function",
        "func": "flow.set(\"uniqueAutofill\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 2700,
        "wires": [
            []
        ]
    },
    {
        "id": "d192b275aac0824e",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "2a121d2dbd94eecd",
        "name": "Reset autofill",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 790,
        "y": 2640,
        "wires": [
            [
                "f6151272dcfe1559"
            ]
        ],
        "l": true
    },
    {
        "id": "dd0bc2a54fe2a072",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Create autofill",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 2520,
        "wires": []
    },
    {
        "id": "81de1ec667d84484",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Create water pump",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 2140,
        "wires": []
    },
    {
        "id": "2d6bf3e8aa77a8c6",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unlocked",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 300,
        "wires": []
    },
    {
        "id": "4d7e38077918190f",
        "type": "switch",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "",
        "property": "payload.lock_status",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Unlocked",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Locked",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 230,
        "y": 340,
        "wires": [
            [
                "2d6bf3e8aa77a8c6"
            ],
            [
                "bc185e54ce871b11"
            ],
            [
                "a9779b1f38edf18d"
            ]
        ]
    },
    {
        "id": "85dabd5afaf4b17d",
        "type": "switch",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "48",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 620,
        "y": 80,
        "wires": [
            [
                "9c61a141b8525561"
            ]
        ]
    },
    {
        "id": "9c61a141b8525561",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 80,
        "wires": []
    },
    {
        "id": "bc185e54ce871b11",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Locked",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 340,
        "wires": []
    },
    {
        "id": "a9779b1f38edf18d",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "debug 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 380,
        "wires": []
    },
    {
        "id": "f0ba2779795efdae",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 2390,
        "y": 80,
        "wires": [],
        "l": true
    },
    {
        "id": "bd2d1b59183b99bb",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "FLOOR_HEAT_STATUS",
        "links": [
            "db73295f937c90a1"
        ],
        "x": 1570,
        "y": 80,
        "wires": [
            [
                "aa518caf7366cec9",
                "f183a66e28426985",
                "e3f64f273f5bdaa5"
            ]
        ],
        "l": true
    },
    {
        "id": "aa518caf7366cec9",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Unique floor heat",
        "func": "// unique_floor_heat.js\n//\n// Combines instance and level discovery into a single node.\n// 1. Tracks unique instances in session context (\"uniqueFloorHeat\").\n// 2. Tracks unique levels in PERSISTENT context (\"uniqueFloorHeatLevels\").\n\n// --- Configuration ---\nconst instanceKey = \"uniqueFloorHeat\"; // Session-only\nconst levelsKey = \"uniqueFloorHeatLevels\"; // Persistent\n\n// --- 1. Get data from payload ---\nconst instanceId = msg.payload.instance;\nconst raw_setpoint = msg.payload.raw_setpoint;\nconst schedule_mode = msg.payload.schedule_mode; // \"Enabled\" or \"Disabled\"\n\n// --- 2. Validate input ---\nif (typeof instanceId !== 'number') {\n    return null; // No instance, can't proceed\n}\n\n// We only want to discover a level if:\n// 1. The setpoint is > 1 (to filter \"Off\" and test values)\n// 2. The schedule_mode is \"Enabled\"\nconst isValidLevel = (\n    typeof raw_setpoint === 'number' &&\n    raw_setpoint > 1 &&\n    schedule_mode === \"Enabled\"\n);\n\n// --- 3. Get context lists ---\nlet instanceList = flow.get(instanceKey) || [];\nlet levelList = global.get(levelsKey, \"file\") || [];\n\nlet isNewInstance = false;\nlet isNewLevel = false;\n\n// --- 4. Process Instance ---\nif (!instanceList.includes(instanceId)) {\n    isNewInstance = true;\n    instanceList.push(instanceId);\n    flow.set(instanceKey, instanceList); // Save to session context\n}\n\n// --- 5. Process Level ---\n// This block will now ONLY run if isValidLevel is true\nif (isValidLevel && !levelList.includes(raw_setpoint)) {\n    isNewLevel = true;\n    levelList.push(raw_setpoint);\n    levelList.sort((a, b) => a - b);\n    global.set(levelsKey, levelList, \"file\"); // Save to persistent context\n    node.log(`Discovered new floor heat level: ${raw_setpoint}`);\n}\n\n// --- 6. Output Logic ---\nif (!isNewInstance && !isNewLevel) {\n    return null; // Nothing new, stop here\n}\n\nif (isNewLevel) {\n    //node.warn(`New level found. Sending config updates for all known instances: ${instanceList.join(', ')}`);\n\n    let outputs = [];\n    for (const inst of instanceList) {\n        outputs.push({ payload: { instance: inst } });\n    }\n    return outputs;\n}\n\nif (isNewInstance) {\n    return { payload: { instance: instanceId } };\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 140,
        "wires": [
            [
                "b3e18602b6affaf5"
            ]
        ]
    },
    {
        "id": "f183a66e28426985",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Floor heat status",
        "func": "// publish_floor_heat_status.js\n//\n// 1. Formats the climate status.\n// 2. Formats the schedule switch status.\n// 3. Saves the current schedule state to PERSISTENT context.\n// 4. Outputs an array of 2 messages.\n\nconst payload = msg.payload;\nconst instance = payload.instance;\nconst raw_setpoint = payload.raw_setpoint;\n\n// --- Get the Level Map ---\nconst levelMap = global.get(\"floorHeatLevelMap\", \"file\") || {};\n\n// --- 1. Prepare Climate Status ---\nconst climatePayload = {};\nclimatePayload.measured_temperature = payload.measured_temperature;\n\n// Translate raw_setpoint to preset name\nconst preset = levelMap[raw_setpoint];\nif (preset) {\n    climatePayload.preset_mode = preset;\n} else if (raw_setpoint === 0) {\n    climatePayload.preset_mode = \"Off\";\n} else {\n    climatePayload.preset_mode = \"Unknown\";\n}\n\n// --- Set Action, Mode, and Setpoint ---\nif (payload.operating_status === \"Off\") {\n    climatePayload.action = \"off\";\n    climatePayload.mode = \"off\";\n    climatePayload.set_point = null; // Hide setpoint when Off\n\n} else {\n    // Unit is On (either 'heat' or 'idle')\n    climatePayload.mode = \"heat\";\n\n    if (climatePayload.preset_mode === \"Store\") {\n        climatePayload.action = \"idle\";\n        climatePayload.set_point = null; // Hide setpoint in Store mode\n    } else {\n        // --- Handling for all other levels (Level 1, etc.) ---\n        climatePayload.set_point = payload.set_point;\n        \n        // Check the 'heating_active' property from the INPUT payload\n        if (payload.heating_active) { \n            climatePayload.action = \"heating\";\n        } else {\n            climatePayload.action = \"idle\";\n        }\n    }\n}\n\n// --- 2. Prepare Schedule Status ---\nlet scheduleStateOn = false;\nlet scheduleStatePayload = \"OFF\";\n\nif (payload.schedule_mode === \"Enabled\") {\n    scheduleStateOn = true;\n    scheduleStatePayload = \"ON\";\n}\n\n// --- 3. Save Schedule State to PERSISTENT Context ---\nconst scheduleContextKey = `floorHeat_${instance}_ScheduleOn`;\nglobal.set(scheduleContextKey, scheduleStateOn, \"file\");\n\n// --- 4. Create Output Messages ---\nconst climateEntityId = `floor_heat_${instance}`;\nconst climateStateTopic = `homeassistant/climate/${climateEntityId}/state`;\nconst climateMsg = {\n    topic: climateStateTopic,\n    payload: climatePayload\n};\n\nconst switchEntityId = `floor_heat_${instance}_schedule`;\nconst switchStateTopic = `homeassistant/switch/${switchEntityId}/state`;\nconst switchMsg = {\n    topic: switchStateTopic,\n    payload: scheduleStatePayload\n};\n\nreturn [climateMsg, switchMsg];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 80,
        "wires": [
            [
                "f0ba2779795efdae",
                "1a10fdc6f9970a2f"
            ]
        ]
    },
    {
        "id": "b3e18602b6affaf5",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Create floor heat",
        "func": "// create_floor_heat.js\n//\n// Creates BOTH a climate entity and a schedule switch entity.\n// Outputs an array of 2 messages.\n\nconst instance = msg.payload.instance;\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\n// --- Get Discovered Levels ---\nconst levelsKey = \"uniqueFloorHeatLevels\";\nconst levels = global.get(levelsKey, \"file\") || [];\n\n// --- Build Preset List and Map ---\nlet levelMap = {};\nlet presetList = [];\nlet levelCounter = 1;\n\n// The 'unique' node sorts the list, so the lowest value is always first.\n// Get the lowest level (\"Store\").\nconst lowestLevel = levels.length > 0 ? levels[0] : null;\n\nfor (const rawVal of levels) {\n    let name;\n\n    // Check if the current value is the lowest one we found\n    if (rawVal === lowestLevel) {\n        name = \"Store\"; // Dynamically assigned to the lowest value\n    } else {\n        name = `Level ${levelCounter++}`;\n    }\n\n    presetList.push(name);\n    levelMap[name] = rawVal;\n    levelMap[rawVal] = name;\n}\nglobal.set(\"floorHeatLevelMap\", levelMap, \"file\");\n\n// --- Entity 1: Climate ---\nconst climateEntityId = `floor_heat_${instance}`;\nconst climateStateTopic = `homeassistant/climate/${climateEntityId}/state`;\nconst climateDiscoveryTopic = `homeassistant/climate/${climateEntityId}/config`;\n\nconst climatePayload = {\n    name: `Floor Heat ${instance}`,\n    unique_id: climateEntityId,\n    icon: \"mdi:heating-coil\",\n\n    // --- State Reporting ---\n    action_topic: climateStateTopic,\n    action_template: \"{{ value_json.action }}\",\n    current_temperature_topic: climateStateTopic,\n    current_temperature_template: \"{{ value_json.measured_temperature }}\",\n    temperature_state_topic: climateStateTopic,\n    temperature_state_template: \"{{ value_json.set_point }}\",\n\n    mode_state_topic: climateStateTopic,\n    mode_state_template: \"{{ value_json.mode }}\",\n\n    preset_mode_state_topic: climateStateTopic,\n    preset_mode_state_template: \"{{ value_json.preset_mode }}\",\n\n    // --- Commands ---\n    mode_command_topic: `homeassistant/climate/${climateEntityId}/set_mode`,\n    modes: [\"off\", \"heat\"],\n\n    // Temperature command topic (probably not needed)\n    temperature_command_topic: `homeassistant/climate/${climateEntityId}/set_temperature`,\n\n    preset_mode_command_topic: `homeassistant/climate/${climateEntityId}/set_preset_mode`,\n    preset_modes: presetList,\n    temperature_unit: \"F\"\n};\n\n// --- Entity 2: Schedule Switch (Light) ---\nconst componentType = \"light\";\nconst switchEntityId = `floor_heat_${instance}_schedule`;\nconst switchStateTopic = `homeassistant/${componentType}/${switchEntityId}/state`;\nconst switchCommandTopic = `homeassistant/${componentType}/${switchEntityId}/set`;\nconst switchDiscoveryTopic = `homeassistant/${componentType}/${switchEntityId}/config`;\n\nconst switchPayload = {\n    name: `Floor Heat ${instance} Schedule`,\n    unique_id: switchEntityId,\n    icon: \"mdi:calendar-clock\",\n    command_topic: switchCommandTopic, // Topic HA sends commands to\n    state_topic: switchStateTopic,     // Topic HA reads state from\n    state_value_template: \"{{ value_json.state }}\",\n    payload_on: \"ON\",\n    payload_off: \"OFF\"\n};\n\n// --- Prepare Output Messages ---\nconst climateMsg = {\n    topic: climateDiscoveryTopic,\n    payload: climatePayload,\n    retain: true\n};\n\nconst switchMsg = {\n    topic: switchDiscoveryTopic,\n    payload: switchPayload,\n    retain: true\n};\n\nreturn [[climateMsg, switchMsg]];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 140,
        "wires": [
            [
                "f0ba2779795efdae",
                "6e53b4f33db9f29c"
            ]
        ]
    },
    {
        "id": "a9069efd6410088f",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "1f7fde87c1ab1f51",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2130,
        "y": 320,
        "wires": [
            [
                "7a0956cdace18b52"
            ]
        ]
    },
    {
        "id": "7a0956cdace18b52",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "1f7fde87c1ab1f51",
        "name": "Reset function",
        "func": "flow.set(\"uniqueFloorHeat\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2380,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "893d80d1125057e8",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "1f7fde87c1ab1f51",
        "name": "Reset floor heat",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 2120,
        "y": 260,
        "wires": [
            [
                "7a0956cdace18b52"
            ]
        ],
        "l": true
    },
    {
        "id": "6e53b4f33db9f29c",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Create floor heat",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2370,
        "y": 140,
        "wires": []
    },
    {
        "id": "56aa8b5c045b391d",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "ee5f54f521f5ecda",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1610,
        "y": 320,
        "wires": [
            [
                "870bf91817db9d08"
            ]
        ]
    },
    {
        "id": "870bf91817db9d08",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ee5f54f521f5ecda",
        "name": "Reset function",
        "func": "// --- Reset persistent and in-memory context cleanly ---\n\n// Helper function to clear both stores\nfunction clearContext(key) {\n    // Remove persistent value\n    global.set(key, undefined, \"file\");\n    // Remove in-memory value\n    global.set(key, undefined);\n}\n\n// --- Clear specific global variables ---\nclearContext(\"uniqueFloorHeatLevels\");\nclearContext(\"floorHeatLevelMap\");\n\n// --- Clear specific flow variables ---\nflow.set(\"uniqueFloorHeat\", undefined, \"file\");\nflow.set(\"uniqueFloorHeat\", undefined);\nflow.set(\"floorHeatLevelMap\", undefined, \"file\");\nflow.set(\"floorHeatLevelMap\", undefined);\n\nnode.warn(\"Context cleared\");\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1800,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "e3f64f273f5bdaa5",
        "type": "switch",
        "z": "3470febb2cd6e952",
        "name": "",
        "property": "payload.instance",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1830,
        "y": 480,
        "wires": [
            [
                "74e9b3d485eb5735"
            ],
            [
                "5aa079ea85cca5b0"
            ],
            [
                "cd4ce201cf6c3c35"
            ]
        ]
    },
    {
        "id": "74e9b3d485eb5735",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "name": "Floor Heat 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2040,
        "y": 480,
        "wires": []
    },
    {
        "id": "da37ca2cff193df6",
        "type": "function",
        "z": "3470febb2cd6e952",
        "name": "function 1",
        "func": "// Read all your persistent context values\nconst levelList = global.get(\"uniqueFloorHeatLevels\", \"file\");\nconst levelMap = global.get(\"floorHeatLevelMap\", \"file\");\nconst instanceList = flow.get(\"uniqueFloorHeat\"); // memory\n\nmsg.payload = {\n    levelList: levelList,\n    levelMap: levelMap,\n    instanceList: instanceList\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1860,
        "y": 840,
        "wires": [
            [
                "957a1cce5fc519c4",
                "9cdde5d38e985fcc",
                "b4dd91b512e049fa"
            ]
        ]
    },
    {
        "id": "f7c4163bb54a8306",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1660,
        "y": 840,
        "wires": [
            [
                "da37ca2cff193df6"
            ]
        ]
    },
    {
        "id": "957a1cce5fc519c4",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.levelList",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2050,
        "y": 780,
        "wires": []
    },
    {
        "id": "9cdde5d38e985fcc",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "name": "debug 5",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.levelMap",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2030,
        "y": 840,
        "wires": []
    },
    {
        "id": "b4dd91b512e049fa",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "name": "debug 6",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.instanceList",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2020,
        "y": 900,
        "wires": []
    },
    {
        "id": "5aa079ea85cca5b0",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Floor Heat 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2030,
        "y": 520,
        "wires": []
    },
    {
        "id": "cd4ce201cf6c3c35",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "Floor Heat 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2030,
        "y": 580,
        "wires": []
    },
    {
        "id": "1a10fdc6f9970a2f",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "8da591d6205a352e",
        "name": "debug 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1990,
        "y": 40,
        "wires": []
    },
    {
        "id": "9f88f215f3f07227",
        "type": "switch",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DIGITAL_INPUT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WATER_PUMP_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AUTOFILL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WINDOW_SHADE_CONTROL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "LOCK_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "TANK_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_SOURCE_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_AMBIENT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FLOOR_HEAT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FURNACE_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "GENERATOR_DEMAND_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ATS_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "CHARGER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHARGER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "INVERTER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_DC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AC_LOAD_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ATS_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "SOLAR_EQUALIZATION_CONFIGURATION_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_2",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DC_SOURCE_STATUS",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 29,
        "x": 420,
        "y": 260,
        "wires": [
            [],
            [
                "9e8e5609c54fec82"
            ],
            [
                "96c3c21a4dd0b9bd"
            ],
            [
                "4a6d57460d64c76f"
            ],
            [
                "3b2f348b9326267c"
            ],
            [
                "eb3524b2b7bf51e5"
            ],
            [
                "2e5425d73a166c9b"
            ],
            [
                "010c5119a7e833b2"
            ],
            [
                "ccec30ad0f32bbdf"
            ],
            [
                "ae9f041c9cd36bb9"
            ],
            [
                "1bb521d55aeb5eba"
            ],
            [
                "cd9d55c23ebcee86"
            ],
            [
                "d76a4a48e1beaed6"
            ],
            [
                "6b27f0f99ea11a72"
            ],
            [
                "f82e60f4adb5e60b"
            ],
            [
                "e5d61c5724c6ed1b"
            ],
            [
                "bacdea9854675b01"
            ],
            [
                "f171dcbe8b5d2e05"
            ],
            [
                "b2bda5ef5e68c98d"
            ],
            [
                "cb64b7a9a87f03cc"
            ],
            [
                "9621acf15d833362"
            ],
            [
                "b91d72f6d383c0d6"
            ],
            [
                "c38d48059f463772"
            ],
            [
                "a0357de00b26b002"
            ],
            [
                "0ecfccb41b17f21b"
            ],
            [
                "1b079a5b225e1552"
            ],
            [
                "f945d56c437bfb38"
            ],
            [
                "40bc1ec5180b6589"
            ],
            [
                "b797e5a52b6db5b4"
            ]
        ]
    },
    {
        "id": "96c3c21a4dd0b9bd",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AUTOFILL_STATUS",
        "func": "// Simplified AUTOFILL_STATUS Decoder\n// Decodes the status to a final \"on\" or \"off\" and uses a string instance name.\n\n/**\n * Main function to decode the incoming autofill message.\n * @param {string} dgn - The DGN of the message.\n * @param {number[]} data - The data payload as an array of bytes.\n * @returns {object} A result object.\n */\nfunction decodeAutofillMessage(dgn, data) {\n    let finalStatus = \"off\";\n\n    // Check the first byte for the operating status\n    if (data.length > 0) {\n        const operatingStatusBits = data[0] & 0x03; // Mask for bits 0-1\n        if (operatingStatusBits === 1) { // 01b = AutoFill on\n            finalStatus = \"on\";\n        }\n    }\n\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AUTOFILL_STATUS\",\n        instance: \"autofill\", // Hard-code to string instance name\n        status: finalStatus,\n    };\n\n    return result;\n}\n\n// === Main Logic ===\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected an object');\n    return null;\n}\nconst { dgn, dataPayload } = msg.payload;\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(dataPayload.substring(i, i + 2), 16));\n}\nconst decodedData = decodeAutofillMessage(dgn, dataBytes);\nmsg.payload = { ...msg.payload, ...decodedData };\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 100,
        "wires": [
            [
                "b87fcd5e60905824"
            ]
        ]
    },
    {
        "id": "19307edfe4e5bd84",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 1060,
        "wires": []
    },
    {
        "id": "b2bda5ef5e68c98d",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_AC_STATUS",
        "func": "// CHARGER_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes CHARGER_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC input status for battery chargers (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_AC_STATUS Specific Decoders ===\n\nfunction decodeChargerACInstance(value) {\n    // Charger AC instance interpretation per RV-C spec\n    // For chargers, this typically indicates the AC input line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    // Special handling for 0xFF (all bits set) - typically means \"Not Available\"\n    if (value === 255) {\n        return {\n            faults: \"No Faults\",\n            open_ground: false,\n            open_neutral: false,\n            reverse_polarity: false,\n            ground_current_fault: false,\n            any_fault: false\n        };\n    }\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeChargerACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.charging_capable = result.ac_available && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_AC_STATUS message\nconst decodedData = decodeChargerACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1060,
        "wires": [
            [
                "19307edfe4e5bd84"
            ]
        ]
    },
    {
        "id": "91cac903d306591a",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 1180,
        "wires": []
    },
    {
        "id": "9621acf15d833362",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_AC_STATUS",
        "func": "// INVERTER_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC output status for inverters (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_AC_STATUS Specific Decoders ===\n\nfunction decodeInverterACInstance(value) {\n    // Inverter AC instance interpretation per RV-C spec\n    // For inverters, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeInverterACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active = result.rms_voltage !== \"Not Available\" &&\n                             typeof result.rms_voltage === 'number' &&\n                             result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.inverter_loaded = result.rms_current !== \"Not Available\" &&\n                            typeof result.rms_current === 'number' &&\n                            result.rms_current > 0.1; // Some current flow\n\n    result.inverter_available = !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_AC_STATUS message\nconst decodedData = decodeInverterACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1180,
        "wires": [
            [
                "91cac903d306591a"
            ]
        ]
    },
    {
        "id": "9e8e5609c54fec82",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WATER_PUMP_STATUS",
        "func": "// Standard RV-C WATER_PUMP_STATUS Decoder\n// Decodes the standard DGN 1FFB3h to a simple \"on\" or \"off\" status.\n\n// Validate input payload from the CAN bus node\nif (!msg.payload || typeof msg.payload.dataPayload !== 'string') {\n    node.warn('Invalid payload: expected object with dataPayload string.');\n    return null;\n}\n\nconst dataPayload = msg.payload.dataPayload;\n\n// We only need the first byte for the status\nif (dataPayload.length < 2) {\n    node.warn(\"Data payload is too short to decode.\");\n    return null;\n}\n\n// Get the first byte and parse it\nconst firstByte = parseInt(dataPayload.substring(0, 2), 16);\n\n// Extract the first two bits (00-11) which represent the operating status\nconst statusBits = firstByte & 0x03; // Mask to get only the first two bits\n\n// Per the RV-C spec, a value of 1 means \"enabled\"\nconst finalStatus = (statusBits === 1) ? \"ON\" : \"OFF\";\n\n// Prepare the payload for the downstream status updater node\nmsg.payload = {\n    ...msg.payload, // Keep the original message data\n    instance: \"water_pump\",\n    status: finalStatus\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 40,
        "wires": [
            [
                "295d4bc9058dab71"
            ]
        ]
    },
    {
        "id": "b9d5913b9730b3e0",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_AMBIENT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1370,
        "y": 580,
        "wires": []
    },
    {
        "id": "1bb521d55aeb5eba",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_AMBIENT_STATUS",
        "func": "// THERMOSTAT_AMBIENT_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_AMBIENT_STATUS messages per RV-C specification\n// Handles ambient temperature and humidity sensors\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_AMBIENT_STATUS Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value <= 250) {\n        return \"Out of Range\"; // Values 201-250\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40C to +170C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeHumidity(value) {\n    // Humidity as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDewPoint(value, isCelsius = false) {\n    // Dew point temperature with same encoding as ambient temperature\n    return decodeTemperature(value, isCelsius);\n}\n\nfunction decodeAirQuality(value) {\n    // Air quality index\n    const qualityLevels = {\n        0: \"Good\",\n        1: \"Moderate\",\n        2: \"Unhealthy for Sensitive\",\n        3: \"Unhealthy\",\n        4: \"Very Unhealthy\",\n        5: \"Hazardous\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return qualityLevels[value] || `Unknown Quality ${value}`;\n}\n\nfunction decodeSensorStatus(value) {\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 251) {\n        return \"Error\";\n    }\n\n    // Sensor status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Temperature Valid\");\n    if (value & 0x02) statusBits.push(\"Humidity Valid\");\n    if (value & 0x04) statusBits.push(\"Dew Point Valid\");\n    if (value & 0x08) statusBits.push(\"Air Quality Valid\");\n    if (value & 0x10) statusBits.push(\"Sensor Calibrated\");\n    if (value & 0x20) statusBits.push(\"Sensor Fault\");\n    if (value & 0x40) statusBits.push(\"Low Battery\");\n    if (value & 0x80) statusBits.push(\"Communication Error\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_AMBIENT_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'ambient temperature' || param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name.includes('humidity')) {\n            return decodeHumidity(value);\n        }\n        if (param.name === 'dew point' || param.name.includes('dew')) {\n            return decodeDewPoint(value);\n        }\n        if (param.name === 'air quality' || param.name.includes('quality')) {\n            return decodeAirQuality(value);\n        }\n        if (param.name === 'sensor status' || param.name.includes('status')) {\n            return decodeSensorStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatAmbientMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_AMBIENT_STATUS\"\n    };\n\n    // Decode based on THERMOSTAT_AMBIENT_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[1]);\n\n        // Byte 2: Humidity\n        result.humidity = decodeHumidity(data[2]);\n\n        // Byte 3: Dew Point\n        result.dew_point = decodeDewPoint(data[3]);\n\n        // Byte 4: Air Quality Index\n        result.air_quality = decodeAirQuality(data[4]);\n\n        // Byte 5: Sensor Status\n        result.sensor_status = decodeSensorStatus(data[5]);\n\n        // Bytes 6-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_ambient_temperature = data[1];\n        result.raw_humidity = data[2];\n        result.raw_dew_point = data[3];\n        result.raw_air_quality = data[4];\n        result.raw_sensor_status = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    if (result.ambient_temperature !== undefined && typeof result.ambient_temperature === 'number') {\n        result.temperature_fahrenheit = parseFloat(((result.ambient_temperature * 9 / 5) + 32).toFixed(1));\n    }\n\n    result.sensor_available = result.instance !== \"Not Available\" &&\n        result.ambient_temperature !== \"Not Available\";\n\n    result.humidity_available = typeof result.humidity === 'number';\n    result.air_quality_available = result.air_quality !== \"Not Available\" &&\n        result.air_quality !== \"Not Supported\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_AMBIENT_STATUS message\nconst decodedData = decodeThermostatAmbientMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 580,
        "wires": [
            [
                "b9d5913b9730b3e0"
            ]
        ]
    },
    {
        "id": "cd9d55c23ebcee86",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FLOOR_HEAT_STATUS",
        "func": "// FLOOR_HEAT_STATUS Decoder\n\nfunction decodeFloorHeatInstance(value) {\n    // Per Table 5.3 (Standard_Physical_Units.pdf, pg 2) \n    if (value === 0) {\n        return \"all\"; // \n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 254) {\n        return \"Out of range / not configured\"; // \n    } else if (value === 255) {\n        return \"Data not available\"; // \n    }\n    // Values 251-253 are not defined in this standard\n    return \"Reserved/Invalid\";\n}\n\n/**\n * Decodes Operating Mode from Byte 1, Bits 0-1 \n */\nfunction decodeOperatingMode(value) {\n    const modes = {\n        0: \"Automatic\", // 00b \n        1: \"Manual\"     // 01b \n    };\n    return modes[value] || \"Reserved\";\n}\n\n/**\n * Decodes Operating Status from Byte 1, Bits 2-3 \n */\nfunction decodeOperatingStatus(value) {\n    const states = {\n        0: \"Off\", // 00b \n        1: \"On\"   // 01b \n    };\n    return states[value] || \"Reserved\";\n}\n\n/**\n * Decodes Heat Element Status from Byte 1, Bits 4-5 \n */\nfunction decodeHeatElementStatus(value) {\n    const states = {\n        0: \"Off\", // 00b \n        1: \"On\"   // 01b \n    };\n    return states[value] || \"Reserved\";\n}\n\n/**\n * Decodes Schedule Mode from Byte 1, Bits 6-7 \n */\nfunction decodeScheduleMode(value) {\n    const modes = {\n        0: \"Disabled\", // 00b \n        1: \"Enabled\"   // 01b \n    };\n    return modes[value] || \"Reserved\";\n}\n\n/**\n * Decodes a standard RV-C temperature value (uint16).\n * Uses 0.03125C resolution (per RVC spec) with -273.15C offset (Kelvin).\n */\nfunction decodeTemperature(value, isCelsius = false) {\n    if (value === 0) {\n        return \"Not Available\";\n    } else if (value <= 65530) {\n        const tempK = value * 0.03125; // Kelvin\n        const tempC = tempK - 273.15; // Convert to Celsius\n\n        if (isCelsius) {\n            return parseFloat(tempC.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((tempC * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\n/**\n * Decodes the dead band value from Byte 6.\n * (I haven't seen this used; logic is DGN-specific)\n */\nfunction decodeDeadband(value) {\n    // Spec: Precision = 0.1C, Value range = 0.0 to 25.0C \n    if (value <= 250) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1C\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeFloorHeatMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"FLOOR_HEAT_STATUS\"\n    };\n\n    // Spec defines 7 bytes (0-6) \n    if (data.length < 7) {\n        result.decoding_error = \"Payload too short. Expected 7 bytes for 1FEFCh.\";\n        return result; // Return error object to allow debugging\n    }\n\n    // Byte 0: Instance \n    result.instance = decodeFloorHeatInstance(data[0]);\n    result.raw_instance = data[0];\n\n    // Check if the instance is a valid number.\n    // If it's a string (\"all\", \"Data not available\", etc.), return null to filter.\n    if (typeof result.instance !== 'number') {\n        //node.warn(`Message filtered: Instance is not a valid number (${result.instance}).`);\n        return null;\n    }\n\n    // Byte 1: Bit-packed fields \n    const byte1 = data[1];\n    result.operating_mode = decodeOperatingMode(byte1 & 0x03);         // Bits 0-1\n    result.operating_status = decodeOperatingStatus((byte1 >> 2) & 0x03); // Bits 2-3\n    result.heat_element_status = decodeHeatElementStatus((byte1 >> 4) & 0x03); // Bits 4-5\n    result.schedule_mode = decodeScheduleMode((byte1 >> 6) & 0x03);   // Bits 6-7\n    result.raw_byte1 = byte1;\n\n    // Bytes 2-3: Measured Temperature (uint16, little-endian) \n    const tempRaw = data[2] | (data[3] << 8);\n    result.measured_temperature = decodeTemperature(tempRaw);\n    result.raw_temperature = tempRaw;\n\n    // Bytes 4-5: Set Point (uint16, little-endian) \n    const setpointRaw = data[4] | (data[5] << 8);\n    // Use the same decodeTemperature function for the set point\n    result.set_point = decodeTemperature(setpointRaw);\n    result.raw_setpoint = setpointRaw;\n\n    // Byte 6: Dead band (uint8) \n    result.dead_band_c = decodeDeadband(data[6]);\n    result.raw_dead_band = data[6];\n\n    // Byte 7: Not defined in the spec table \n    if (data.length > 7) {\n        result.raw_byte7 = data[7];\n    }\n\n    // Add convenience fields\n    result.floor_heat_on = result.operating_status === \"On\";\n    result.heating_active = result.heat_element_status === \"On\";\n    result.floor_heat_available = result.instance !== \"Not Available\" &&\n        result.instance !== \"Error\" &&\n        result.instance !== \"Not Supported\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the FLOOR_HEAT_STATUS message\nconst decodedData = decodeFloorHeatMessage(dgn, dataBytes);\n\n// If decodeFloorHeatMessage returned null (e.g., invalid instance),\n// stop the flow here by returning null.\nif (decodedData === null) {\n    return null;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 640,
        "wires": [
            [
                "db73295f937c90a1"
            ]
        ]
    },
    {
        "id": "e06ff8584295e0bd",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 520,
        "wires": []
    },
    {
        "id": "ae9f041c9cd36bb9",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_2",
        "func": "// THERMOSTAT_STATUS_2 Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_STATUS_2 messages per RV-C specification\n// Handles thermostat scheduling and advanced features\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_2 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrentScheduleInstance(value) {\n    // Current schedule instance mapping per RV-C spec\n    if (value === 0) {\n        return \"Sleep\";\n    } else if (value === 1) {\n        return \"Wake\";\n    } else if (value === 2) {\n        return \"Away\";\n    } else if (value === 3) {\n        return \"Return\";\n    } else if (value >= 4 && value <= 249) {\n        return `Additional Instance ${value}`;\n    } else if (value === 250) {\n        return \"Storage\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeScheduleInstances(value) {\n    // Number of schedule instances capacity\n    if (value <= 200) {\n        return value; // Direct count\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeReducedNoiseMode(value) {\n    // Reduced noise mode from bit field\n    if (value === 0) {\n        return \"Disabled\";\n    } else if (value === 1) {\n        return \"Enabled\";\n    }\n    return \"Unknown\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_STATUS_2 parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'current schedule instance') {\n            return decodeCurrentScheduleInstance(value);\n        }\n        if (param.name === 'number of schedule instances') {\n            return decodeScheduleInstances(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit' || param.type === 'bit2' || (param.type.startsWith('uint') && param.bit)) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.name === 'reduced noise mode') {\n                return decodeReducedNoiseMode(bitValue);\n            }\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus2Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_2\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_2 format (typically 4-8 bytes)\n    if (data.length > 0) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Current Schedule Instance\n        if (data.length > 1) {\n            result.current_schedule_instance = decodeCurrentScheduleInstance(data[1]);\n        }\n\n        // Byte 2: Number of Schedule Instances\n        if (data.length > 2) {\n            result.number_of_schedule_instances = decodeScheduleInstances(data[2]);\n        }\n\n        // Byte 3: Reduced Noise Mode (bits 0-1)\n        if (data.length > 3) {\n            if (data[3] === 255) {\n                result.reduced_noise_mode = \"Not Available\";\n            } else if (data[3] === 254) {\n                result.reduced_noise_mode = \"Reserved\";\n            } else if (data[3] === 253) {\n                result.reduced_noise_mode = \"Out of Range\";\n            } else {\n                const noiseBits = decodeBits(data[3], 0, 1);\n                result.reduced_noise_mode = decodeReducedNoiseMode(noiseBits);\n            }\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        if (data.length > 1) result.raw_current_schedule = data[1];\n        if (data.length > 2) result.raw_schedule_count = data[2];\n        if (data.length > 3) result.raw_features_byte = data[3];\n        if (data.length > 4) result.raw_byte_4 = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.scheduling_supported = result.number_of_schedule_instances !== \"Not Available\" &&\n        typeof result.number_of_schedule_instances === 'number' &&\n        result.number_of_schedule_instances > 0;\n\n    result.current_mode = result.current_schedule_instance;\n\n    // Determine if in a standard schedule mode\n    if (typeof result.current_schedule_instance === 'string') {\n        const schedule = result.current_schedule_instance.toLowerCase();\n        result.in_sleep_mode = schedule === \"sleep\";\n        result.in_wake_mode = schedule === \"wake\";\n        result.in_away_mode = schedule === \"away\";\n        result.in_return_mode = schedule === \"return\";\n        result.in_standard_schedule = [\"sleep\", \"wake\", \"away\", \"return\"].includes(schedule);\n    }\n\n    result.quiet_mode_active = result.reduced_noise_mode === \"Enabled\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_2 message\nconst decodedData = decodeThermostatStatus2Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 520,
        "wires": [
            [
                "e06ff8584295e0bd"
            ]
        ]
    },
    {
        "id": "6a02f9f3c2b95dcc",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 760,
        "wires": []
    },
    {
        "id": "6b27f0f99ea11a72",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_STATUS",
        "func": "// GENERATOR_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_STATUS messages per RV-C specification\n// Handles generator operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_STATUS Specific Decoders ===\n\nfunction decodeGeneratorInstance(value) {\n    // Generator instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Generator operating state mapping per RV-C specification (extended)\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Cool Down\",\n        5: \"Prime/Pre-Heat\",\n        6: \"Exercise\",\n        7: \"Test\",\n        8: \"Fault\",\n        9: \"Maintenance Required\",\n        10: \"Remote Start\",\n        11: \"Warm Up\",\n        12: \"Load Test\",\n        13: \"Safety Shutdown\",\n        14: \"Over Temperature\",\n        15: \"Low Oil Pressure\",\n        16: \"Over Speed\",\n        17: \"Under Speed\",\n        18: \"Over Voltage\",\n        19: \"Under Voltage\",\n        20: \"Over Current\",\n        21: \"Under Current\",\n        22: \"Auto Start\",\n        23: \"Manual Start\",\n        24: \"Scheduled Start\",\n        25: \"Emergency Start\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeGeneratorCommand(value) {\n    // Generator command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Exercise\",\n        3: \"Test\",\n        4: \"Prime\",\n        5: \"Pre-Heat\",\n        6: \"Reset Fault\",\n        7: \"Clear Maintenance\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Gasoline\",\n        2: \"Diesel\",\n        3: \"Propane\",\n        4: \"Natural Gas\",\n        5: \"Dual Fuel\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeEngineRPM(value) {\n    // Engine RPM (4 RPM resolution)\n    if (value <= 16000) {\n        return value * 4; // 4 RPM per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeRunTime(value) {\n    // Run time in hours (0.1 hour resolution)\n    if (value <= 655300) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1 hour per step\n    } else if (value === 4294967293) {\n        return \"Out of Range\";\n    } else if (value === 4294967294) {\n        return \"Reserved\";\n    } else if (value === 4294967295) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40C\n    if (value <= 210) {\n        return value - 40; // -40C to +170C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFuelLevel(value) {\n    // Fuel level as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOilPressure(value) {\n    // Oil pressure in kPa (0.5 kPa resolution)\n    if (value <= 500) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5 kPa per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 1.2).toFixed(1)); // 1.2V per step, 0-300V range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 0.4).toFixed(1)); // 0.4A per step, 0-100A range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultStatus(value) {\n    // Fault status bit field\n    const faults = [];\n\n    if (value & 0x01) faults.push(\"Low Oil Pressure\");\n    if (value & 0x02) faults.push(\"High Temperature\");\n    if (value & 0x04) faults.push(\"Low Fuel\");\n    if (value & 0x08) faults.push(\"Overcurrent\");\n    if (value & 0x10) faults.push(\"Overvoltage\");\n    if (value & 0x20) faults.push(\"Undervoltage\");\n    if (value & 0x40) faults.push(\"Service Required\");\n    if (value & 0x80) faults.push(\"System Fault\");\n\n    return faults.length > 0 ? faults.join(\", \") : \"No Faults\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific GENERATOR_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeGeneratorInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeGeneratorCommand(value);\n        }\n        if (param.name === 'fuel type') {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'fuel level') {\n            return decodeFuelLevel(value);\n        }\n        if (param.name === 'oil pressure') {\n            return decodeOilPressure(value);\n        }\n        if (param.name === 'fault status' || param.name === 'faults') {\n            return decodeFaultStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'engine rpm' || param.name === 'rpm') {\n            return decodeEngineRPM(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'run time' || param.name === 'runtime') {\n            return decodeRunTime(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_STATUS\"\n    };\n\n    // Decode based on GENERATOR_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Bytes 3-4: Engine RPM (16-bit, little-endian)\n        const engineRPM = data[3] | (data[4] << 8);\n        result.engine_rpm = decodeEngineRPM(engineRPM);\n\n        // Byte 5: AC Voltage (single byte for generators)\n        result.ac_voltage = decodeACVoltage(data[5]);\n\n        // Byte 6: AC Current (single byte approximation)\n        result.ac_current = decodeACCurrent(data[6]);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_engine_rpm_bytes = [data[3], data[4]];\n        result.raw_ac_voltage = data[5];\n        result.raw_ac_current = data[6];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.generator_running = state === \"running\";\n        result.generator_available = ![\"fault\", \"maintenance required\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_exercising = state === \"exercise\";\n        result.needs_maintenance = state === \"maintenance required\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    // Engine status\n    result.engine_running = typeof result.engine_rpm === 'number' && result.engine_rpm > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_STATUS message\nconst decodedData = decodeGeneratorMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 760,
        "wires": [
            [
                "6a02f9f3c2b95dcc"
            ]
        ]
    },
    {
        "id": "f82e60f4adb5e60b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_AC_STATUS",
        "func": "// GENERATOR_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC output status for generators (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_AC_STATUS Specific Decoders ===\n\nfunction decodeGeneratorACInstance(value) {\n    // Generator AC instance interpretation per RV-C spec\n    // For generators, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active = result.rms_voltage !== \"Not Available\" &&\n                             typeof result.rms_voltage === 'number' &&\n                             result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.generator_loaded = result.rms_current !== \"Not Available\" &&\n                             typeof result.rms_current === 'number' &&\n                             result.rms_current > 0.1; // Some current flow\n\n    result.generator_ac_available = result.ac_output_active && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_AC_STATUS message\nconst decodedData = decodeGeneratorACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 820,
        "wires": [
            [
                "6b903512de37f1ad"
            ]
        ]
    },
    {
        "id": "6b903512de37f1ad",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 820,
        "wires": []
    },
    {
        "id": "bacdea9854675b01",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_AC_STATUS",
        "func": "// ATS_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes ATS_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC input/output status for automatic transfer switches (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_AC_STATUS Specific Decoders ===\n\nfunction decodeATSACInstance(value) {\n    // ATS AC instance interpretation per RV-C spec\n    // For ATS, this typically indicates the AC input/output line being monitored\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7 - ATS-specific fault interpretation\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeATSACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeATSACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields for ATS operations\n    result.ac_source_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.ats_load_present = result.rms_current !== \"Not Available\" &&\n        typeof result.rms_current === 'number' &&\n        result.rms_current > 0.1; // Some current flow\n\n    result.ac_source_qualified = result.ac_source_available &&\n        !result.any_fault &&\n        typeof result.frequency === 'number' &&\n        result.frequency >= 58 && result.frequency <= 62; // Reasonable frequency range\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_AC_STATUS message\nconst decodedData = decodeATSACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 940,
        "wires": [
            [
                "f80a9416a8e18e46"
            ]
        ]
    },
    {
        "id": "f80a9416a8e18e46",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 940,
        "wires": []
    },
    {
        "id": "f171dcbe8b5d2e05",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_STATUS",
        "func": "// CHARGER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes CHARGER_STATUS messages per RV-C specification\n// Handles battery charger operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_STATUS Specific Decoders ===\n\nfunction decodeChargerInstance(value) {\n    // Charger instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Charger operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"Bulk\",\n        2: \"Absorption\",\n        3: \"Overcharge\",\n        4: \"Equalize\",\n        5: \"Float\",\n        6: \"No Charge\",\n        7: \"Constant Voltage\",\n        8: \"Constant Current\",\n        9: \"Fault\",\n        10: \"Unavailable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeChargerCommand(value) {\n    // Charger command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Bulk\",\n        3: \"Absorption\",\n        4: \"Overcharge\",\n        5: \"Equalize\",\n        6: \"Float\",\n        7: \"Auto\",\n        8: \"Reset Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeChargerType(value) {\n    // Charger type mapping\n    const chargerTypes = {\n        0: \"Unknown\",\n        1: \"AC-DC Converter\",\n        2: \"Solar Controller\",\n        3: \"Wind Generator\",\n        4: \"Alternator\",\n        5: \"DC-DC Converter\",\n        6: \"Fuel Cell\",\n        7: \"Shore Power\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return chargerTypes[value] || `Unknown Type ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40C to +170C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeEfficiency(value) {\n    // Efficiency as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Charging Active\");\n    if (value & 0x02) statusBits.push(\"AC Input Available\");\n    if (value & 0x04) statusBits.push(\"Battery Connected\");\n    if (value & 0x08) statusBits.push(\"Equalize Mode\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Reverse Polarity\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overvoltage Input\",\n        2: \"Undervoltage Input\",\n        3: \"Overtemperature\",\n        4: \"Fan Failure\",\n        5: \"Communication Error\",\n        6: \"Battery Fault\",\n        7: \"Ground Fault\",\n        8: \"Current Limit\",\n        9: \"Internal Fault\",\n        10: \"Reverse Polarity\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific CHARGER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeChargerInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeChargerCommand(value);\n        }\n        if (param.name === 'charger type' || param.name === 'type') {\n            return decodeChargerType(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'efficiency') {\n            return decodeEfficiency(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeChargerMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_STATUS\"\n    };\n\n    // Decode based on CHARGER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Charger Type\n        result.charger_type = decodeChargerType(data[2]);\n\n        // Bytes 3-4: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[3] | (data[4] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Bytes 5-6: DC Current (16-bit, little-endian)\n        const dcCurrent = data[5] | (data[6] << 8);\n        result.dc_current = decodeDCCurrent(dcCurrent);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_charger_type = data[2];\n        result.raw_dc_voltage_bytes = [data[3], data[4]];\n        result.raw_dc_current_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.charger_active = ![\"off\", \"no charge\", \"fault\", \"unavailable\", \"error\"].includes(state);\n        result.charger_charging = [\"bulk\", \"absorption\", \"float\", \"equalize\"].includes(state);\n        result.charger_available = ![\"fault\", \"unavailable\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.dc_voltage === 'number' && typeof result.dc_current === 'number') {\n        result.dc_power = parseFloat((result.dc_voltage * result.dc_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_STATUS message\nconst decodedData = decodeChargerMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1000,
        "wires": [
            [
                "78904d457471d1b2"
            ]
        ]
    },
    {
        "id": "78904d457471d1b2",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1000,
        "wires": []
    },
    {
        "id": "b91d72f6d383c0d6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_DC_STATUS",
        "func": "// INVERTER_DC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_DC_STATUS messages per RV-C specification\n// Handles DC input status for inverters (DC battery connection monitoring)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_DC_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance interpretation per RV-C spec\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCInstance(value) {\n    // DC Instance mapping per RV-C specification\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC Voltage in volts (0.05V resolution)\n    if (value <= 64000) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    // Handle signed 32-bit value\n    let signedValue = value;\n    if (value > 2147483647) {\n        signedValue = value - 4294967296; // Convert from unsigned to signed\n    }\n\n    if (Math.abs(signedValue) <= MAX_VALID) {\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40C\n    if (value <= 210) {\n        return value - 40; // -40C to +170C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeInverterState(value) {\n    // Inverter operational state\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Sleep Mode\",\n        5: \"Search Mode\",\n        6: \"Standby\",\n        7: \"Fault\",\n        8: \"Battery Low\",\n        9: \"Overload\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\nfunction decodeUint32(data, startByte) {\n    // Decode 32-bit value (little-endian)\n    if (!data || startByte + 3 >= data.length) {\n        return 4294967295; // Not available\n    }\n    return data[startByte] |\n           (data[startByte + 1] << 8) |\n           (data[startByte + 2] << 16) |\n           (data[startByte + 3] << 24);\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterDCMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_DC_STATUS\"\n    };\n\n    // Decode INVERTER_DC_STATUS message (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Inverter Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: DC Instance (battery bank)\n        result.dc_source_instance = decodeDCInstance(data[1]);\n\n        // Bytes 2-3: DC Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 2);\n        result.dc_voltage = decodeDCVoltage(voltageRaw);\n\n        // Bytes 4-7: DC Current (uint32, little-endian, signed)\n        const currentRaw = decodeUint32(data, 4);\n        result.dc_current = decodeDCCurrent(currentRaw);\n\n        // Additional bytes if available for extended status\n        if (data.length > 8) {\n            // Byte 8: Inverter State (if available)\n            result.inverter_state = decodeInverterState(data[8]);\n        }\n\n        if (data.length > 9) {\n            // Byte 9: Temperature (if available)\n            result.temperature = decodeTemperature(data[9]);\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n    }\n\n    // Add convenience fields\n    result.dc_input_available = result.dc_voltage !== \"Not Available\" &&\n                               typeof result.dc_voltage === 'number' &&\n                               result.dc_voltage > 10; // Reasonable DC voltage threshold\n\n    result.inverter_drawing_power = result.dc_current !== \"Not Available\" &&\n                                   typeof result.dc_current === 'number' &&\n                                   Math.abs(result.dc_current) > 0.5; // Some current flow\n\n    result.inverter_supplying_power = result.dc_current !== \"Not Available\" &&\n                                     typeof result.dc_current === 'number' &&\n                                     result.dc_current < -0.5; // Negative current = supplying power\n\n    if (result.inverter_state !== undefined) {\n        const state = result.inverter_state.toString().toLowerCase();\n        result.inverter_operational = [\"running\", \"search mode\", \"standby\"].includes(state);\n        result.inverter_faulted = [\"fault\", \"battery low\", \"overload\"].includes(state);\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_DC_STATUS message\nconst decodedData = decodeInverterDCMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1240,
        "wires": [
            [
                "04bc7637ee7139d8"
            ]
        ]
    },
    {
        "id": "04bc7637ee7139d8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_DC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 1240,
        "wires": []
    },
    {
        "id": "2e5425d73a166c9b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode TANK_STATUS",
        "func": "// TANK_STATUS Decoder (Updated with Flat Output) - Complete and Accurate RV-C Implementation\n// Decodes TANK_STATUS messages (1FFB7) per RV-C specification\n// Handles all RV tank types: Fresh Water, Gray Water, Black Water, LPG\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === TANK_STATUS Specific Decoders ===\n\nfunction decodeTankInstance(value) {\n    // Tank instance mapping per RV-C specification\n    const tankTypes = {\n        0: \"Fresh Water\",\n        1: \"Gray Water\",\n        2: \"Black Water\",\n        3: \"LPG\",\n        4: \"Fuel\",\n        5: \"Hot Water\",\n        6: \"Hydraulic Fluid\",\n        7: \"Live Well\",\n        8: \"Ballast\",\n        9: \"Oil\",\n        10: \"Coolant\",\n        11: \"Diesel Exhaust Fluid\",\n        12: \"Compressed Air\",\n        13: \"Fresh Water 2\",\n        14: \"Gray Water 2\",\n        15: \"Black Water 2\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return tankTypes[value] || `Unknown Tank ${value}`;\n}\n\nfunction decodeTankLevel(value) {\n    // Tank level as raw sensor reading (not percentage)\n    // Percentage calculated as: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw sensor reading\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankResolution(value) {\n    // Tank resolution as raw sensor resolution value\n    // Used in calculation: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw resolution value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40C\n    if (value <= 210) {\n        return value - 40; // -40C to +170C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankStatus(value) {\n    // Tank status bit field decoding\n    const statusBits = {\n        0: \"Tank OK\",\n        1: \"Tank Low\",\n        2: \"Tank Full\",\n        3: \"Tank Overfilled\",\n        4: \"Sensor Fault\",\n        5: \"Tank Disconnected\",\n        6: \"Reserved\",\n        7: \"Reserved\"\n    };\n\n    const activeStatuses = [];\n    for (let bit = 0; bit < 8; bit++) {\n        if (value & (1 << bit)) {\n            activeStatuses.push(statusBits[bit]);\n        }\n    }\n\n    return activeStatuses.length > 0 ? activeStatuses.join(\", \") : \"Tank OK\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    const value = data[byte];\n\n    if (param.type === 'uint8') {\n        // Handle specific TANK_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeTankInstance(value);\n        }\n        if (param.name === 'relative level' || param.name === 'level') {\n            return decodeTankLevel(value);\n        }\n        if (param.name === 'resolution') {\n            return decodeTankResolution(value);\n        }\n        if (param.name === 'temperature') {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'status' || param.name === 'tank status') {\n            return decodeTankStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeTankStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"TANK_STATUS\"\n    };\n\n    // Decode based on TANK_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Tank Instance\n        result.instance = data[0];\n        result.instance_name = decodeTankInstance(data[0]);\n\n        // Byte 1: Relative Level (0-200)\n        result.relative_level = decodeTankLevel(data[1]);\n\n        // Byte 2: Resolution (tank capacity steps)\n        result.resolution = decodeTankResolution(data[2]);\n\n        // Byte 3: Temperature\n        result.temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Tank Status (bit field)\n        result.status = decodeTankStatus(data[4]);\n\n        // Bytes 5-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_relative_level = data[1];\n        result.raw_resolution = data[2];\n        result.raw_temperature = data[3];\n        result.raw_status = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields for easier consumption\n    // Calculate tank percentage using RV-C formula: (relative_level / resolution) * 100\n    if (result.relative_level !== undefined && result.resolution !== undefined &&\n        typeof result.relative_level === 'number' && typeof result.resolution === 'number' &&\n        result.resolution > 0) {\n        result.level_percentage = Math.round((result.relative_level / result.resolution) * 100);\n    } else if (result.relative_level !== undefined && typeof result.relative_level === 'number') {\n        // Fallback if resolution is not available (direct percentage)\n        result.level_percentage = Math.round(result.relative_level * 0.5); // 0.5% per step\n    }\n\n    if (result.instance !== undefined) {\n        // Map numeric instance to single-word tank type\n        const tankTypeMap = {\n            0: \"fresh\",\n            1: \"gray\",\n            2: \"black\",\n            3: \"lpg\",\n            4: \"fuel\",\n            5: \"hot\",\n            6: \"hydraulic\",\n            7: \"livewell\",\n            8: \"ballast\",\n            9: \"oil\",\n            10: \"coolant\",\n            11: \"def\",\n            12: \"air\",\n            13: \"fresh2\",\n            14: \"gray2\",\n            15: \"black2\",\n            251: \"error\",\n            252: \"notsupported\",\n            253: \"outofrange\",\n            254: \"reserved\",\n            255: \"notavailable\"\n        };\n\n        result.tank_type = tankTypeMap[result.instance] || \"other\";\n    }\n\n    // Tank level status\n    if (typeof result.level_percentage === 'number') {\n        result.tank_empty = result.level_percentage <= 5;\n        result.tank_low = result.level_percentage <= 25;\n        result.tank_full = result.level_percentage >= 95;\n        result.tank_level_available = true;\n    } else {\n        result.tank_level_available = false;\n    }\n\n    // Validate instance - Tank spec defines instances 0-19 for tank types\n    // RV-C special values 251-255 indicate error/unavailable status\n    const validInstances = [0, 1, 2, 3, 16, 17, 18, 19];\n    const isValidRange = result.instance <= 19 || (result.instance >= 16 && result.instance <= 19);\n\n    if (result.instance > 250 || (!isValidRange && result.instance > 19)) {\n        node.warn(`Invalid tank instance: ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    // Temperature status\n    result.temperature_available = typeof result.temperature === 'number';\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the TANK_STATUS message\nconst decodedData = decodeTankStatusMessage(dgn, dataBytes);\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 340,
        "wires": [
            [
                "45ae070eafc9a732"
            ]
        ]
    },
    {
        "id": "e5d61c5724c6ed1b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_DEMAND_STATUS",
        "func": "// GENERATOR_DEMAND_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_DEMAND_STATUS messages per RV-C specification\n// Handles automatic generator start (AGS) demand status and control flags\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_DEMAND_STATUS Specific Decoders ===\n\nfunction decodeDemandStatus(value) {\n    // Decode demand status bits (2-bit fields)\n    const states = {\n        0: \"No Demand\",\n        1: \"Demand Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeOverrideStatus(value) {\n    // Decode override/activity status bits (2-bit fields)\n    const states = {\n        0: \"Normal Operation\",\n        1: \"Override/Activity Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeTime(hour, minute) {\n    // Convert hour and minute to readable time format\n    if (hour === 255 || minute === 255) {\n        return \"Not Available\";\n    }\n    if (hour > 23 || minute > 59) {\n        return \"Invalid Time\";\n    }\n\n    // Format as 24-hour time\n    const hourStr = hour.toString().padStart(2, '0');\n    const minStr = minute.toString().padStart(2, '0');\n    return `${hourStr}:${minStr}`;\n}\n\nfunction decodeMinimumCycleTime(value) {\n    // Minimum cycle time in minutes\n    if (value === 0) {\n        return \"No Minimum\";\n    } else if (value <= 250) {\n        return `${value} minutes`;\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorDemandMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_DEMAND_STATUS\"\n    };\n\n    if (data.length >= 7) {\n        // Byte 0: Demand status bits\n        const byte0 = data[0];\n        result.generator_demand = decodeDemandStatus(decodeBits(byte0, 0, 1));\n        result.internal_demand = decodeDemandStatus(decodeBits(byte0, 2, 3));\n        result.network_demand = decodeDemandStatus(decodeBits(byte0, 4, 5));\n        result.external_activity_detected = decodeOverrideStatus(decodeBits(byte0, 6, 7));\n\n        // Byte 1: Override and control status bits\n        const byte1 = data[1];\n        result.manual_override_detected = decodeOverrideStatus(decodeBits(byte1, 0, 1));\n        result.quiet_time = decodeOverrideStatus(decodeBits(byte1, 2, 3));\n        result.quiet_time_override = decodeOverrideStatus(decodeBits(byte1, 4, 5));\n        result.generator_lock = decodeOverrideStatus(decodeBits(byte1, 6, 7));\n\n        // Bytes 2-3: Quiet time begin (DEPRECATED but still decoded)\n        result.quiet_time_begin = decodeTime(data[2], data[3]);\n\n        // Bytes 4-5: Quiet time end (DEPRECATED but still decoded)\n        if (data.length >= 6) {\n            result.quiet_time_end = decodeTime(data[4], data[5]);\n        }\n\n        // Byte 6: Minimum cycle time\n        if (data.length >= 7) {\n            result.minimum_cycle_time = decodeMinimumCycleTime(data[6]);\n        }\n\n        // Raw values for debugging\n        result.raw_demand_byte = byte0;\n        result.raw_control_byte = byte1;\n    }\n\n    // Add convenience fields for easier automation logic\n    result.generator_should_run = result.generator_demand === \"Demand Active\" ||\n        result.internal_demand === \"Demand Active\" ||\n        result.network_demand === \"Demand Active\";\n\n    result.automatic_start_allowed = result.external_activity_detected !== \"Override/Activity Active\" &&\n        result.generator_lock !== \"Override/Activity Active\";\n\n    result.quiet_time_active = result.quiet_time === \"Override/Activity Active\" &&\n        result.quiet_time_override !== \"Override/Activity Active\";\n\n    result.manual_control_active = result.manual_override_detected === \"Override/Activity Active\";\n\n    // Overall status assessment\n    result.demand_summary = result.generator_should_run ? \"Generator Requested\" : \"No Generator Demand\";\n\n    if (result.generator_lock === \"Override/Activity Active\") {\n        result.demand_summary = \"Generator Locked\";\n    } else if (result.external_activity_detected === \"Override/Activity Active\") {\n        result.demand_summary = \"External Activity Blocking\";\n    } else if (result.quiet_time_active) {\n        result.demand_summary = \"Quiet Time Active\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_DEMAND_STATUS message\nconst decodedData = decodeGeneratorDemandMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 880,
        "wires": [
            [
                "51e87f869d6aa2c5"
            ]
        ]
    },
    {
        "id": "51e87f869d6aa2c5",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_DEMAND_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 880,
        "wires": []
    },
    {
        "id": "cb64b7a9a87f03cc",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_STATUS",
        "func": "// INVERTER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_STATUS messages per RV-C specification\n// Handles inverter operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Inverter operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Inverting\",\n        3: \"Charging\",\n        4: \"Passthrough\",\n        5: \"Standby\",\n        6: \"Fault\",\n        7: \"Equalize\",\n        8: \"Bulk Charge\",\n        9: \"Absorption\",\n        10: \"Float\",\n        11: \"Search Mode\",\n        12: \"Sleep Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeInverterCommand(value) {\n    // Inverter command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Invert Only\",\n        3: \"Charge Only\",\n        4: \"Auto\",\n        5: \"Search Mode\",\n        6: \"Reset Fault\",\n        7: \"Equalize\",\n        8: \"Shore Power Priority\",\n        9: \"Battery Priority\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    if (value <= MAX_VALID) {\n        // Handle signed values for charging (positive) vs discharging (negative)\n        const signedValue = value > 2147483647 ? value - 4294967296 : value;\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency in Hz (0.1Hz resolution)\n    if (value <= 700) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1Hz per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40C to +170C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"AC Output On\");\n    if (value & 0x02) statusBits.push(\"Charging Active\");\n    if (value & 0x04) statusBits.push(\"AC Input Available\");\n    if (value & 0x08) statusBits.push(\"Overload\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Low Battery\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overload\",\n        2: \"Overvoltage Input\",\n        3: \"Undervoltage Input\",\n        4: \"Overvoltage Output\",\n        5: \"Undervoltage Output\",\n        6: \"Overtemperature\",\n        7: \"Fan Failure\",\n        8: \"Ground Fault\",\n        9: \"DC Ripple\",\n        10: \"AC Frequency Error\",\n        11: \"Internal Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific INVERTER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeInverterInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeInverterCommand(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name === 'frequency') {\n            return decodeFrequency(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_STATUS\"\n    };\n\n    // Decode based on INVERTER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: AC Voltage\n        result.ac_voltage = decodeACVoltage(data[2]);\n\n        // Bytes 3-4: AC Current (16-bit, little-endian)\n        const acCurrent = data[3] | (data[4] << 8);\n        result.ac_current = decodeACCurrent(acCurrent);\n\n        // Bytes 5-6: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[5] | (data[6] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Byte 7: Temperature or Frequency\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_ac_voltage = data[2];\n        result.raw_ac_current_bytes = [data[3], data[4]];\n        result.raw_dc_voltage_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.inverter_active = state === \"inverting\";\n        result.charger_active = state === \"charging\";\n        result.inverter_available = ![\"fault\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_passthrough = state === \"passthrough\";\n        result.is_in_standby = state === \"standby\" || state === \"search mode\" || state === \"sleep mode\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_STATUS message\nconst decodedData = decodeInverterMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1120,
        "wires": [
            [
                "9f3a9fd8a4506e74"
            ]
        ]
    },
    {
        "id": "9f3a9fd8a4506e74",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1120,
        "wires": []
    },
    {
        "id": "010c5119a7e833b2",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_SOURCE_STATUS_1",
        "func": "// Corrected RV-C DC_SOURCE_STATUS Decoder for Node-RED\n// Decodes DC_SOURCE_STATUS messages 1, 2, and 3 based on their DGN.\n// Input: msg.payload with {dgn, dataPayload}\n// Output: msg.payload with decoded fields\n\n// === Helper Functions (Largely from your original code) ===\n\n// Decodes a bitfield from within a byte\nfunction decodeBits(byte, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (byte & mask) >> startBit;\n}\n\n// Decodes the DC Instance (Byte 0)\nfunction decodeDCInstance(value) {\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\"\n    };\n    // Per the spec, 5-250 are valid \"Other\" instances \n    if (value >= 5 && value <= 250) {\n        return `Other DC Instance ${value}`;\n    }\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\n// Decodes the Device Priority (Byte 1)\nfunction decodeDevicePriority(value) {\n    const priorities = {\n        20: \"Voltmeter\",\n        40: \"Voltmeter/Ammeter\",\n        60: \"Inverter\",\n        80: \"Charger\",\n        100: \"Inverter/Charger\",\n        120: \"Battery SOC/BMS Device\"\n    };\n    return priorities[value] || `Unknown Priority ${value}`;\n}\n\n// Decodes DC Voltage (uint16)\nfunction decodeDCVoltage(value) {\n    // NOTE: This logic is based on your original function, assuming a 0.05V resolution\n    // from the unprovided \"Table 5.3\" referenced in the spec.\n    if (value <= 64000) return parseFloat((value * 0.05).toFixed(2));\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes DC Current (32-bit signed)\nfunction decodeDCCurrent32bit(value) {\n    // NOTE: This logic is based on your original function, assuming a 0.05A resolution\n    // from the unprovided \"Table 5.3\" referenced in the spec.\n    if (value === 4294967295) return \"Not Available\";\n\n    // Convert 32-bit unsigned to signed\n    if (value > 2147483647) {\n        value = value - 4294967296;\n    }\n\n    // The spec does not define the range for current, using your original logic.\n    return parseFloat((value * 0.05).toFixed(2));\n}\n\n// Decodes Temperature (uint16)\nfunction decodeTemperature(value) {\n    // This is for the uint16 version in STATUS_2 [cite: 72]\n    // The spec does not define the scaling for this field, assuming offset of -40 C.\n    if (value <= 64000) return (value * 0.03125) - 273; // Example scaling\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes State of Charge / Health / Relative Capacity (uint8)\nfunction decodePercentage(value) {\n    // 0.5% per step from your original function.\n    if (value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\n\n\n// === DGN-Specific Decoders ===\n\nfunction decodeDCSourceStatus1(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_1\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_1\" };\n\n    result.instance = data[0];\n    result.instance_name = decodeDCInstance(data[0]);\n\n    // Validate instance - DC Source valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(`Invalid DC source instance (STATUS_1): ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const voltage = (data[3] << 8) | data[2];\n    result.dc_voltage_V = decodeDCVoltage(voltage);\n\n    const current = (data[7] << 24) | (data[6] << 16) | (data[5] << 8) | data[4];\n    result.dc_current_A = decodeDCCurrent32bit(current);\n\n    return result;\n}\n\nfunction decodeDCSourceStatus2(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_2\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_2\" };\n\n    result.instance = data[0];\n    result.instance_name = decodeDCInstance(data[0]);\n\n    // Validate instance - DC Source valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(`Invalid DC source instance (STATUS_2): ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const temp = (data[3] << 8) | data[2];\n    result.source_temp_C = decodeTemperature(temp);\n\n    result.state_of_charge_percent = decodePercentage(data[4]);\n\n    const time = (data[6] << 8) | data[5];\n    result.time_remaining_min = (time <= 64000) ? time : \"Not Available\";\n\n    const interp = decodeBits(data[7], 0, 1);\n    const interpMap = { 0: \"Time to Empty\", 1: \"Time to Full\", 3: \"Not Available\" };\n    result.time_remaining_interpretation = interpMap[interp] || \"Reserved\";\n\n    return result;\n}\n\nfunction decodeDCSourceStatus3(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_3\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_3\" };\n\n    result.instance = data[0];\n    result.instance_name = decodeDCInstance(data[0]);\n\n    // Validate instance - DC Source valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(`Invalid DC source instance (STATUS_3): ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    result.device_priority = decodeDevicePriority(data[1]);\n    result.state_of_health_percent = decodePercentage(data[2]);\n\n    const cap = (data[4] << 8) | data[3];\n    result.capacity_remaining_Ah = (cap <= 64000) ? cap : \"Not Available\";\n\n    result.relative_capacity_percent = decodePercentage(data[5]);\n\n    const ripple = (data[7] << 8) | data[6];\n    result.ac_rms_ripple_mV = (ripple <= 65530) ? ripple : \"Not Available\";\n\n    return result;\n}\n\n// === Main Router Function ===\n\nfunction decodeDCSourceMessage(dgn, data) {\n    switch (dgn) {\n        case '1FFFD':\n            return decodeDCSourceStatus1(data);\n        case '1FFFC':\n            return decodeDCSourceStatus2(data);\n        case '1FFFB':\n            return decodeDCSourceStatus3(data);\n        default:\n            return {\n                dgn: dgn,\n                error: `Unsupported DGN for DC_SOURCE_STATUS decoding.`\n            };\n    }\n}\n\n// === Main Node-RED Logic ===\n\nconst incomingPayload = msg.payload;\nif (!incomingPayload || !incomingPayload.dgn || !incomingPayload.dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Convert hex payload to byte array\nconst dataBytes = [];\nfor (let i = 0; i < incomingPayload.dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(incomingPayload.dataPayload.substring(i, i + 2), 16));\n}\n\n// Decode the message by routing to the correct function based on DGN\nconst decodedData = decodeDCSourceMessage(incomingPayload.dgn, dataBytes);\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Merge the original payload and the newly decoded data\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up by removing the raw hex payload\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 400,
        "wires": [
            [
                "bff245b2ca47ef79"
            ]
        ]
    },
    {
        "id": "c38d48059f463772",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AC_LOAD_STATUS",
        "func": "// AC_LOAD_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes AC_LOAD_STATUS messages per RV-C specification\n// Handles generic AC circuit loads with load management capabilities\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === AC_LOAD_STATUS Specific Decoders ===\n\nfunction decodeLoadInstance(value) {\n    // Load instance interpretation per RV-C spec\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << (i - 1); // Group 1 = bit 0, Group 2 = bit 1, etc.\n        if (!(value & groupBit)) { // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingLevel(value) {\n    // Operating status/level (0-100% for dimmable, or special values)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 252) {\n        return \"Load Delay Active\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return modes[value] || \"Unknown\";\n}\n\nfunction decodeVariableCapability(value) {\n    // Variable level capability (2-bit field)\n    const capabilities = {\n        0: \"Not Variable (Not Dimmable)\",\n        1: \"Variable (Dimmable)\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return capabilities[value] || \"Unknown\";\n}\n\nfunction decodePriority(value) {\n    // Load priority (4-bit field)\n    if (value <= 13) {\n        return `Priority ${value} (${value === 0 ? \"Highest\" : value === 13 ? \"Lowest\" : \"Medium\"})`;\n    } else if (value === 14) {\n        return \"Error\";\n    } else if (value === 15) {\n        return \"No Data\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDelay(value) {\n    // Delay before load activation\n    if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrent(value) {\n    // Current in amperes per Table 5.3 (0.05A resolution for small values)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeACLoadMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AC_LOAD_STATUS\"\n    };\n\n    // Determine if this is AC_LOAD_STATUS or AC_LOAD_STATUS_2\n    const dgnHex = dgn.toUpperCase();\n\n    if (dgnHex === \"1FFBF\") {\n        // AC_LOAD_STATUS (standard status)\n        result.status_type = \"AC_LOAD_STATUS\";\n\n        if (data.length >= 8) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Group membership bitmap\n            result.group_membership = decodeGroupBitmap(data[1]);\n\n            // Byte 2: Operating status (level)\n            result.operating_level = decodeOperatingLevel(data[2]);\n\n            // Byte 3: Mode, capability, and priority bits\n            const byte3 = data[3];\n            result.operating_mode = decodeOperatingMode(decodeBits(byte3, 0, 1));\n            result.variable_capability = decodeVariableCapability(decodeBits(byte3, 2, 3));\n            result.load_priority = decodePriority(decodeBits(byte3, 4, 7));\n\n            // Byte 4: Delay\n            result.activation_delay = decodeDelay(data[4]);\n\n            // Byte 5: Demanded current\n            result.demanded_current = decodeCurrent(data[5]);\n\n            // Bytes 6-7: Present current (uint16, little-endian)\n            const presentCurrentRaw = decodeUint16(data, 6);\n            result.present_current = decodeCurrent(Math.min(presentCurrentRaw, 255)); // Scale down if needed\n\n            // Raw values for debugging\n            result.raw_present_current = presentCurrentRaw;\n            result.raw_control_byte = byte3;\n        }\n\n    } else if (dgnHex === \"1FEDD\") {\n        // AC_LOAD_STATUS_2 (extended status)\n        result.status_type = \"AC_LOAD_STATUS_2\";\n\n        if (data.length >= 4) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Status bits\n            const byte1 = data[1];\n            const lockStatus = decodeBits(byte1, 0, 1);\n            const overcurrentStatus = decodeBits(byte1, 2, 3);\n            const overrideStatus = decodeBits(byte1, 4, 5);\n            const enableStatus = decodeBits(byte1, 6, 7);\n\n            const statusStates = [\"Normal\", \"Active/Fault\", \"Reserved\", \"Not Supported\"];\n            result.lock_status = lockStatus === 0 ? \"Unlocked\" : statusStates[lockStatus] || \"Unknown\";\n            result.overcurrent_status = statusStates[overcurrentStatus] || \"Unknown\";\n            result.override_status = statusStates[overrideStatus] || \"Unknown\";\n            result.enable_status = enableStatus === 0 ? \"Enabled\" : statusStates[enableStatus] || \"Unknown\";\n\n            // Byte 2: Last command\n            result.last_command = data[2]; // Command code - would need command lookup table for name\n\n            // Byte 3: Interlock status\n            if (data.length > 3) {\n                const interlockStatus = decodeBits(data[3], 0, 1);\n                result.interlock_status = interlockStatus === 0 ? \"Not Active\" :\n                    interlockStatus === 1 ? \"Active\" : \"Not Supported\";\n            }\n\n            // Raw values for debugging\n            result.raw_status_byte = byte1;\n        }\n    }\n\n    // Add convenience fields\n    if (result.operating_level !== undefined) {\n        result.load_active = typeof result.operating_level === 'number' && result.operating_level > 0;\n    }\n\n    if (result.variable_capability !== undefined) {\n        result.is_dimmable = result.variable_capability.includes(\"Dimmable\");\n    }\n\n    if (result.operating_mode !== undefined) {\n        result.can_auto_control = result.operating_mode === \"Automatic\";\n    }\n\n    // Load health assessment\n    result.load_healthy = true;\n    if (result.overcurrent_status === \"Active/Fault\") result.load_healthy = false;\n    if (result.enable_status === \"Active/Fault\") result.load_healthy = false;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the AC_LOAD_STATUS message\nconst decodedData = decodeACLoadMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1300,
        "wires": [
            [
                "77e3defd386ce8a8"
            ]
        ]
    },
    {
        "id": "77e3defd386ce8a8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AC_LOAD_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1300,
        "wires": []
    },
    {
        "id": "a0357de00b26b002",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_STATUS",
        "func": "// ATS_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes ATS_STATUS messages per RV-C specification\n// Handles automatic transfer switch status and source selection\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_STATUS Specific Decoders ===\n\nfunction decodeATSInstance(value) {\n    // ATS instance interpretation per RV-C spec\n    if (value >= 1 && value <= 6) {\n        return value; // Valid instances\n    } else if (value === 0 || value >= 7) {\n        return \"Invalid Instance\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSourceInUse(value) {\n    // Source currently in use\n    if (value === 0) {\n        return \"Primary\";\n    } else if (value >= 1 && value <= 6) {\n        return `Source ${value}`;\n    } else if (value === 253) {\n        return \"No Source Active\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid Source\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return modes[value] || \"Unknown\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeATSMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_STATUS\"\n    };\n\n    if (data.length >= 3) {\n        // Byte 0: ATS Instance\n        result.instance = decodeATSInstance(data[0]);\n\n        // Byte 1: Source in use\n        result.source_in_use = decodeSourceInUse(data[1]);\n\n        // Byte 2: Operating mode (bits 0-1)\n        const byte2 = data[2];\n        result.operating_mode = decodeOperatingMode(decodeBits(byte2, 0, 1));\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_source = data[1];\n        result.raw_mode_byte = byte2;\n    }\n\n    // Add convenience fields\n    result.has_active_source = result.source_in_use !== \"No Source Active\" &&\n        result.source_in_use !== \"Not Available\" &&\n        !result.source_in_use.includes(\"Invalid\");\n\n    result.is_automatic_mode = result.operating_mode === \"Automatic\";\n    result.is_manual_mode = result.operating_mode === \"Manual\";\n\n    result.using_primary_source = result.source_in_use === \"Primary\";\n\n    // Overall status assessment\n    if (result.has_active_source) {\n        result.transfer_switch_status = `Active on ${result.source_in_use}`;\n    } else {\n        result.transfer_switch_status = \"No Active Source\";\n    }\n\n    if (result.operating_mode === \"Manual\") {\n        result.transfer_switch_status += \" (Manual Mode)\";\n    } else if (result.operating_mode === \"Automatic\") {\n        result.transfer_switch_status += \" (Automatic Mode)\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_STATUS message\nconst decodedData = decodeATSMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1360,
        "wires": [
            [
                "fa30f6cf9bede7e9"
            ]
        ]
    },
    {
        "id": "fa30f6cf9bede7e9",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1360,
        "wires": []
    },
    {
        "id": "4a6d57460d64c76f",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_DIMMER_STATUS_3",
        "func": "// DC_DIMMER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes DC_DIMMER_STATUS_1/2/3 messages per RV-C specification\n// Handles RGB/RGBW dimmer loads with brightness, current, and fault monitoring\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === DC_DIMMER_STATUS Specific Decoders ===\n\nfunction decodeDimmerInstance(value) {\n    // Dimmer instance interpretation per RV-C spec\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeBrightnessLevel(value) {\n    // Brightness level (0-200% per Table 5.3)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Value Changing (Ramp)\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current per Table 5.3 (0.05A resolution for small currents)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeChannelFault(value) {\n    // Channel fault status (2-bit field)\n    const faultStates = {\n        0: \"No Fault\",\n        1: \"Undercurrent (Open Circuit)\",\n        2: \"Overcurrent\",\n        3: \"Reserved\"\n    };\n    return faultStates[value] || \"Unknown\";\n}\n\nfunction decodeFaultByte(value) {\n    // Decode fault bits from byte 5 (STATUS_2)\n    const masterFault = decodeBits(value, 0, 1);\n    const redFault = decodeBits(value, 2, 3);\n    const greenFault = decodeBits(value, 4, 5);\n    const blueFault = decodeBits(value, 6, 7);\n\n    const faults = [];\n    if (masterFault > 0) faults.push(`Master: ${decodeChannelFault(masterFault)}`);\n    if (redFault > 0) faults.push(`Red: ${decodeChannelFault(redFault)}`);\n    if (greenFault > 0) faults.push(`Green: ${decodeChannelFault(greenFault)}`);\n    if (blueFault > 0) faults.push(`Blue: ${decodeChannelFault(blueFault)}`);\n\n    return {\n        fault_summary: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        master_fault: decodeChannelFault(masterFault),\n        red_fault: decodeChannelFault(redFault),\n        green_fault: decodeChannelFault(greenFault),\n        blue_fault: decodeChannelFault(blueFault),\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << i;\n        if (!(value & groupBit)) { // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingStatus(value) {\n    // Operating status for STATUS_3\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step\n    } else if (value === 251) {\n        return \"Value Changing (Ramp)\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeStatus3Byte3(value) {\n    // Decode status bits from byte 3 (STATUS_3)\n    const lockStatus = decodeBits(value, 0, 1);\n    const overcurrentStatus = decodeBits(value, 2, 3);\n    const overrideStatus = decodeBits(value, 4, 5);\n    const enableStatus = decodeBits(value, 6, 7);\n\n    const lockStates = [\"Unlocked\", \"Locked\", \"Reserved\", \"Not Supported\"];\n    const statusStates = [\"Normal/Inactive\", \"Active/Abnormal\", \"Reserved\", \"Not Supported\"];\n    const enableStates = [\"Enabled\", \"Disabled\", \"Reserved\", \"Not Supported\"];\n\n    return {\n        lock_status: lockStates[lockStatus] || \"Unknown\",\n        overcurrent_status: statusStates[overcurrentStatus] || \"Unknown\",\n        override_status: statusStates[overrideStatus] || \"Unknown\",\n        enable_status: enableStates[enableStatus] || \"Unknown\"\n    };\n}\n\nfunction decodeLastCommand(value) {\n    // Last executed command (STATUS_3)\n    const commands = {\n        0: \"Set Brightness\",\n        1: \"ON\",\n        2: \"ON Delay\",\n        3: \"OFF\",\n        4: \"Stop\",\n        5: \"Toggle\",\n        6: \"Memory OFF\",\n        7: \"Save Scene\",\n        11: \"Ramp Brightness\",\n        12: \"Ramp Toggle\",\n        13: \"Ramp Up\",\n        14: \"Ramp Down\",\n        15: \"Ramp Up/Down\",\n        16: \"Ramp Up/Down Toggle\",\n        21: \"Lock\",\n        22: \"Unlock\",\n        31: \"Flash\",\n        32: \"Flash Momentary\",\n        33: \"Flash Pattern\",\n        34: \"Scene Recall\",\n        35: \"Scene Store\",\n        36: \"Group Command\",\n        37: \"Reset\",\n        38: \"Factory Reset\",\n        39: \"Calibrate\",\n        40: \"Test Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeDelayDuration(value) {\n    // Delay/Duration field (STATUS_3)\n    if (value === 0) {\n        return \"Expired\";\n    } else if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 252) {\n        return \"Flashing\";\n    } else if (value === 253) {\n        return \">240 seconds\";\n    } else if (value === 255) {\n        return \"No delay active\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeStatus3Byte6(value) {\n    // Decode status bits from byte 6 (STATUS_3)\n    const interlockStatus = decodeBits(value, 0, 1);\n    const loadStatus = decodeBits(value, 2, 3);\n    const undercurrentStatus = decodeBits(value, 6, 7);\n\n    const interlockStates = [\"Not Active\", \"Active\", \"Reserved\", \"Not Supported\"];\n    const loadStates = [\"Off (status=0)\", \"On (status>0 or flashing)\", \"Reserved\", \"Reserved\"];\n    const undercurrentStates = [\"Normal\", \"Active\", \"Timeout Error\", \"Not Supported\"];\n\n    return {\n        interlock_status: interlockStates[interlockStatus] || \"Unknown\",\n        load_status: loadStates[loadStatus] || \"Unknown\",\n        undercurrent_status: undercurrentStates[undercurrentStatus] || \"Unknown\"\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeDCDimmerMessage(dgn, data) {\n    // Map DGN hex codes to specific names for unified routing\n    let dgnName = \"DC_DIMMER_STATUS\"; // fallback\n    const dgnHex = dgn.toUpperCase();\n    if (dgnHex === \"1FFBB\") {\n        dgnName = \"DC_DIMMER_STATUS_1\";\n    } else if (dgnHex === \"1FFBA\") {\n        dgnName = \"DC_DIMMER_STATUS_2\";\n    } else if (dgnHex === \"1FEDA\") {\n        dgnName = \"DC_DIMMER_STATUS_3\";\n    }\n\n    const result = {\n        dgn: dgn,\n        dgn_name: dgnName\n    };\n\n    // Determine which STATUS message based on DGN and decode accordingly\n\n    if (dgnHex === \"1FFBB\") {\n        // DC_DIMMER_STATUS_1 - Brightness levels and timing\n        result.status_type = \"STATUS_1\";\n\n        if (data.length >= 7) {\n            result.instance = data[0];\n            result.instance_name = decodeDimmerInstance(data[0]);\n            result.master_brightness = decodeBrightnessLevel(data[1]);\n            result.red_brightness = decodeBrightnessLevel(data[2]);\n            result.green_brightness = decodeBrightnessLevel(data[3]);\n            result.blue_brightness = decodeBrightnessLevel(data[4]);\n\n            // Byte 5: On/Off Duration (4 bits each)\n            result.on_duration = decodeBits(data[5], 0, 3); // 0-14 seconds\n            result.off_duration = decodeBits(data[5], 4, 7); // 0-14 seconds\n\n            if (data.length > 6) {\n                result.white_brightness = decodeBrightnessLevel(data[6]);\n            }\n        }\n\n    } else if (dgnHex === \"1FFBA\") {\n        // DC_DIMMER_STATUS_2 - Current measurements and faults\n        result.status_type = \"STATUS_2\";\n\n        if (data.length >= 8) {\n            result.instance = data[0];\n            result.instance_name = decodeDimmerInstance(data[0]);\n            result.red_current = decodeDCCurrent(data[2]);\n            result.green_current = decodeDCCurrent(data[3]);\n            result.blue_current = decodeDCCurrent(data[4]);\n\n            // Byte 5: Fault bits\n            const faultInfo = decodeFaultByte(data[5]);\n            Object.assign(result, faultInfo);\n\n            if (data.length > 6) {\n                result.white_current = decodeDCCurrent(data[6]);\n            }\n\n            if (data.length > 7) {\n                // Byte 7: White fault (bits 0-1)\n                const whiteFault = decodeBits(data[7], 0, 1);\n                result.white_fault = decodeChannelFault(whiteFault);\n            }\n        }\n\n    } else if (dgnHex === \"1FEDA\") {\n        // DC_DIMMER_STATUS_3 - Comprehensive operational status\n        result.status_type = \"STATUS_3\";\n\n        if (data.length >= 8) {\n            result.instance = data[0];\n            result.instance_name = decodeDimmerInstance(data[0]);\n            result.group_membership = decodeGroupBitmap(data[1]);\n            result.operating_status = decodeOperatingStatus(data[2]);\n\n            // Byte 3: Status bits\n            const status3Info = decodeStatus3Byte3(data[3]);\n            Object.assign(result, status3Info);\n\n            result.delay_duration = decodeDelayDuration(data[4]);\n            result.last_command = decodeLastCommand(data[5]);\n\n            // Byte 6: More status bits\n            const status6Info = decodeStatus3Byte6(data[6]);\n            Object.assign(result, status6Info);\n\n            result.master_memory_value = decodeBrightnessLevel(data[7]);\n        }\n    }\n\n    // Validate instance - DC Dimmer valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(`Invalid DC dimmer instance: ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    // Add convenience fields\n    if (result.master_brightness !== undefined) {\n        result.dimmer_on = typeof result.master_brightness === 'number' && result.master_brightness > 0;\n    }\n\n    if (result.operating_status !== undefined) {\n        result.dimmer_active = typeof result.operating_status === 'number' && result.operating_status > 0;\n    }\n\n    if (result.any_fault !== undefined) {\n        result.dimmer_healthy = !result.any_fault;\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the DC_DIMMER_STATUS message\nconst decodedData = decodeDCDimmerMessage(dgn, dataBytes);\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Keep dataPayload in case downstream nodes need it\n// (Removed deletion to prevent issues with message reprocessing)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 160,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "d76a4a48e1beaed6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FURNACE_STATUS",
        "func": "// FURNACE_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes FURNACE_STATUS messages per RV-C specification\n// Handles gas/diesel furnace operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === FURNACE_STATUS Specific Decoders ===\n\nfunction decodeFurnaceInstance(value) {\n    // Furnace instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Furnace operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Pre-Purge\",\n        3: \"Ignition\",\n        4: \"Flame Established\",\n        5: \"Running\",\n        6: \"Post-Purge\",\n        7: \"Shutdown\",\n        8: \"Lockout\",\n        9: \"Fault\",\n        10: \"Safety Check\",\n        11: \"Cool Down\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeFurnaceCommand(value) {\n    // Furnace command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Reset Fault\",\n        3: \"Test\",\n        4: \"Service Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Propane\",\n        2: \"Diesel\",\n        3: \"Gasoline\",\n        4: \"Natural Gas\",\n        5: \"Electric\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40C to +170C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeAirFlow(value) {\n    // Air flow in CFM (Cubic Feet per Minute)\n    if (value <= 65000) {\n        return value; // Direct CFM value\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Ignition Failure\",\n        2: \"Flame Loss\",\n        3: \"High Temperature\",\n        4: \"Low Gas Pressure\",\n        5: \"High Gas Pressure\",\n        6: \"Fan Failure\",\n        7: \"Igniter Failure\",\n        8: \"Flame Sensor Failure\",\n        9: \"Control Board Fault\",\n        10: \"Safety Lockout\",\n        11: \"Overheat\",\n        12: \"Airflow Problem\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Flame Present\");\n    if (value & 0x02) statusBits.push(\"Igniter On\");\n    if (value & 0x04) statusBits.push(\"Gas Valve Open\");\n    if (value & 0x08) statusBits.push(\"Fan Running\");\n    if (value & 0x10) statusBits.push(\"Safety Circuit OK\");\n    if (value & 0x20) statusBits.push(\"High Limit OK\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific FURNACE_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeFurnaceInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeFurnaceCommand(value);\n        }\n        if (param.name === 'fuel type') {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'fan speed') {\n            return decodeFanSpeed(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'air flow' || param.name.includes('flow')) {\n            return decodeAirFlow(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeFurnaceMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"FURNACE_STATUS\"\n    };\n\n    // Decode based on FURNACE_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeFurnaceInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Byte 3: Exhaust Temperature\n        result.exhaust_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Intake Temperature\n        result.intake_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[5]);\n\n        // Bytes 6-7: Air Flow (16-bit, little-endian)\n        const airFlow = data[6] | (data[7] << 8);\n        result.air_flow = decodeAirFlow(airFlow);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_exhaust_temperature = data[3];\n        result.raw_intake_temperature = data[4];\n        result.raw_fan_speed = data[5];\n        result.raw_air_flow_bytes = [data[6], data[7]];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.furnace_running = state === \"running\";\n        result.furnace_heating = [\"flame established\", \"running\"].includes(state);\n        result.furnace_available = ![\"fault\", \"lockout\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"lockout\") || state.includes(\"error\");\n        result.is_starting = [\"starting\", \"pre-purge\", \"ignition\"].includes(state);\n        result.is_shutting_down = [\"post-purge\", \"shutdown\", \"cool down\"].includes(state);\n    }\n\n    // Temperature status\n    result.exhaust_temp_available = typeof result.exhaust_temperature === 'number';\n    result.intake_temp_available = typeof result.intake_temperature === 'number';\n\n    // Fan status\n    result.fan_running = typeof result.fan_speed === 'number' && result.fan_speed > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the FURNACE_STATUS message\nconst decodedData = decodeFurnaceMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 700,
        "wires": [
            [
                "9d90b7163a12d5ed"
            ]
        ]
    },
    {
        "id": "9d90b7163a12d5ed",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "FURNACE_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 700,
        "wires": []
    },
    {
        "id": "fbc5efde2c447eda",
        "type": "link in",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS in",
        "links": [
            "02bdfc59de71b5a5"
        ],
        "x": 220,
        "y": 260,
        "wires": [
            [
                "9f88f215f3f07227"
            ]
        ],
        "l": true
    },
    {
        "id": "ffd5bc5ca5695602",
        "type": "inject",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 780,
        "wires": [
            [
                "09640adb1fd08fbb"
            ]
        ]
    },
    {
        "id": "09640adb1fd08fbb",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecodedStatus\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 780,
        "wires": [
            []
        ]
    },
    {
        "id": "b797e5a52b6db5b4",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Unique STATUS",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecodedStatus = flow.get(\"uniqueDecodedStatus\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgnName);\n\n// Check if it's a new unique message\nif (!uniqueDecodedStatus.includes(newMsgStr)) {\n    uniqueDecodedStatus.push(newMsgStr);\n    flow.set(\"uniqueDecodedStatus\", uniqueDecodedStatus);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 160,
        "y": 840,
        "wires": [
            [
                "48e6dda2b2d9575e"
            ]
        ]
    },
    {
        "id": "48e6dda2b2d9575e",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "New Unique Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 840,
        "wires": []
    },
    {
        "id": "d0e2cc417cf65b90",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 460,
        "wires": []
    },
    {
        "id": "ccec30ad0f32bbdf",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_1",
        "func": "// THERMOSTAT_STATUS_1 Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_STATUS_1 messages per RV-C specification\n// Handles primary thermostat control and status information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_1 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode mapping per RV-C specification (extended)\n    const modes = {\n        0: \"Off\",\n        1: \"Auto\",\n        2: \"Heat\",\n        3: \"Cool\",\n        4: \"Furnace\",\n        5: \"Fan Only\",\n        6: \"Dry\",\n        7: \"Emergency Heat\",\n        8: \"Heat Pump\",\n        9: \"Defrost\",\n        10: \"Aux Heat\",\n        11: \"Eco Mode\",\n        12: \"Sleep Mode\",\n        13: \"Away Mode\",\n        14: \"Manual Override\",\n        15: \"Vacation Mode\",\n        16: \"Schedule Mode\",\n        17: \"Temperature Hold\",\n        18: \"Energy Save\",\n        19: \"Quick Heat\",\n        20: \"Quick Cool\",\n        21: \"System Test\",\n        22: \"Calibration\",\n        23: \"Service Mode\",\n        24: \"Installation Mode\",\n        25: \"Demo Mode\",\n        26: \"Lock Mode\",\n        27: \"Filter Mode\",\n        28: \"Humidity Control\",\n        29: \"Dehumidify\",\n        30: \"Humidify\",\n        31: \"Air Quality Mode\",\n        32: \"Zone Control\",\n        33: \"Multi-Stage Heat\",\n        34: \"Multi-Stage Cool\",\n        35: \"Heat Recovery\",\n        36: \"Ventilation Mode\",\n        37: \"Fresh Air Mode\",\n        38: \"Recirculate Mode\",\n        39: \"Purge Mode\",\n        40: \"Startup Mode\",\n        41: \"Shutdown Mode\",\n        42: \"Fault Recovery\",\n        43: \"Performance Test\",\n        44: \"Efficiency Mode\",\n        45: \"Comfort Mode\",\n        46: \"Advanced Auto\",\n        47: \"Smart Mode\",\n        48: \"Remote Control\",\n        49: \"Mobile App Control\",\n        50: \"Voice Control\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return modes[value] || `Unknown Mode ${value}`;\n}\n\nfunction decodeFanMode(value) {\n    // Fan mode mapping\n    const fanModes = {\n        0: \"Auto\",\n        1: \"On\",\n        2: \"Low\",\n        3: \"Medium\",\n        4: \"High\",\n        5: \"Variable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fanModes[value] || `Unknown Fan Mode ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset (-40C to +170C range)\n    if (value <= 210) {\n        const temp = value - 40; // Offset by 40 degrees\n        if (isCelsius) {\n            return parseFloat(temp.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Heating Active\");\n    if (value & 0x02) statusBits.push(\"Cooling Active\");\n    if (value & 0x04) statusBits.push(\"Fan Running\");\n    if (value & 0x08) statusBits.push(\"Aux Heat Active\");\n    if (value & 0x10) statusBits.push(\"Defrost Active\");\n    if (value & 0x20) statusBits.push(\"System Fault\");\n    if (value & 0x40) statusBits.push(\"Filter Change Required\");\n    if (value & 0x80) statusBits.push(\"Service Required\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage (0-100%)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus1Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_1\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_1 format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Operating Mode\n        result.operating_mode = decodeOperatingMode(data[1]);\n\n        // Byte 2: Fan Mode\n        result.fan_mode = decodeFanMode(data[2]);\n\n        // Byte 3: Set Point Temperature\n        result.set_point_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: System Status\n        result.system_status = decodeSystemStatus(data[5]);\n\n        // Byte 6: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[6]);\n\n        // Byte 7: Reserved/Future use\n        // Typically 0xFF in current implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_mode = data[1];\n        result.raw_fan_mode = data[2];\n        result.raw_set_point_temperature = data[3];\n        result.raw_ambient_temperature = data[4];\n        result.raw_system_status = data[5];\n        result.raw_fan_speed = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.thermostat_available = result.instance !== \"Not Available\" &&\n                                  result.operating_mode !== \"Not Available\";\n\n    result.temperature_available = typeof result.ambient_temperature === 'number' &&\n                                   typeof result.set_point_temperature === 'number';\n\n    // Calculate temperature difference if both temps available\n    if (result.temperature_available) {\n        result.temperature_difference = parseFloat((result.ambient_temperature - result.set_point_temperature).toFixed(1));\n        result.needs_heating = result.temperature_difference < -1; // More than 1F below setpoint\n        result.needs_cooling = result.temperature_difference > 1;  // More than 1F above setpoint\n    }\n\n    // System operating status\n    if (typeof result.system_status === 'string' && result.system_status !== \"Not Available\") {\n        result.heating_active = result.system_status.includes(\"Heating Active\");\n        result.cooling_active = result.system_status.includes(\"Cooling Active\");\n        result.fan_running = result.system_status.includes(\"Fan Running\");\n        result.aux_heat_active = result.system_status.includes(\"Aux Heat Active\");\n        result.defrost_active = result.system_status.includes(\"Defrost Active\");\n        result.system_fault = result.system_status.includes(\"System Fault\");\n        result.filter_change_required = result.system_status.includes(\"Filter Change Required\");\n        result.service_required = result.system_status.includes(\"Service Required\");\n        result.system_active = result.heating_active || result.cooling_active || result.defrost_active;\n    } else {\n        result.heating_active = false;\n        result.cooling_active = false;\n        result.fan_running = false;\n        result.aux_heat_active = false;\n        result.defrost_active = false;\n        result.system_fault = false;\n        result.filter_change_required = false;\n        result.service_required = false;\n        result.system_active = false;\n    }\n\n    // Operating mode status\n    result.is_off = result.operating_mode === \"Off\";\n    result.is_auto_mode = result.operating_mode === \"Auto\";\n    result.is_heating_mode = result.operating_mode === \"Heat\" || result.operating_mode === \"Furnace\" ||\n                             result.operating_mode === \"Heat Pump\" || result.operating_mode === \"Emergency Heat\";\n    result.is_cooling_mode = result.operating_mode === \"Cool\";\n\n    // Fan status\n    result.fan_auto_mode = result.fan_mode === \"Auto\";\n    result.fan_on_mode = result.fan_mode === \"On\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_1 message\nconst decodedData = decodeThermostatStatus1Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 460,
        "wires": [
            [
                "d0e2cc417cf65b90"
            ]
        ]
    },
    {
        "id": "45ae070eafc9a732",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "TANK_STATUS",
        "mode": "link",
        "links": [
            "61f4573c56915577"
        ],
        "x": 1300,
        "y": 340,
        "wires": [],
        "l": true
    },
    {
        "id": "bff245b2ca47ef79",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_SOURCE_STATUS_1",
        "mode": "link",
        "links": [
            "663120adc5ec254f"
        ],
        "x": 1340,
        "y": 400,
        "wires": [],
        "l": true
    },
    {
        "id": "7af7fb2178a714cf",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_3",
        "mode": "link",
        "links": [
            "7313d7c724d31538"
        ],
        "x": 1330,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "0ecfccb41b17f21b",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "SOLAR_EQUALIZATION_CONFIGURATION_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1420,
        "wires": []
    },
    {
        "id": "1b079a5b225e1552",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1480,
        "wires": []
    },
    {
        "id": "f945d56c437bfb38",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1540,
        "wires": []
    },
    {
        "id": "3b2f348b9326267c",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WINDOW_SHADE_CONTROL_STATUS",
        "func": "// WINDOW_SHADE_CONTROL_STATUS Decoder - Complete RV-C Implementation\n// Decodes WINDOW_SHADE_CONTROL_STATUS messages per RV-C specification Section 6.39.2\n// Handles window shade operating status, motor control, and position information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === WINDOW_SHADE_CONTROL_STATUS Specific Decoders ===\n\nfunction decodeInstance(value) {\n    // Window shade instance mapping\n    if (value >= 1 && value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 0) {\n        return \"All Instances\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeGroupDetails(value) {\n    // Group membership bitmap decoding\n    if (value === 0xFF) {\n        return { type: 'special', description: 'No data' };\n    }\n    if (value === 0x00) {\n        return { type: 'special', description: 'Member of all groups' };\n    }\n\n    const groups = [];\n    for (let bit = 0; bit < 7; bit++) {\n        if (!(value & (1 << bit))) {\n            groups.push(bit + 1);\n        }\n    }\n\n    if (groups.length > 0) {\n        return {\n            type: 'standard',\n            groups: groups,\n            description: `Groups: ${groups.join(', ')}`\n        };\n    } else {\n        return {\n            type: 'standard',\n            groups: [],\n            description: \"No group membership\"\n        };\n    }\n}\n\nfunction decodeOperatingStatus(value) {\n    // Operating status (motor duty) as percentage per Table 5.3\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Value Changing\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLockStatus(value) {\n    // Lock status (bits 0-1)\n    const lockMap = {\n        0: \"Load is unlocked\",\n        1: \"Load is locked\",\n        3: \"Lock command not supported\"\n    };\n    return lockMap[value] || `Unknown Lock Status ${value}`;\n}\n\nfunction decodeMotorStatus(value) {\n    // Motor status (bits 2-3)\n    const motorMap = {\n        0: \"Neither 'Forward' nor 'Reverse' output is on\",\n        1: \"Either 'Forward' or 'Reverse' output is on (Motor active)\"\n    };\n    return motorMap[value] || `Unknown Motor Status ${value}`;\n}\n\nfunction decodeForwardStatus(value) {\n    // Forward status (bits 4-5)\n    const forwardMap = {\n        0: \"'Forward' output not on\",\n        1: \"'Forward' output is on (Shade raising/opening)\"\n    };\n    return forwardMap[value] || `Unknown Forward Status ${value}`;\n}\n\nfunction decodeReverseStatus(value) {\n    // Reverse status (bits 6-7)\n    const reverseMap = {\n        0: \"'Reverse' output not on\",\n        1: \"'Reverse' output is on (Shade lowering/closing)\"\n    };\n    return reverseMap[value] || `Unknown Reverse Status ${value}`;\n}\n\nfunction decodeDuration(value) {\n    // Duration decoding\n    if (value === 0) {\n        return \"Delay/duration expired\";\n    } else if (value >= 1 && value <= 239) {\n        return `${value} seconds remaining`;\n    } else if (value === 240) {\n        return \"240 or more seconds remaining\";\n    } else if (value === 255) {\n        return \"No delay/duration active\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLastCommand(value) {\n    // Last command executed mapping per Table 6.39.3c\n    const commandMap = {\n        4: \"Stop\",\n        129: \"Forward (Open Shade)\", // 0x81\n        65: \"Reverse (Close Shade)\", // 0x41\n        133: \"Toggle Forward\", // 0x85\n        69: \"Toggle Reverse\", // 0x45\n        16: \"Tilt\", // 0x10\n        33: \"Lock\", // 0x21\n        34: \"Unlock\" // 0x22\n    };\n    return commandMap[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeOvercurrentStatus(value) {\n    // Overcurrent status (bits 0-1)\n    const overcurrentMap = {\n        0: \"Load output not in overcurrent\",\n        1: \"Load output has drawn overcurrent\",\n        3: \"Overcurrent status unavailable or not supported\"\n    };\n    return overcurrentMap[value] || `Unknown Overcurrent Status ${value}`;\n}\n\nfunction decodeOverrideStatus(value) {\n    // Override status (bits 2-3)\n    const overrideMap = {\n        0: \"External override is inactive\",\n        1: \"External override is active\",\n        3: \"Override status is unavailable or not supported\"\n    };\n    return overrideMap[value] || `Unknown Override Status ${value}`;\n}\n\nfunction decodeDisableStatus(value, disableNumber) {\n    // Disable status for Disable1 (bits 4-5) or Disable2 (bits 6-7)\n    const disableMap = {\n        0: `Disable ${disableNumber} is not active`,\n        1: `Disable ${disableNumber} is active`,\n        3: `Disable ${disableNumber} is not supported`\n    };\n    return disableMap[value] || `Unknown Disable${disableNumber} Status ${value}`;\n}\n\n// === Main Decode Function ===\n\nfunction decodeWindowShadeControlStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"WINDOW_SHADE_CONTROL_STATUS\"\n    };\n\n    if (data.length < 7) {\n        return { error: \"Invalid data length for WINDOW_SHADE_CONTROL_STATUS - expected at least 7 bytes\" };\n    }\n\n    // Byte 0: Instance\n    result.instance = data[0];\n    result.instance_name = decodeInstance(data[0]);\n\n    // Byte 1: Group\n    const groupDetails = decodeGroupDetails(data[1]);\n    result.group_description = groupDetails.description;\n    if (groupDetails.groups) {\n        result.groups = groupDetails.groups;\n    }\n\n    // Byte 2: Operating Status (Motor Duty)\n    result.operating_status = decodeOperatingStatus(data[2]);\n\n    // Byte 3: Lock Status, Motor Status, Forward Status, Reverse Status\n    const byte3 = data[3];\n    const lockStatusRaw = decodeBits(byte3, 0, 1);\n    const motorStatusRaw = decodeBits(byte3, 2, 3);\n    const forwardStatusRaw = decodeBits(byte3, 4, 5);\n    const reverseStatusRaw = decodeBits(byte3, 6, 7);\n\n    result.lock_status = decodeLockStatus(lockStatusRaw);\n    result.motor_status = decodeMotorStatus(motorStatusRaw);\n    result.forward_status = decodeForwardStatus(forwardStatusRaw);\n    result.reverse_status = decodeReverseStatus(reverseStatusRaw);\n\n    // Byte 4: Duration\n    result.duration = decodeDuration(data[4]);\n\n    // Byte 5: Last Command\n    result.last_command = decodeLastCommand(data[5]);\n\n    // Byte 6: Overcurrent Status, Override Status, Disable1 Status, Disable2 Status\n    const byte6 = data[6];\n    const overcurrentStatusRaw = decodeBits(byte6, 0, 1);\n    const overrideStatusRaw = decodeBits(byte6, 2, 3);\n    const disable1StatusRaw = decodeBits(byte6, 4, 5);\n    const disable2StatusRaw = decodeBits(byte6, 6, 7);\n\n    result.overcurrent_status = decodeOvercurrentStatus(overcurrentStatusRaw);\n    result.override_status = decodeOverrideStatus(overrideStatusRaw);\n    result.disable1_status = decodeDisableStatus(disable1StatusRaw, 1);\n    result.disable2_status = decodeDisableStatus(disable2StatusRaw, 2);\n\n    // Raw values for debugging\n    result.raw_instance = data[0];\n    result.raw_group = data[1];\n    result.raw_operating_status = data[2];\n    result.raw_byte3 = byte3;\n    result.raw_lock_status = lockStatusRaw;\n    result.raw_motor_status = motorStatusRaw;\n    result.raw_forward_status = forwardStatusRaw;\n    result.raw_reverse_status = reverseStatusRaw;\n    result.raw_duration = data[4];\n    result.raw_last_command = data[5];\n    result.raw_byte6 = byte6;\n    result.raw_overcurrent_status = overcurrentStatusRaw;\n    result.raw_override_status = overrideStatusRaw;\n    result.raw_disable1_status = disable1StatusRaw;\n    result.raw_disable2_status = disable2StatusRaw;\n\n    // Add convenience fields for Home Assistant integration\n    result.is_locked = lockStatusRaw === 1;\n    result.motor_active = motorStatusRaw === 1;\n    result.shade_opening = forwardStatusRaw === 1;\n    result.shade_closing = reverseStatusRaw === 1;\n    result.shade_moving = result.shade_opening || result.shade_closing;\n    result.has_overcurrent = overcurrentStatusRaw === 1;\n    result.override_active = overrideStatusRaw === 1;\n    result.disable1_active = disable1StatusRaw === 1;\n    result.disable2_active = disable2StatusRaw === 1;\n    result.any_disable_active = result.disable1_active || result.disable2_active;\n\n    // Determine shade position status\n    if (typeof result.operating_status === 'number') {\n        result.shade_position_percent = result.operating_status;\n        result.shade_fully_open = result.operating_status >= 99;\n        result.shade_fully_closed = result.operating_status <= 1;\n        result.shade_partially_open = result.operating_status > 1 && result.operating_status < 99;\n    } else {\n        result.shade_position_percent = null;\n        result.shade_fully_open = false;\n        result.shade_fully_closed = false;\n        result.shade_partially_open = false;\n    }\n\n    // Validate instance - Window shade valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(`Invalid shade instance: ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the WINDOW_SHADE_CONTROL_STATUS message\nlet decodedData;\nif (dgn === '1FEDE') {\n    decodedData = decodeWindowShadeControlStatusMessage(dgn, dataBytes);\n\n    // --- UPDATED FILTERING LOGIC ---\n    // Filter out messages that are either from an inactive instance OR are invalid/non-compliant.\n    // 1. Inactive: Operating Status is \"Not Available\" (raw value 255).\n    // 2. Invalid: Last Command is 0, which is not a defined command in the RV-C spec.\n    if (decodedData.raw_operating_status === 255 || decodedData.raw_last_command === 0) {\n        let reason = (decodedData.raw_operating_status === 255) ? \"Inactive (Status Not Available)\" : \"Invalid (Last Command is 0)\";\n        node.debug(`Filtering out instance ${decodedData.instance}: ${reason}`);\n        return null; // Stop the message from continuing.\n    }\n    // --- END OF UPDATED BLOCK ---\n\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 220,
        "wires": [
            [
                "4ab29d3dd1da32a5"
            ]
        ]
    },
    {
        "id": "eb3524b2b7bf51e5",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode LOCK_STATUS",
        "func": "// LOCK_STATUS Decoder - Complete RV-C Implementation\n// Decodes LOCK_STATUS messages per RV-C specification Section 6.40.2\n// Handles door/window lock status, motion detection, and position information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === LOCK_STATUS Specific Decoders ===\n\nfunction decodeInstance(value) {\n    // Lock instance mapping per Section 6.40.1\n    if (value >= 1 && value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 0) {\n        return \"Invalid\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLockStatus(value) {\n    // Lock status (bits 0-1)\n    const lockMap = {\n        0: \"Unlocked\",\n        1: \"Locked\"\n    };\n    return lockMap[value] || `Unknown Lock Status ${value}`;\n}\n\nfunction decodeMotion(value) {\n    // Motion status\n    const motionMap = {\n        0: \"No Motion\",\n        1: \"Opening\",\n        2: \"Closing\"\n    };\n    return motionMap[value] || `Unknown Motion ${value}`;\n}\n\nfunction decodePosition(value) {\n    // Position as percentage per Table 5.3 (100% = Fully Open)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeVoltage(value) {\n    // Voltage decoding per Table 5.3 (16-bit, little-endian)\n    if (value === 65535) {\n        return \"Not Available\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65532) {\n        return \"Error\";\n    } else if (value <= 65530) {\n        // Voltage in mV with 0.1V resolution\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1V per step\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeLockStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"LOCK_STATUS\"\n    };\n\n    if (data.length < 6) {\n        return { error: \"Invalid data length for LOCK_STATUS - expected at least 6 bytes\" };\n    }\n\n    // Byte 0: Instance\n    result.instance = data[0];\n    result.instance_name = decodeInstance(data[0]);\n\n    // Byte 1: Lock Status (bits 0-1)\n    const byte1 = data[1];\n    const lockStatusRaw = decodeBits(byte1, 0, 1);\n    result.lock_status = decodeLockStatus(lockStatusRaw);\n\n    // Byte 2: Motion\n    result.motion = decodeMotion(data[2]);\n\n    // Byte 3: Position\n    result.position = decodePosition(data[3]);\n\n    // Bytes 4-5: Voltage (16-bit, little-endian)\n    const voltageRaw = decodeUint16(data, 4);\n    result.voltage = decodeVoltage(voltageRaw);\n\n    // Raw values for debugging\n    result.raw_instance = data[0];\n    result.raw_byte1 = byte1;\n    result.raw_lock_status = lockStatusRaw;\n    result.raw_motion = data[2];\n    result.raw_position = data[3];\n    result.raw_voltage_bytes = data.length >= 6 ? [data[4], data[5]] : null;\n    result.raw_voltage = voltageRaw;\n\n    // Include additional bytes if present\n    if (data.length > 6) {\n        for (let i = 6; i < data.length; i++) {\n            result[`raw_byte${i}`] = data[i];\n        }\n    }\n\n    // Add convenience fields for Home Assistant integration\n    result.is_locked = lockStatusRaw === 1;\n    result.is_unlocked = lockStatusRaw === 0;\n    result.is_moving = data[2] === 1 || data[2] === 2;\n    result.is_opening = data[2] === 1;\n    result.is_closing = data[2] === 2;\n    result.is_stationary = data[2] === 0;\n\n    // Position status (if available)\n    if (typeof result.position === 'number') {\n        result.position_percent = result.position;\n        result.fully_open = result.position >= 99;\n        result.fully_closed = result.position <= 1;\n        result.partially_open = result.position > 1 && result.position < 99;\n    } else {\n        result.position_percent = null;\n        result.fully_open = false;\n        result.fully_closed = false;\n        result.partially_open = false;\n    }\n\n    // Voltage status (if available)\n    if (typeof result.voltage === 'number') {\n        result.voltage_volts = result.voltage;\n        result.low_voltage = result.voltage < 11.0; // Typical 12V system low voltage threshold\n        result.high_voltage = result.voltage > 15.0; // Typical 12V system high voltage threshold\n        result.normal_voltage = result.voltage >= 11.0 && result.voltage <= 15.0;\n    } else {\n        result.voltage_volts = null;\n        result.low_voltage = false;\n        result.high_voltage = false;\n        result.normal_voltage = false;\n    }\n\n    // Validate instance - Lock valid instances are 0-250 (0 = broadcast/all locks)\n    if (result.instance < 0 || result.instance > 250) {\n        node.warn(`Invalid lock instance: ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    // Lock and motion combination status\n    result.locked_and_closed = result.is_locked && result.fully_closed;\n    result.unlocked_and_open = result.is_unlocked && result.fully_open;\n    result.secure_status = result.locked_and_closed ? \"Secure\" : \"Not Secure\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the LOCK_STATUS message\nlet decodedData;\nif (dgn === '1FEE5') {\n    decodedData = decodeLockStatusMessage(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 280,
        "wires": [
            [
                "f00adfe38f0e26b5"
            ]
        ]
    },
    {
        "id": "f00adfe38f0e26b5",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "LOCK_STATUS",
        "mode": "link",
        "links": [
            "1d2d33ef4e57dd39"
        ],
        "x": 1300,
        "y": 280,
        "wires": [],
        "l": true
    },
    {
        "id": "4ab29d3dd1da32a5",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "SHADE_STATUS",
        "mode": "link",
        "links": [
            "f9a04003db7d8e4a"
        ],
        "x": 1310,
        "y": 220,
        "wires": [],
        "l": true
    },
    {
        "id": "b87fcd5e60905824",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "AUTOFILL_STATUS",
        "mode": "link",
        "links": [
            "93a2783b5bb8d93d"
        ],
        "x": 1320,
        "y": 100,
        "wires": [],
        "l": true
    },
    {
        "id": "295d4bc9058dab71",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "WATER_PUMP_STATUS",
        "mode": "link",
        "links": [
            "efb5c968a0a43c7d"
        ],
        "x": 1330,
        "y": 40,
        "wires": [],
        "l": true
    },
    {
        "id": "40bc1ec5180b6589",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_SOURCE_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1600,
        "wires": []
    },
    {
        "id": "db73295f937c90a1",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "FLOOR_HEAT_STATUS",
        "mode": "link",
        "links": [
            "bd2d1b59183b99bb"
        ],
        "x": 1330,
        "y": 640,
        "wires": [],
        "l": true
    },
    {
        "id": "7e609140970f546c",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Load on Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 260,
        "y": 1580,
        "wires": [
            [
                "74c7e4a6cc2508eb"
            ]
        ]
    },
    {
        "id": "74c7e4a6cc2508eb",
        "type": "file in",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Read DGN table",
        "filename": "/config/projects/rv-link-node-red/rvc/dgn-summary-table.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "allProps": false,
        "x": 460,
        "y": 1580,
        "wires": [
            [
                "c78420a075d43408"
            ]
        ]
    },
    {
        "id": "cd670f6465b6374b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Store dgnTable",
        "func": "// Convert the data to a Map when initially storing it\nconst dgnMap = new Map(\n    msg.payload.map(entry => [\n        entry.Hex.toString().toUpperCase(),\n        entry.DGN\n    ])\n);\n\n// Add the special case for FECA\n//if (dgnMap.has('FECA')) {\n//    dgnMap.set('1FECA', dgnMap.get('FECA'));\n//}\n\n// Store the Map in global context\nglobal.set('dgnMap', dgnMap);\n\n// Count the number of records\nconst decoderCount = dgnMap.size;\n\n// Update the node status to indicate success\nnode.status({ fill: 'green', shape: 'dot', text: `Config loaded, ${decoderCount} records` });\nreturn null;",
        "outputs": 0,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1580,
        "wires": []
    },
    {
        "id": "c78420a075d43408",
        "type": "json",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 670,
        "y": 1580,
        "wires": [
            [
                "cd670f6465b6374b"
            ]
        ]
    },
    {
        "id": "cacf35b859af22a9",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out: Retain TRUE",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 730,
        "y": 380,
        "wires": []
    },
    {
        "id": "e7ae35364ce60f3f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 420,
        "wires": []
    },
    {
        "id": "f658418a7b9b4857",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out: Retain TRUE",
        "links": [
            "d38c75bc1474be23",
            "d3a13b531babee66",
            "d4ef1d361f084b58",
            "ea29386f9f8682bc",
            "b94bb12a8c0a7027",
            "927340668e7942e4",
            "bc627a6a37117bc0",
            "cff02a511add6887",
            "f0ba2779795efdae"
        ],
        "x": 270,
        "y": 380,
        "wires": [
            [
                "cacf35b859af22a9",
                "e7ae35364ce60f3f"
            ]
        ],
        "l": true
    },
    {
        "id": "b86f82e84d961549",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/+/+/set",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 180,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "64c5e5cfd4382453",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "mode": "link",
        "links": [
            "a3b957142479c075"
        ],
        "x": 670,
        "y": 280,
        "wires": [],
        "l": true
    },
    {
        "id": "2110ea4d0b85f784",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "topic": "can/raw",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 120,
        "wires": [
            [
                "958fed9f12301f59",
                "32add109922d428a"
            ]
        ]
    },
    {
        "id": "958fed9f12301f59",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "mode": "link",
        "links": [
            "2fcbc4d630144362"
        ],
        "x": 680,
        "y": 140,
        "wires": [],
        "l": true
    },
    {
        "id": "8d7d5d3ea117cf79",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decode RVC CAN",
        "func": "// RVC CAN Message Parser\n// Decodes a raw CAN message to output only the fields needed for\n// downstream routing (dgnName) and decoding (dataPayload).\n// Input: msg.payload (string) - e.g., \"19FEDA8C#3AFF00FDFF2100FF\"\n// Output: msg.payload (object) with essential fields\n\nconst originalMessage = msg.payload;\n\n// 1. Validate input\nif (!originalMessage || typeof originalMessage !== 'string') {\n    node.warn(\"Invalid message payload: expected string, got \" + typeof originalMessage);\n    return null;\n}\nconst dgnMap = global.get('dgnMap');\nif (!dgnMap) {\n    node.error(\"dgnMap not found in global context. Ensure the map is initialized.\");\n    return null;\n}\n\n// 2. Parse CAN message format: CANID#PAYLOAD\nconst parts = originalMessage.split('#');\nif (parts.length !== 2) {\n    node.warn(\"Invalid CAN message format: \" + originalMessage);\n    return null;\n}\nconst canIdHex = parts[0];\nconst dataPayload = parts[1];\nconst canIdNum = parseInt(canIdHex, 16);\n\nif (isNaN(canIdNum)) {\n    node.warn(\"Invalid CAN ID: \" + canIdHex);\n    return null;\n}\n\n// 3. Determine the DGN and its name\nlet dgn = ((canIdNum >> 8) & 0x1FFFF).toString(16).toUpperCase();\nlet dgnName = dgnMap.get(dgn);\n\n// Fallback logic for alternate DGN formats\nif (!dgnName && dgn.length === 4) {\n    const alternateDgn = '1' + dgn;\n    const alternateName = dgnMap.get(alternateDgn);\n    if (alternateName) {\n        dgn = alternateDgn;\n        dgnName = alternateName;\n    }\n}\n\n// Fallback for proprietary names\nif (!dgnName) {\n    if (dgn === 'EF64') {\n        dgnName = \"AQUAHOT\";\n    } else if (dgn.startsWith('EF')) {\n        dgnName = \"PROPRIETARY\";\n    }\n}\n\n// Default to UNKNOWN if no name is found\nif (!dgnName) {\n    dgnName = \"UNKNOWN\";\n}\n\n// 4. Create the simplified output object\nmsg.payload = {\n    originalMessage: originalMessage,\n    dgn: dgn,\n    dgnName: dgnName,\n    dataPayload: dataPayload\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 460,
        "wires": [
            [
                "ac47ce53a9fc3f21",
                "698efabc308fece6",
                "a16ce99da6a2a88f",
                "2e131d4d25819c93",
                "a2dad25eb05117f7",
                "fc66c16576e28548",
                "c6fb02a17f709e08",
                "a6594a9464d8fe4e"
            ]
        ]
    },
    {
        "id": "ac47ce53a9fc3f21",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decoded",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1480,
        "y": 580,
        "wires": []
    },
    {
        "id": "698efabc308fece6",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dataPayload",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dataPayload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1490,
        "y": 540,
        "wires": []
    },
    {
        "id": "a16ce99da6a2a88f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgn",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgn",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 340,
        "wires": []
    },
    {
        "id": "2e131d4d25819c93",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgnName",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgnName",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1480,
        "y": 380,
        "wires": []
    },
    {
        "id": "a2dad25eb05117f7",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "originalMessage",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.originalMessage",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1500,
        "y": 300,
        "wires": []
    },
    {
        "id": "fc66c16576e28548",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "sourceAddress",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.sourceAddress",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1500,
        "y": 420,
        "wires": []
    },
    {
        "id": "c6fb02a17f709e08",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "priority",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.priority",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 500,
        "wires": []
    },
    {
        "id": "2fcbc4d630144362",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "CAN in",
        "links": [
            "958fed9f12301f59"
        ],
        "x": 1030,
        "y": 460,
        "wires": [
            [
                "8d7d5d3ea117cf79"
            ]
        ],
        "l": true
    },
    {
        "id": "a6594a9464d8fe4e",
        "type": "switch",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DM-RV",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DATE_TIME_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "UNKNOWN",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DC_DIMMER_COMMAND",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ADDRESS_CLAIMED",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AQUAHOT",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "PROPRIETARY",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 10,
        "x": 1710,
        "y": 460,
        "wires": [
            [],
            [],
            [
                "c781b519a9f9b156"
            ],
            [
                "02bdfc59de71b5a5"
            ],
            [
                "c4216c430d06083f",
                "d0150fd6556514e6"
            ],
            [
                "03744ec33f2e6776"
            ],
            [
                "45414bacecada477"
            ],
            [
                "8f99241c9a1cfbde"
            ],
            [
                "3d5ce3e925ee2f04"
            ],
            [
                "463dfbbef66b51c2"
            ]
        ]
    },
    {
        "id": "a4028527eb23fa04",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2250,
        "y": 640,
        "wires": [
            [
                "092c751dcdd12270"
            ]
        ]
    },
    {
        "id": "092c751dcdd12270",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset function",
        "func": "flow.set(\"uniqueUNKNOWN\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2520,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "c781b519a9f9b156",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Unique UNKNOWN",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueUNKNOWN = flow.get(\"uniqueUNKNOWN\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgn);\n\n// Check if it's a new unique message\nif (!uniqueUNKNOWN.includes(newMsgStr)) {\n    uniqueUNKNOWN.push(newMsgStr);\n    flow.set(\"uniqueUNKNOWN\", uniqueUNKNOWN);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 600,
        "wires": [
            [
                "eea1641469efb23f"
            ]
        ]
    },
    {
        "id": "eea1641469efb23f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "New UNKNOWN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2530,
        "y": 700,
        "wires": []
    },
    {
        "id": "02bdfc59de71b5a5",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "STATUS out",
        "mode": "link",
        "links": [
            "fbc5efde2c447eda"
        ],
        "x": 1950,
        "y": 300,
        "wires": [],
        "l": true
    },
    {
        "id": "d34a8c1fd2cc4320",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 670,
        "y": 220,
        "wires": []
    },
    {
        "id": "515386b6b0d01893",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Load 5 seconds after Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 300,
        "y": 1120,
        "wires": [
            [
                "b846bc1605dae821"
            ]
        ]
    },
    {
        "id": "b846bc1605dae821",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim request",
        "func": "// RV-C Address Claim - Send Initial Claim\n// Generates a persistent unique ID, selects an address, and broadcasts the\n// ADDRESS_CLAIMED message (DGN EE00h) to claim the address.\n\n// --- Step 1: Handle Manual Reset Command (if triggered) ---\nif (msg.topic === \"reset_device_id\") {\n  // Clear the saved unique ID from persistent storage\n  global.set(\"my_persistent_rvc_id\", null);\n  // Reset the address attempt counter to start fresh\n  context.set(\"address_attempt\", null);\n  node.warn(\"Persistent DEVICE_NAME cleared. Generating a new one and starting claim...\");\n  // By not returning, we allow the script to continue and generate a new ID immediately.\n}\n\n\n// --- Configuration ---\nconst STARTING_ADDRESS = 223;\nconst MIN_ADDRESS = 208;\n\n\n// --- Step 2: Create or Retrieve a Persistent Unique DEVICE_NAME ---\nlet uniqueId = global.get(\"my_persistent_rvc_id\");\n\nif (!uniqueId) {\n  // No ID found, so generate a new one.\n  const randomSerial = Math.floor(Math.random() * 0x1FFFFF);\n  const randomSerialHex = randomSerial.toString(16).padStart(6, '0').toUpperCase();\n  uniqueId = \"8000000000\" + randomSerialHex;\n\n  // Save this new ID to the global context for future use.\n  global.set(\"my_persistent_rvc_id\", uniqueId);\n  //node.warn(\"Generated and saved a new persistent DEVICE_NAME: \" + uniqueId);\n}\nconst DEVICE_NAME = uniqueId;\n\n\n// --- Step 3: Select an Address to Claim ---\nconst usedAddresses = new Set(flow.get(\"used_addresses\") || []);\nlet addressToTry = context.get(\"address_attempt\") || STARTING_ADDRESS;\n\nif (msg.topic === \"address_claim_retry\") {\n  addressToTry--;\n  node.warn(`Lost address conflict. Trying next address: ${addressToTry}`);\n}\n\nwhile (usedAddresses.has(addressToTry) && addressToTry >= MIN_ADDRESS) {\n  addressToTry--;\n  node.warn(`Address ${addressToTry + 1} is known to be in use, skipping to ${addressToTry}`);\n}\n\nif (addressToTry < MIN_ADDRESS) {\n  node.error(`Exhausted all addresses in the valid range (${STARTING_ADDRESS}-${MIN_ADDRESS}). Address claiming failed.`);\n  flow.set(\"claim_in_progress\", false);\n  return null;\n}\n\ncontext.set(\"address_attempt\", addressToTry);\n\n\n// --- Step 4: Build and Send the Claim Message ---\nconst DGN = \"EE00\";\nconst priority = 6;\nconst canIdNum = (priority << 26) | (parseInt(DGN, 16) << 8) | addressToTry;\nconst canIdHex = canIdNum.toString(16).padStart(8, '0').toUpperCase();\nconst dataPayload = DEVICE_NAME;\nconst canMessage = `${canIdHex}#${dataPayload}`;\n\nflow.set(\"claiming_address\", addressToTry);\nflow.set(\"claim_in_progress\", true);\nflow.set(\"our_device_name\", DEVICE_NAME);\n\nmsg.payload = canMessage;\nmsg.topic = \"can/send\";\nmsg.claiming_address = addressToTry;\n\nnode.log(`Attempting to claim address ${addressToTry} (0x${addressToTry.toString(16).toUpperCase()})`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 1120,
        "wires": [
            [
                "55071115a3fe7c2c",
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "55071115a3fe7c2c",
        "type": "delay",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 850,
        "y": 1200,
        "wires": [
            [
                "6423c433e099d2a5"
            ]
        ]
    },
    {
        "id": "4e46ba83df00a31b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim monitor",
        "func": "// RV-C Address Claim Monitor Function\n// Assumes it ONLY receives decoded ADDRESS_CLAIMED messages (DGN EE00)\n// Compares device NAMEs to determine winner in case of conflict\n\nconst claimInProgress = flow.get(\"claim_in_progress\");\nif (!claimInProgress) {\n    return null; // Not in the claiming process\n}\n\nconst claimingAddress = flow.get(\"claiming_address\");\nconst ourDeviceName = flow.get(\"our_device_name\");\nconst competitorName = msg.payload.dataPayload.toUpperCase();\nconst sourceAddressInt = parseInt(msg.payload.sourceAddress, 16);\n\n// Check if a message is for the same address we are trying to claim\nif (sourceAddressInt === claimingAddress) {\n\n    // *** NEW CHECK ***\n    // First, verify this isn't our own message being echoed back.\n    // If the NAMEs are identical, it's our own claim. Ignore it and let the timer run.\n    if (competitorName === ourDeviceName) {\n        // This is our own message, not a real conflict.\n        return null;\n    }\n    // *** END OF NEW CHECK ***\n\n    // If we get here, it's a real conflict from a different device.\n    node.warn(`Address ${claimingAddress} conflict detected!`);\n    node.warn(`Our NAME: ${ourDeviceName}, Competitor NAME: ${competitorName}`);\n\n    // Compare NAMEs - Lower numerical value wins\n    const ourNameValue = BigInt(\"0x\" + ourDeviceName);\n    const competitorNameValue = BigInt(\"0x\" + competitorName);\n\n    if (ourNameValue < competitorNameValue) {\n        // WE WIN\n        node.warn(`We WIN the conflict. Continuing to claim address ${claimingAddress}`);\n        return null;\n    } else {\n        // WE LOSE\n        node.warn(`We LOSE the conflict. Cancelling timer and trying next address.`);\n        flow.set(\"claim_in_progress\", false);\n\n        const retryMsg = { topic: \"address_claim_retry\" };\n        const resetTimerMsg = { reset: true };\n\n        return [retryMsg, resetTimerMsg];\n    }\n}\n\n// If we reach here, it's a claim for a different address, so ignore it.\nreturn null;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1200,
        "wires": [
            [
                "b846bc1605dae821"
            ],
            [
                "55071115a3fe7c2c"
            ]
        ]
    },
    {
        "id": "45414bacecada477",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "ADDRESS_CLAIMED",
        "mode": "link",
        "links": [
            "f01db5ebc3ae2e18"
        ],
        "x": 1980,
        "y": 420,
        "wires": [],
        "l": true
    },
    {
        "id": "f01db5ebc3ae2e18",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "ADDRESS_CLAIMED",
        "links": [
            "45414bacecada477"
        ],
        "x": 260,
        "y": 1200,
        "wires": [
            [
                "4e46ba83df00a31b"
            ]
        ],
        "l": true
    },
    {
        "id": "a2334b77d3764815",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 1650,
        "y": 1120,
        "wires": [],
        "l": true
    },
    {
        "id": "6423c433e099d2a5",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim success",
        "func": "// RV-C Address Claim Success Function\n// Called after 250ms timer expires - finalizes address claim if no conflict lost\n// Reference: RV-C Spec Section 3.3.2 - Source Address Claiming\n//\n// IMPORTANT: This does NOT send a second ADDRESS_CLAIMED message.\n// We already sent ADDRESS_CLAIMED at the start of the process.\n// Success = 250ms timer expires without losing a conflict.\n\n// Get the address we were trying to claim when this timer started\nconst claimedAddress = msg.claiming_address;\n\nif (claimedAddress === undefined || claimedAddress === null) {\n    node.error(\"No address to claim - timer message missing claiming_address\");\n    return null;\n}\n\n// Check if this timer is still valid (claim hasn't been cancelled by monitor)\nconst claimInProgress = flow.get(\"claim_in_progress\");\nif (!claimInProgress) {\n    // Claim was cancelled during the 250ms window (we lost a conflict)\n    node.warn(`Timer expired for address ${claimedAddress}, but claim was cancelled - ignoring`);\n    return null;\n}\n\n// Verify we're still trying to claim the same address\nconst currentClaimingAddress = flow.get(\"claiming_address\");\nif (currentClaimingAddress !== claimedAddress) {\n    node.warn(`Timer expired for address ${claimedAddress}, but we're now trying ${currentClaimingAddress} - ignoring stale timer`);\n    return null;\n}\n\n// SUCCESS! No conflict detected during the 250ms monitoring window\n// Store the claimed address to global context\nglobal.set(\"rvc_source_address\", claimedAddress);\n\n// Clear claiming flags\nflow.set(\"claim_in_progress\", false);\nflow.set(\"claiming_address\", null);\nflow.set(\"our_device_name\", null);\n\n//node.warn(`Address stored to global.rvc_source_address: ${claimedAddress}`);\n\n// Start poll\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1200,
        "wires": [
            [
                "a2334b77d3764815",
                "73abad3deeed31e8",
                "695ef0ed6d78a244",
                "3f5eb271f702c8f3",
                "1e244bad0304bb74"
            ]
        ]
    },
    {
        "id": "8f99241c9a1cfbde",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "AQUAHOT",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1950,
        "y": 480,
        "wires": []
    },
    {
        "id": "1e93f7b73c40091a",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2250,
        "y": 820,
        "wires": [
            [
                "38606e245b70b98e"
            ]
        ]
    },
    {
        "id": "38606e245b70b98e",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecoded\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2520,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "d0150fd6556514e6",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Unique otherwise",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecoded = flow.get(\"uniqueDecoded\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dataPayload);\n\n// Check if it's a new unique message\nif (!uniqueDecoded.includes(newMsgStr)) {\n    uniqueDecoded.push(newMsgStr);\n    flow.set(\"uniqueDecoded\", uniqueDecoded);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 880,
        "wires": [
            [
                "8f7381d08bf2b8a8"
            ]
        ]
    },
    {
        "id": "8f7381d08bf2b8a8",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "New Unique Dgn",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2530,
        "y": 880,
        "wires": []
    },
    {
        "id": "1ac6e0fa1cbb3852",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out: Retain FALSE",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 730,
        "y": 500,
        "wires": []
    },
    {
        "id": "74329f13cbbc528a",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out: Retain FALSE",
        "links": [
            "a2334b77d3764815",
            "6aa079d768e1571c"
        ],
        "x": 270,
        "y": 500,
        "wires": [
            [
                "1ac6e0fa1cbb3852",
                "0e65ff3bc0a0795c"
            ]
        ],
        "l": true
    },
    {
        "id": "73abad3deeed31e8",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll dc_dimmer_3",
        "func": "// Generates an RV-C \"Request\" message to poll all lights for their status.\n// DGN EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FEDA).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for DC_DIMMER_STATUS_3 (1FEDA), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"DAFE01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll Lights] Sending global request for light status. CAN: ${msg.payload}`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 1200,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "695ef0ed6d78a244",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll locks",
        "func": "// Generates an RV-C \"Request\" message to poll all locks for their status.\n// DGN 18EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FEE5).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for LOCK_STATUS (1FEE5), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"E5FE01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll Locks] Sending global request for lock status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 1240,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "3f5eb271f702c8f3",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll shades",
        "func": "// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254; // 0xFE\nconst PRIORITY = 6;\nconst REQUESTED_DGN = \"01FEDE\"; // The DGN for WINDOW_SHADE_CONTROL_STATUS\nconst BROADCAST_ADDRESS = 255;  // The destination address for a global request (0xFF)\n\n// --- Logic ---\n\n// 1. Build the data payload\n// The payload is the DGN being requested, sent in 3-byte little-endian format.\n// The remaining 5 bytes are padded with 0xFF.\nconst requestedDgnInt = parseInt(REQUESTED_DGN, 16);\nconst dataPayloadBytes = new Uint8Array(8);\ndataPayloadBytes.fill(0xFF); // Pad the entire payload with 0xFF first\ndataPayloadBytes[0] = requestedDgnInt & 0xFF;         // Byte 1: DE\ndataPayloadBytes[1] = (requestedDgnInt >> 8) & 0xFF;  // Byte 2: FE\ndataPayloadBytes[2] = (requestedDgnInt >> 16) & 0xFF; // Byte 3: 01\nconst dataPayloadHex = Array.from(dataPayloadBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n// 2. Determine the PGN for the request message itself\n// A J1939 request PGN is 0xEA00. The destination address is placed in the second byte.\nconst requestPgn = 0xEA00 | BROADCAST_ADDRESS; // This results in 0xEAFF\n\n// 3. Construct the full 29-bit CAN ID from its parts\n// Formula: (Priority << 26) | (PGN << 8) | Source Address\nconst canIdInt = (PRIORITY << 26) | (requestPgn << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 4. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayloadHex.toUpperCase()}`;\n\n// node.warn(`[Poll Shades] Sending global request for shade status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 1280,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "1e244bad0304bb74",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Clear unique values",
        "mode": "link",
        "links": [
            "21799a7e71f6c5b4",
            "54c6beb1daaa00bb",
            "84e908d542084d74",
            "99381e18a0d5f318",
            "b9f27aaa32da92c0",
            "d192b275aac0824e",
            "e8b62c33eab8e3ac",
            "893d80d1125057e8"
        ],
        "x": 1400,
        "y": 1400,
        "wires": [],
        "l": true
    },
    {
        "id": "07b8bcce03f19e8f",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Device discovery",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1110,
        "y": 1300,
        "wires": [
            [
                "73abad3deeed31e8",
                "695ef0ed6d78a244",
                "3f5eb271f702c8f3",
                "1e244bad0304bb74",
                "d3cc901dd2fbd359",
                "ba0c52ff61838986"
            ]
        ]
    },
    {
        "id": "b2cbbdbaab1fc227",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "081183d6c363e792",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2250,
        "y": 280,
        "wires": [
            [
                "f96e5b3b013a2b8f"
            ]
        ]
    },
    {
        "id": "f96e5b3b013a2b8f",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "081183d6c363e792",
        "name": "Reset function",
        "func": "flow.set(\"uniqueCommand\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2520,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "03744ec33f2e6776",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Unique COMMAND",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueCommand = flow.get(\"uniqueCommand\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgn);\n\n// Check if it's a new unique message\nif (!uniqueCommand.includes(newMsgStr)) {\n    uniqueCommand.push(newMsgStr);\n    flow.set(\"uniqueCommand\", uniqueCommand);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 360,
        "wires": [
            [
                "bc59e15bf069f17d"
            ]
        ]
    },
    {
        "id": "bc59e15bf069f17d",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "081183d6c363e792",
        "name": "New COMMAND",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2530,
        "y": 340,
        "wires": []
    },
    {
        "id": "463dfbbef66b51c2",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Otherwsie",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 660,
        "wires": []
    },
    {
        "id": "d3cc901dd2fbd359",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll water pump",
        "func": "// Generates an RV-C \"Request\" message to poll water pump for status.\n// DGN 18EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FFB3).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for WATER_PUMP_STATUS (1FFB3), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"B3FB01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll Water Pump] Sending global request for water pump status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 1320,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "ba0c52ff61838986",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll autofill",
        "func": "// Generates an RV-C \"Request\" message to poll autofill for status.\n// DGN 18EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FFB1).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for AUTOFILL_STATUS (1FFB1), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"B1FB01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll AutoFill] Sending global request for autofill status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 1360,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "17b175c97c0551d4",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "Reset Proprietary",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2260,
        "y": 460,
        "wires": [
            [
                "9f47dc231ecd50cd"
            ]
        ]
    },
    {
        "id": "9f47dc231ecd50cd",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "Reset function",
        "func": "flow.set(\"uniqueProprietary\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2520,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "5968e8ee034f8751",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "New Proprietary",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2520,
        "y": 520,
        "wires": []
    },
    {
        "id": "3d5ce3e925ee2f04",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Unique Proprietary",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueProprietary = flow.get(\"uniqueProprietary\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgn);\n\n// Check if it's a new unique message\nif (!uniqueProprietary.includes(newMsgStr)) {\n    uniqueProprietary.push(newMsgStr);\n    flow.set(\"uniqueProprietary\", uniqueProprietary);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 540,
        "wires": [
            [
                "5968e8ee034f8751"
            ]
        ]
    },
    {
        "id": "c4216c430d06083f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "DC_DIMMER_COMMAND",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2000,
        "y": 200,
        "wires": []
    },
    {
        "id": "0e65ff3bc0a0795c",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 460,
        "wires": []
    },
    {
        "id": "9e9b11b9441e51db",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/climate/+/set_mode",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 240,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "54cd7e4a8959a77c",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/climate/+/set_preset_mode",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 300,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "32add109922d428a",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "can/raw",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 100,
        "wires": []
    },
    {
        "id": "802228bc8d89d80a",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "black",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "a2d2ed96ff4615f9",
        "type": "function",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${type}_${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 160,
        "wires": [
            [
                "d38c75bc1474be23"
            ]
        ]
    },
    {
        "id": "d38c75bc1474be23",
        "type": "link out",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 630,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "abd1e06a1927df6d",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "switch",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "58",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 200,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "68c09ec9b9f984fd",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "floor_heat_1_schedule",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 360,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "da1b195a794a61f2",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "fan",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "switch_48",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 540,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "356ca3617c50f06b",
        "type": "function",
        "z": "222c995b7790b8de",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 380,
        "wires": [
            [
                "d38c75bc1474be23",
                "578d3f3784c2f9d1"
            ]
        ]
    },
    {
        "id": "578d3f3784c2f9d1",
        "type": "debug",
        "z": "222c995b7790b8de",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 380,
        "wires": []
    },
    {
        "id": "4c36d204a0dcb38f",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "floor_heat_2_schedule",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 420,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "45cd9bd685e09007",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "floor_heat_3_schedule",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 480,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "c6f1577708bfe9cd",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "switch",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "floor_heat_3_schedule",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 600,
        "wires": [
            []
        ]
    }
]