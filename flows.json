[
    {
        "id": "b3d80c5dc947ec88",
        "type": "tab",
        "label": "Home Assistant",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3470febb2cd6e952",
        "type": "tab",
        "label": "Switches",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7f95345534f00358",
        "type": "tab",
        "label": "Tanks and Batteries",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3e5f038a4f5a8b9a",
        "type": "tab",
        "label": "Status Decode",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "292e70a6ba25b323",
        "type": "tab",
        "label": "Config",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "222c995b7790b8de",
        "type": "tab",
        "label": "Delete HA Entity",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ee904ab46f56578e",
        "type": "tab",
        "label": "HomeKit",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "9cfcca5efde78052",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "RVC Spec",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7e609140970f546c",
            "74c7e4a6cc2508eb",
            "cd670f6465b6374b",
            "c78420a075d43408"
        ],
        "x": 74,
        "y": 39,
        "w": 852,
        "h": 82
    },
    {
        "id": "aea9d97e0563bd83",
        "type": "group",
        "z": "b3d80c5dc947ec88",
        "name": "Home Assistant message encoding",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a37da245aba53b96",
            "a3b957142479c075",
            "85de1b537d9b8b35",
            "6aa079d768e1571c",
            "89946e1c7a570ed0",
            "927786f8f3f21075",
            "c19a749621bffe0c",
            "58d9a2789e4a1391",
            "8a5082e9f29a8080",
            "d367ea017bd41347",
            "778971897d2a7fdc"
        ],
        "x": 94,
        "y": 99,
        "w": 1172,
        "h": 282
    },
    {
        "id": "3c819b7900145438",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "MQTT",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "cacf35b859af22a9",
            "e7ae35364ce60f3f",
            "f658418a7b9b4857",
            "b86f82e84d961549",
            "64c5e5cfd4382453",
            "2110ea4d0b85f784",
            "958fed9f12301f59",
            "32add109922d428a",
            "c6fd91cf9695813b",
            "4ad3b304d4f1e27b",
            "d34a8c1fd2cc4320",
            "a922fdb6b43bbced",
            "4f33fad10d85b69d",
            "51910a93d572e95c",
            "982faa37c0038bf4",
            "74329f13cbbc528a",
            "1ac6e0fa1cbb3852"
        ],
        "x": 74,
        "y": 299,
        "w": 1392,
        "h": 442
    },
    {
        "id": "f09f79586501cb0b",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "CAN message routing",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "8d7d5d3ea117cf79",
            "ac47ce53a9fc3f21",
            "698efabc308fece6",
            "a16ce99da6a2a88f",
            "2e131d4d25819c93",
            "a2dad25eb05117f7",
            "fc66c16576e28548",
            "c6fb02a17f709e08",
            "2fcbc4d630144362",
            "a6594a9464d8fe4e",
            "9dd6a98018824be9",
            "02bdfc59de71b5a5",
            "37b11a996fc2757e",
            "45414bacecada477",
            "5f6336442bfb9808",
            "8f99241c9a1cfbde",
            "01b53bba61cb7227"
        ],
        "x": 74,
        "y": 779,
        "w": 1438,
        "h": 688
    },
    {
        "id": "0b18891888586798",
        "type": "group",
        "z": "ee904ab46f56578e",
        "name": "HomeKit",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "faf503bfdd48519a",
            "107cff91357ef6da",
            "9104e3fb894083ee",
            "b7cc11c60eb56768",
            "7c30a3bc33fa2315",
            "9428382ab57f3f5d",
            "1bf17ae955275cf0"
        ],
        "x": 84,
        "y": 279,
        "w": 1022,
        "h": 202
    },
    {
        "id": "eb51c1f2d0d389d1",
        "type": "group",
        "z": "3e5f038a4f5a8b9a",
        "name": "Reset unique STATUS list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ffd5bc5ca5695602",
            "09640adb1fd08fbb",
            "b797e5a52b6db5b4",
            "48e6dda2b2d9575e"
        ],
        "x": 14,
        "y": 619,
        "w": 492,
        "h": 142
    },
    {
        "id": "067069104a82b459",
        "type": "group",
        "z": "7f95345534f00358",
        "name": "Tanks",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d4ef1d361f084b58",
            "61f4573c56915577",
            "6dc4171b23e1cc2a",
            "f9f5381eb086c0e6",
            "b6d3cd6d2e6fbc66",
            "240af7ca01aa2041",
            "6ce8faba3e3bd3c3",
            "cc621fc63e303e1b"
        ],
        "x": 134,
        "y": -1,
        "w": 992,
        "h": 408
    },
    {
        "id": "e2dc4d711cc9dc94",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Switches",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d3a13b531babee66",
            "7313d7c724d31538",
            "f0083147745c8366",
            "48e3b18cb440da52",
            "25162d774c052102",
            "32ec19602e928185",
            "3d64b0d9c219e954"
        ],
        "x": 54,
        "y": 99,
        "w": 1092,
        "h": 348
    },
    {
        "id": "5d1ecae7ac09586c",
        "type": "group",
        "z": "7f95345534f00358",
        "name": "Batteries",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ea29386f9f8682bc",
            "663120adc5ec254f",
            "2c1151c97bb185f2",
            "b6d90639c3fc122c",
            "86fa588a8393f6de",
            "d68c2206e3379850",
            "a1c297b2d8067a0b",
            "64578fa414def60a"
        ],
        "x": 134,
        "y": 539,
        "w": 1132,
        "h": 308
    },
    {
        "id": "04e375b0c463df72",
        "type": "group",
        "z": "222c995b7790b8de",
        "name": "Delete Home Assistant Entity",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "802228bc8d89d80a",
            "a2d2ed96ff4615f9",
            "d38c75bc1474be23",
            "abd1e06a1927df6d"
        ],
        "x": 94,
        "y": 79,
        "w": 672,
        "h": 162
    },
    {
        "id": "852597de52df1703",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "DC_DIMMER_COMMAND_2",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a1beccb1a2803ca5",
            "44947b512cb27b5b",
            "25e6f74b216427e5",
            "000b002344662b42",
            "c769cda1070372b2",
            "a0885c7cb1a0a88f",
            "57e45f522fc50a9b",
            "4259c887eedd95ec"
        ],
        "x": 54,
        "y": 499,
        "w": 1238,
        "h": 308
    },
    {
        "id": "8ef86a1c4b59d8e1",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "Claim CAN source address",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "515386b6b0d01893",
            "b846bc1605dae821",
            "55071115a3fe7c2c",
            "4e46ba83df00a31b",
            "f01db5ebc3ae2e18",
            "a2334b77d3764815",
            "6423c433e099d2a5",
            "89f2d386ecc80a69"
        ],
        "x": 74,
        "y": 1519,
        "w": 1392,
        "h": 182
    },
    {
        "id": "ff07f63b9271ea10",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "Discovery",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "97f9cc8db4a66114",
            "8203b055d9149eff",
            "73abad3deeed31e8",
            "c1bf29f13e5e33d8",
            "695ef0ed6d78a244",
            "3f5eb271f702c8f3"
        ],
        "x": 1014,
        "y": 39,
        "w": 752,
        "h": 222
    },
    {
        "id": "9dd6a98018824be9",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique UNKNOWN",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a4028527eb23fa04",
            "092c751dcdd12270",
            "c781b519a9f9b156",
            "eea1641469efb23f"
        ],
        "x": 954,
        "y": 1299,
        "w": 532,
        "h": 142
    },
    {
        "id": "b6d3cd6d2e6fbc66",
        "type": "group",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "bfc3dc28b23b2396",
            "d574ead42dd36caa"
        ],
        "x": 174,
        "y": 299,
        "w": 472,
        "h": 82
    },
    {
        "id": "d68c2206e3379850",
        "type": "group",
        "z": "7f95345534f00358",
        "g": "5d1ecae7ac09586c",
        "name": "Rest unique battery list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7c04541818436246",
            "738718a321d185e7"
        ],
        "x": 174,
        "y": 739,
        "w": 472,
        "h": 82
    },
    {
        "id": "a0885c7cb1a0a88f",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "852597de52df1703",
        "name": "Rest unique light list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "0474640b44c5d2a9",
            "d137fb1314cb498b"
        ],
        "x": 794,
        "y": 699,
        "w": 472,
        "h": 82
    },
    {
        "id": "32ec19602e928185",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "886a33cd8776ba5a",
            "6e2b753c50d28b2b",
            "e8b62c33eab8e3ac"
        ],
        "x": 614,
        "y": 279,
        "w": 472,
        "h": 142
    },
    {
        "id": "01b53bba61cb7227",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Reset unique CAN decode list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "1e93f7b73c40091a",
            "38606e245b70b98e",
            "d0150fd6556514e6",
            "8f7381d08bf2b8a8"
        ],
        "x": 954,
        "y": 1119,
        "w": 532,
        "h": 142
    },
    {
        "id": "481f3f804361a6fd",
        "type": "homekit-bridge",
        "bridgeName": "CoachHomekit",
        "pinCode": "4062-3183",
        "port": "",
        "advertiser": "bonjour-hap",
        "allowInsecureRequest": false,
        "manufacturer": "NRCHKB",
        "model": "1.7.3",
        "serialNo": "Default Serial Number",
        "firmwareRev": "1.7.3",
        "hardwareRev": "1.7.3",
        "softwareRev": "1.7.3",
        "bind": "",
        "bindType": "str",
        "customMdnsConfig": false,
        "mdnsMulticast": true,
        "mdnsInterface": "",
        "mdnsPort": "",
        "mdnsIp": "",
        "mdnsTtl": "",
        "mdnsLoopback": true,
        "mdnsReuseAddr": true,
        "allowMessagePassthrough": true
    },
    {
        "id": "80727e60a251c36c",
        "type": "mqtt-broker",
        "name": "Mosquitto",
        "broker": "127.0.0.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a37da245aba53b96",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Decode HA MQTT",
        "func": "const topicParts = msg.topic.split('/');\nif (topicParts.length !== 4) {\n    return null; // unexpected format\n}\n\nconst entityType = topicParts[1];\nconst entityId = topicParts[2];\nconst command = (typeof msg.payload === 'string') ? msg.payload.toUpperCase() : msg.payload;\n\n// Extract entity prefix from entityId (e.g., \"pump_1\" -> \"pump\")\nconst entityIdParts = entityId.split('_');\nconst entityPrefix = entityIdParts.length > 1 ? entityIdParts[0] : entityId;\n\n// Create routing key for switch node\n// For most entity types, routing key is just the entity type\n// Special handling for switches to differentiate sub-types (switch, pump, autofill, etc.)\nlet routingKey = entityType;\nif (entityType === 'switch') {\n    routingKey = `${entityType}_${entityPrefix}`;  // switch_switch, switch_pump, etc.\n}\n\nmsg.entityType = entityType;\nmsg.entityId = entityId;\nmsg.entityPrefix = entityPrefix;\nmsg.routingKey = routingKey;\nmsg.command = command;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 220,
        "wires": [
            [
                "89946e1c7a570ed0"
            ]
        ]
    },
    {
        "id": "a3b957142479c075",
        "type": "link in",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA in",
        "links": [
            "64c5e5cfd4382453"
        ],
        "x": 170,
        "y": 220,
        "wires": [
            [
                "a37da245aba53b96"
            ]
        ],
        "l": true
    },
    {
        "id": "85de1b537d9b8b35",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode switch command",
        "func": "// Encodes an HA switch command to an RV-C DC_DIMMER_COMMAND_2\n// Outputs in standard CAN bus format for a 'can/send' topic.\n//\n// Handles DC_DIMMER_STATUS_3 entities (prefix: \"switch\")\n// Uses \"Set Level\" command for reliable ON/OFF control\n\n// --- Configuration ---\nconst RVC_COMMAND = 0x00; // 0x00 is \"Set Level\" command\nconst LEVEL_ON = 200;     // 200 = 100% brightness\nconst LEVEL_OFF = 0;      // 0 = 0% brightness (OFF)\nconst NON_GROUP = 0xFF;   // 0xFF = Non-group command\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254; // Use claimed address or fallback to Null address\nconst PRIORITY = 6;       // Standard priority for commands\nconst DGN = \"1FEDB\";      // DC_DIMMER_COMMAND_2\n\n// Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/); // Fixed regex to properly capture digits\n\nif (!match) {\n    node.warn(`[encode_switch_command] Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`[encode_switch_command] Parsed instance number \"${instance}\" is invalid (must be 1-250).`);\n    return null;\n}\n\n// Determine the desired level from the payload\nlet desiredLevel;\nconst state = String(msg.payload).toUpperCase();\n\nif (state === \"ON\") {\n    desiredLevel = LEVEL_ON;\n} else if (state === \"OFF\") {\n    desiredLevel = LEVEL_OFF;\n} else {\n    node.warn(`[encode_switch_command] Invalid payload: \"${msg.payload}\". Expected \"ON\" or \"OFF\".`);\n    return null;\n}\n\n// Build the 8-byte data payload per RV-C DC_DIMMER_COMMAND_2 specification\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = instance;        // Byte 1: Instance Number (1-250)\ndataBytes[1] = NON_GROUP;       // Byte 2: Group (0xFF = non-group command)\ndataBytes[2] = desiredLevel;    // Byte 3: Desired Level/Brightness (0-200)\ndataBytes[3] = RVC_COMMAND;     // Byte 4: Command (0x00 = Set Level)\ndataBytes[4] = 0xFF;            // Byte 5: Delay/Duration (0xFF = Not Available)\ndataBytes[5] = 0x00;            // Byte 6: Interlock (0x00 = No Interlock)\ndataBytes[6] = 0x00;            // Byte 7: Ramp Time (0x00 = Instant)\ndataBytes[7] = 0xFF;            // Byte 8: Reserved (0xFF = Not Available)\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// Construct the CAN ID\n// CAN ID format: Priority (3 bits) + DGN (18 bits) + Source Address (8 bits)\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\n// Debug output\nnode.warn(`[encode_switch_command] Instance ${instance} → ${state} (Level=${desiredLevel}) | CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 140,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "6aa079d768e1571c",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 1130,
        "y": 200,
        "wires": [],
        "l": true
    },
    {
        "id": "89946e1c7a570ed0",
        "type": "switch",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "",
        "property": "routingKey",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "switch_switch",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "switch_pump",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "switch_shade",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "switch_lock",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "switch_autofill",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 6,
        "x": 550,
        "y": 220,
        "wires": [
            [
                "85de1b537d9b8b35"
            ],
            [
                "927786f8f3f21075"
            ],
            [
                "58d9a2789e4a1391"
            ],
            [
                "8a5082e9f29a8080"
            ],
            [
                "d367ea017bd41347"
            ],
            [
                "778971897d2a7fdc"
            ]
        ]
    },
    {
        "id": "927786f8f3f21075",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode pump command",
        "func": "// Encodes an HA water pump command to an RV-C WATER_PUMP_COMMAND\n// Outputs in standard CAN bus format for a 'can/send' topic.\n//\n// Handles WATER_PUMP_STATUS entities (prefix: \"pump\")\n// Supports basic ON/OFF control with Auto/Manual modes\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254; // Use claimed address or fallback to Null address\nconst PRIORITY = 6;       // Standard priority for commands\nconst DGN = \"1FFB2\";      // WATER_PUMP_COMMAND\n\n// 1. Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/); // Fixed regex to properly capture digits\n\nif (!match) {\n    node.warn(`[encode_pump_command] Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`[encode_pump_command] Parsed instance number \"${instance}\" is invalid (must be 1-250).`);\n    return null;\n}\n\n// 2. Parse the HA command (simplified for basic ON/OFF)\nlet pumpCommand = 0xFF; // Default: Not Available\nlet pumpMode = 0xFF;    // Default: Not Available\nlet pumpSpeed = 0xFF;   // Default: Not Available\n\nconst state = String(msg.payload).toUpperCase();\n\nswitch (state) {\n    case 'ON':\n    case 'START':\n        pumpCommand = 1; // Start\n        pumpMode = 1;    // Auto mode\n        pumpSpeed = 200; // 100% speed (200 = 100% in RV-C)\n        break;\n    case 'OFF':\n    case 'STOP':\n        pumpCommand = 0; // Stop\n        pumpMode = 0;    // Off mode\n        pumpSpeed = 0;   // 0% speed\n        break;\n    default:\n        node.warn(`[encode_pump_command] Invalid payload: \"${msg.payload}\". Expected \"ON\" or \"OFF\".`);\n        return null;\n}\n\n// 3. Build the 8-byte data payload per RV-C WATER_PUMP_COMMAND specification\nconst dataBytes = new Array(8).fill(0xFF);\n\ndataBytes[0] = instance;    // Byte 1: Instance Number (1-250)\ndataBytes[1] = pumpCommand; // Byte 2: Command (0=stop, 1=start)\ndataBytes[2] = pumpMode;    // Byte 3: Mode (0=off, 1=auto, 2=manual)\ndataBytes[3] = pumpSpeed;   // Byte 4: Speed (0-200, where 200 = 100%)\ndataBytes[4] = 0xFF;        // Byte 5: Desired Pressure LSB (Not Available)\ndataBytes[5] = 0xFF;        // Byte 6: Desired Pressure MSB (Not Available)\ndataBytes[6] = 0xFF;        // Byte 7: Timer/Flow Rate LSB (Not Available)\ndataBytes[7] = 0xFF;        // Byte 8: Timer/Flow Rate MSB (Not Available)\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID\n// CAN ID format: Priority (3 bits) + DGN (18 bits) + Source Address (8 bits)\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\n// Debug output\nnode.warn(`[encode_pump_command] Instance ${instance} → ${state} (Cmd=${pumpCommand}, Mode=${pumpMode}) | CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 180,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "c19a749621bffe0c",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA command",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 140,
        "wires": []
    },
    {
        "id": "58d9a2789e4a1391",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode shade command",
        "func": "// Encodes simple ON/OFF HA commands to RV-C WINDOW_SHADE_CONTROL_COMMAND\n// ON = Raise/Open shade, OFF = Lower/Close shade\n// Outputs in standard CAN bus format for 'can/send' topic.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEDF\";\n\n// 1. Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/);\n\nif (!match) {\n    node.warn(`Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`Parsed instance number \"${instance}\" is invalid.`);\n    return null;\n}\n\n// 2. Parse the simple ON/OFF command\nlet command;\nlet motorDuty = 100; // Use 100% motor duty for simple operation\nlet duration = 255; // Continuous until stopped\n\nconst haCommand = (typeof msg.payload === 'string') ? msg.payload.toUpperCase() : String(msg.payload).toUpperCase();\n\nswitch (haCommand) {\n    case 'ON':\n    case 'UP':\n    case 'OPEN':\n        command = 0x81; // Forward (Raise/Open)\n        break;\n    case 'OFF':\n    case 'DOWN':\n    case 'CLOSE':\n        command = 0x41; // Reverse (Lower/Close)\n        break;\n    default:\n        node.warn('Unknown shade command: ' + haCommand);\n        return null;\n}\n\n// 3. Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xFF);\n\ndataBytes[0] = instance;            // Instance Number\ndataBytes[1] = 0xFF;                // Group (Non-group command)\ndataBytes[2] = motorDuty;           // Motor Duty Cycle (0-100%)\ndataBytes[3] = command;             // Command (0x81=Forward, 0x41=Reverse)\ndataBytes[4] = duration;            // Duration (255=Continuous)\ndataBytes[5] = 0x00;                // Interlock (No Interlock)\ndataBytes[6] = 0xFF;                // Byte 7 (Not Available)\ndataBytes[7] = 0xFF;                // Byte 8 (Not Available)\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 220,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "8a5082e9f29a8080",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode lock command",
        "func": "// Encodes simple ON/OFF HA commands to RV-C LOCK_COMMAND (DOOR_COMMAND)\n// ON = Unlock, OFF = Lock\n// Outputs in standard CAN bus format for 'can/send' topic.\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEE4\";\n\n// 1. Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/);\n\nif (!match) {\n    node.warn(`Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`Parsed instance number \"${instance}\" is invalid.`);\n    return null;\n}\n\n// 2. Parse the simple ON/OFF command\nlet lockCommand;\n\nconst haCommand = (typeof msg.payload === 'string') ? msg.payload.toUpperCase() : String(msg.payload).toUpperCase();\n\nswitch (haCommand) {\n    case 'ON':\n    case 'UNLOCK':\n        lockCommand = 0; // Unlock\n        break;\n    case 'OFF':\n    case 'LOCK':\n        lockCommand = 1; // Lock\n        break;\n    default:\n        node.warn('Unknown lock command: ' + haCommand);\n        return null;\n}\n\n// 3. Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xFF);\n\ndataBytes[0] = instance;            // Instance Number\ndataBytes[1] = lockCommand;         // Lock Command (0=unlock, 1=lock)\ndataBytes[2] = 0;                   // Additional Command (0=no action)\ndataBytes[3] = 0xFF;                // Byte 4 (Not Available)\ndataBytes[4] = 0xFF;                // Byte 5 (Not Available)\ndataBytes[5] = 0xFF;                // Byte 6 (Not Available)\ndataBytes[6] = 0xFF;                // Byte 7 (Not Available)\ndataBytes[7] = 0xFF;                // Byte 8 (Not Available)\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 260,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "d367ea017bd41347",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode autofill command",
        "func": "// Encodes an HA autofill command to an RV-C AUTOFILL_COMMAND\n// Outputs in standard CAN bus format for a 'can/send' topic.\n//\n// Handles AUTOFILL_STATUS entities (prefix: \"autofill\")\n// Supports basic ON/OFF control with Auto/Manual modes\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254; // Use claimed address or fallback to Null address\nconst PRIORITY = 6;       // Standard priority for commands\nconst DGN = \"1FFB0\";      // AUTOFILL_COMMAND\n\n// 1. Parse the instance number from the topic\nconst topicParts = msg.topic.split('/');\nconst entityId = topicParts[2] || \"\";\nconst match = entityId.match(/_(\\d+)$/);\n\nif (!match) {\n    node.warn(`[encode_autofill_command] Could not parse instance number from topic: ${msg.topic}`);\n    return null;\n}\n\nconst instance = parseInt(match[1], 10);\nif (isNaN(instance) || instance < 1 || instance > 250) {\n    node.warn(`[encode_autofill_command] Parsed instance number \"${instance}\" is invalid (must be 1-250).`);\n    return null;\n}\n\n// 2. Parse the HA command (simplified for basic ON/OFF)\nlet autofillCommand = 0xFF; // Default: Not Available\nlet operatingMode = 0xFF;   // Default: Not Available\n\nconst state = String(msg.payload).toUpperCase();\n\nswitch (state) {\n    case 'ON':\n    case 'START':\n    case 'AUTO':\n        autofillCommand = 1; // Enable/Start\n        operatingMode = 1;   // Auto mode\n        break;\n    case 'OFF':\n    case 'STOP':\n        autofillCommand = 0; // Disable/Stop\n        operatingMode = 0;   // Off mode\n        break;\n    case 'MANUAL':\n        autofillCommand = 1; // Enable\n        operatingMode = 2;   // Manual mode\n        break;\n    default:\n        node.warn(`[encode_autofill_command] Invalid payload: \"${msg.payload}\". Expected \"ON\", \"OFF\", \"AUTO\", or \"MANUAL\".`);\n        return null;\n}\n\n// 3. Build the 8-byte data payload per RV-C AUTOFILL_COMMAND specification\nconst dataBytes = new Array(8).fill(0xFF);\n\ndataBytes[0] = instance;        // Byte 1: Instance Number (1-250)\ndataBytes[1] = autofillCommand; // Byte 2: Command (0=disable, 1=enable)\ndataBytes[2] = operatingMode;   // Byte 3: Operating Mode (0=off, 1=auto, 2=manual)\ndataBytes[3] = 0xFF;            // Byte 4: Desired Level LSB (Not Available)\ndataBytes[4] = 0xFF;            // Byte 5: Desired Level MSB (Not Available)\ndataBytes[5] = 0xFF;            // Byte 6: Reserved (Not Available)\ndataBytes[6] = 0xFF;            // Byte 7: Reserved (Not Available)\ndataBytes[7] = 0xFF;            // Byte 8: Reserved (Not Available)\n\nconst dataHex = dataBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n\n// 4. Construct the CAN ID\n// CAN ID format: Priority (3 bits) + DGN (18 bits) + Source Address (8 bits)\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 5. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\n// Debug output\nnode.warn(`[encode_autofill_command] Instance ${instance} → ${state} (Cmd=${autofillCommand}, Mode=${operatingMode}) | CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 300,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "d42338ae47d820f3",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "d": true,
        "name": "Decode HA MQTT",
        "func": "const topicParts = msg.topic.split('/');\nif (topicParts.length !== 4) {\n    return null; // unexpected format\n}\n\nconst entityType = topicParts[1];\nconst entityId = topicParts[2];\nconst command = (typeof msg.payload === 'string') ? msg.payload.toUpperCase() : msg.payload;\n\n// Extract entity prefix from entityId (e.g., \"shade_1\" -> \"shade\")\nconst entityIdParts = entityId.split('_');\nconst entityPrefix = entityIdParts.length > 1 ? entityIdParts[0] : entityId;\n\n// Create routing key for switch node: entityType_entityPrefix\nlet routingKey = entityType;\nif (entityType === 'switch' || entityType === 'light' || entityType === 'lock') {\n    routingKey = `${entityType}_${entityPrefix}`;\n}\n\nmsg.entityType = entityType;\nmsg.entityId = entityId;\nmsg.entityPrefix = entityPrefix;\nmsg.routingKey = routingKey;\nmsg.command = command;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "778971897d2a7fdc",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "otherwise",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 340,
        "wires": []
    },
    {
        "id": "d3a13b531babee66",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1010,
        "y": 140,
        "wires": [],
        "l": true
    },
    {
        "id": "7313d7c724d31538",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "switch_types",
        "links": [
            "7af7fb2178a714cf"
        ],
        "x": 150,
        "y": 140,
        "wires": [
            [
                "f0083147745c8366",
                "48e3b18cb440da52"
            ]
        ],
        "l": true
    },
    {
        "id": "f0083147745c8366",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unique switch",
        "func": "/***********************************************************\n * Unified Unique Instance Tracker (Centralized)\n * Tracks unique device instances in a single, resettable list.\n *\n * Expects input msg.payload with:\n * - msg.payload.instance (Number): The device instance ID\n * - msg.payload.dgn_name (String): DGN type for device type detection\n ***********************************************************/\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst dgnName = msg.payload.dgn_name;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\nif (typeof dgnName !== 'string') {\n    node.error(\"Input missing 'dgn_name' (string).\", msg);\n    return null;\n}\n\n// Map DGN to a simple device type (no indicators)\nlet deviceType;\nswitch (dgnName) {\n    case \"DC_DIMMER_STATUS_3\":\n        deviceType = \"switch\";\n        break;\n    case \"WATER_PUMP_STATUS\":\n        deviceType = \"pump\";\n        break;\n    case \"AUTOFILL_STATUS\":\n        deviceType = \"autofill\";\n        break;\n    case \"LOCK_STATUS\":\n        deviceType = \"lock\";\n        break;\n    case \"WINDOW_SHADE_CONTROL_STATUS\":\n        deviceType = \"shade\";\n        break;\n    default:\n        // Stop if the device type is not one we want to create\n        return null;\n}\n\nconst uniqueId = `${deviceType}_${instance}`;\n\nconst contextKey = \"uniqueInstances\";\nlet uniqueInstances = flow.get(contextKey) || [];\n\n// Check if this specific device ID has been seen before\nif (!uniqueInstances.includes(uniqueId)) {\n    // If it's new, add it to the list and save it\n    uniqueInstances.push(uniqueId);\n    flow.set(contextKey, uniqueInstances);\n\n    // Send the message downstream to create the HA entity\n    return {\n        payload: {\n            instance: instance,\n            device_type: deviceType\n        }\n    };\n}\n\n// If it's a duplicate, stop the flow\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 220,
        "wires": [
            [
                "25162d774c052102"
            ]
        ]
    },
    {
        "id": "48e3b18cb440da52",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unified STATUS",
        "func": "/***********************************************************\n * Unified HA Status Updater\n * Handles all switch-type devices: lights, pumps, autofill, shades, locks\n * Routes to appropriate HA switch entities with different prefixes\n *\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The device instance ID\n * - msg.payload.dgn_name (String): DGN type for device type detection\n * - Status field varies by device type:\n *   - DC_DIMMER_STATUS: msg.payload.load_status\n *   - WATER_PUMP_STATUS: msg.payload.operating_state\n *   - AUTOFILL_STATUS: msg.payload.operating_status\n *   - WINDOW_SHADE_CONTROL_STATUS: msg.payload.operating_status or forward_status/reverse_status\n *   - LOCK_STATUS (DOOR_STATUS): msg.payload.lock_status or is_locked/is_unlocked\n ***********************************************************/\n\n// Validate basic input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst dgnName = msg.payload.dgn_name;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof dgnName !== 'string') {\n    node.error(\"Input missing 'dgn_name' (string).\", msg);\n    return null;\n}\n\n// Device type mapping and status field extraction\nlet devicePrefix;\nlet statusValue;\nlet haStatus = \"OFF\"; // Default\n\nswitch (dgnName) {\n    case \"DC_DIMMER_STATUS_1\":\n        devicePrefix = \"switch1\";\n        statusValue = msg.payload.load_status;\n\n        if (typeof statusValue !== 'string') {\n            node.error(`${dgnName} missing 'load_status' (string).`, msg);\n            return null;\n        }\n\n        // DC Dimmer: Check if load_status contains \"Off\"\n        haStatus = statusValue.includes(\"Off\") ? \"OFF\" : \"ON\";\n        break;\n\n    case \"DC_DIMMER_STATUS_2\":\n        devicePrefix = \"switch2\";\n        statusValue = msg.payload.load_status;\n\n        if (typeof statusValue !== 'string') {\n            node.error(`${dgnName} missing 'load_status' (string).`, msg);\n            return null;\n        }\n\n        // DC Dimmer: Check if load_status contains \"Off\"\n        haStatus = statusValue.includes(\"Off\") ? \"OFF\" : \"ON\";\n        break;\n\n    case \"DC_DIMMER_STATUS_3\":\n        devicePrefix = \"switch\";\n        statusValue = msg.payload.load_status;\n\n        if (typeof statusValue !== 'string') {\n            node.error(`${dgnName} missing 'load_status' (string).`, msg);\n            return null;\n        }\n\n        // DC Dimmer: Check if load_status contains \"Off\"\n        haStatus = statusValue.includes(\"Off\") ? \"OFF\" : \"ON\";\n        break;\n\n    case \"WATER_PUMP_STATUS\":\n        devicePrefix = \"pump\";\n        statusValue = msg.payload.operating_state;\n\n        if (typeof statusValue !== 'string') {\n            node.error(\"WATER_PUMP_STATUS missing 'operating_state' (string).\", msg);\n            return null;\n        }\n\n        // Water Pump: Check for active states\n        if (statusValue.includes(\"Running\") ||\n            statusValue.includes(\"On\") ||\n            statusValue.includes(\"Priming\") ||\n            statusValue === \"Self Test\") {\n            haStatus = \"ON\";\n        } else if (statusValue.includes(\"Off\") ||\n                   statusValue.includes(\"Stop\") ||\n                   statusValue === \"Standby\") {\n            haStatus = \"OFF\";\n        } else {\n            // Fault states default to OFF\n            haStatus = \"OFF\";\n        }\n        break;\n\n    case \"AUTOFILL_STATUS\":\n        devicePrefix = \"autofill\";\n        statusValue = msg.payload.operating_status;\n\n        if (typeof statusValue !== 'string') {\n            node.error(\"AUTOFILL_STATUS missing 'operating_status' (string).\", msg);\n            return null;\n        }\n\n        // Autofill: Check for active states (case insensitive)\n        const lowerStatus = statusValue.toLowerCase();\n        if (lowerStatus.includes(\"on\") || lowerStatus.includes(\"auto\")) {\n            haStatus = \"ON\";\n        } else if (lowerStatus.includes(\"off\")) {\n            haStatus = \"OFF\";\n        } else {\n            haStatus = \"OFF\";\n        }\n        break;\n\n    case \"WINDOW_SHADE_CONTROL_STATUS\":\n        devicePrefix = \"shade\";\n\n        // Shade: ON = Up/Open, OFF = Down/Closed\n        // Check operating_status (0-200 representing 0-100%)\n        if (typeof msg.payload.operating_status === 'number') {\n            // Consider shade \"ON\" (up) if position > 50%\n            haStatus = msg.payload.operating_status > 100 ? \"ON\" : \"OFF\";\n        }\n        // Fallback: Check motor direction\n        else if (msg.payload.forward_status) {\n            // Forward = raising/opening\n            const forwardStatus = msg.payload.forward_status;\n            haStatus = (forwardStatus.includes(\"on\") || forwardStatus.includes(\"Forward\")) ? \"ON\" : \"OFF\";\n        }\n        // Default to OFF if no clear status\n        else {\n            haStatus = \"OFF\";\n        }\n        break;\n\n    case \"LOCK_STATUS\":\n    case \"DOOR_STATUS\":\n        devicePrefix = \"lock\";\n\n        // Lock: ON = Unlocked, OFF = Locked\n        // Check boolean flags first\n        if (typeof msg.payload.is_unlocked === 'boolean') {\n            haStatus = msg.payload.is_unlocked ? \"ON\" : \"OFF\";\n        } else if (typeof msg.payload.is_locked === 'boolean') {\n            haStatus = msg.payload.is_locked ? \"OFF\" : \"ON\";\n        }\n        // Check string status\n        else if (typeof msg.payload.lock_status === 'string') {\n            const lockStatusLower = msg.payload.lock_status.toLowerCase();\n            haStatus = lockStatusLower.includes(\"unlocked\") ? \"ON\" : \"OFF\";\n        }\n        // Default to OFF (locked) if no clear status\n        else {\n            haStatus = \"OFF\";\n        }\n        break;\n\n    default:\n        node.error(`Unsupported dgn_name: ${dgnName}`, msg);\n        return null;\n}\n\n// Construct the MQTT topic with appropriate prefix\nconst stateTopic = `homeassistant/switch/${devicePrefix}_${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus; // The payload is just the string \"ON\" or \"OFF\"\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 140,
        "wires": [
            [
                "d3a13b531babee66"
            ]
        ]
    },
    {
        "id": "25162d774c052102",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create Switch",
        "func": "/***********************************************************\n * Unified MQTT Discovery for Home Assistant\n * Creates switch entities for multiple device types with appropriate prefixes\n * Handles switches, pumps, and autofill devices\n *\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The device instance ID\n * - msg.payload.device_type (String): Device type (\"switch\", \"pump\", \"autofill\")\n ***********************************************************/\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst deviceType = msg.payload.device_type;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof deviceType !== 'string') {\n    node.error(\"Input missing 'device_type' (string).\", msg);\n    return null;\n}\n\nconst commandableTypes = [\"switch\", \"pump\", \"autofill\", \"lock\", \"shade\"];\nif (commandableTypes.includes(deviceType)) {\n    // RV-C valid instance range: 1-250\n    // Special values: 251=Error, 252=Not Supported, 253=Out of Range, 254=Reserved, 255=Not Available\n    if (instance < 1 || instance > 250) {\n        // Silently ignore special RV-C status values - these aren't real devices\n        if (instance >= 251 && instance <= 255) {\n            return null;\n        }\n        node.warn(`Instance ${instance} is outside the valid RV-C instance range (1-250) for a ${deviceType}. Entity will not be created.`);\n        return null;\n    }\n}\n\n// Device type configuration with HA component mapping\nlet prefix;\nlet displayPrefix;\nlet icon;\nlet componentType;\n\nswitch (deviceType) {\n    case \"switch\":\n        prefix = \"switch\";\n        displayPrefix = \"Switch\";\n        icon = \"mdi:light-recessed\";\n        componentType = \"switch\";\n        break;\n    case \"pump\":\n        prefix = \"pump\";\n        displayPrefix = \"Pump\";\n        icon = \"mdi:water-pump\";\n        componentType = \"switch\";\n        break;\n    case \"autofill\":\n        prefix = \"autofill\";\n        displayPrefix = \"Autofill\";\n        icon = \"mdi:water-plus\";\n        componentType = \"switch\";\n        break;\n    case \"lock\":\n        prefix = \"lock\";\n        displayPrefix = \"Lock\";\n        icon = \"mdi:lock\";\n        componentType = \"switch\";\n        break;\n    case \"shade\":\n        prefix = \"shade\";\n        displayPrefix = \"Shade\";\n        icon = \"mdi:window-shutter\";\n        componentType = \"switch\";\n        break;\n    default:\n        node.error(`Unsupported device_type: ${deviceType}`, msg);\n        return null;\n}\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\nconst displayName = `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    object_id: entityId,\n    icon: icon,\n\n    // Topics for Home Assistant to use\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n\n    // Define what \"ON\" and \"OFF\" look like\n    payload_on: \"ON\",\n    payload_off: \"OFF\",\n\n    // Device information\n    device: {\n        name: \"RV Link\",\n        manufacturer: \"RV Link\",\n        identifiers: \"rv_link\"\n    }\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\nmsg.entityId = entityId;\nmsg.deviceType = deviceType;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 220,
        "wires": [
            [
                "d3a13b531babee66",
                "3d64b0d9c219e954"
            ]
        ]
    },
    {
        "id": "a1beccb1a2803ca5",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": "Decode DC_DIMMER_COMMAND_2",
        "func": "// === Full Node-RED Function (with all helpers) ===\n\n// Helper Functions\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\nfunction decodeRampTime(value) {\n    if (value === 0) return 0;\n    if (value >= 1 && value <= 250) return parseFloat((value * 0.1).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\nfunction decodeDesiredLevel(value) {\n    if (value >= 0 && value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value >= 230 && value <= 249) return `Scene ${value - 229}`;\n    if (value === 250) return \"Dimmed Memory\";\n    if (value === 251) return \"Master Memory\";\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\nfunction getGroupDetails(value) {\n    if (value === 0xFF) return { type: 'special', description: 'No data' };\n    if (value & 0x80) return { type: 'non-group', description: 'Non-group or Node Group command' };\n    if (value === 0x00) return { type: 'special', description: 'Member of all groups' };\n    const groups = []; const groupBits = value & 0x7F;\n    for (let bit = 0; bit < 7; bit++) { if (!(groupBits & (1 << bit))) { groups.push(bit + 1); } }\n    return { type: 'standard', groups: groups, description: groups.length > 0 ? `Groups: ${groups.join(', ')}` : \"No group membership\" };\n}\nfunction decodeDelayDuration(value) {\n    if (value >= 0 && value <= 240) return `${value} seconds`;\n    if (value >= 241 && value <= 250) return `${value - 236} minutes`;\n    if (value === 255) return \"Continuous\";\n    return \"Invalid\";\n}\nfunction decodeCommand(value) {\n    const commands = { 0: \"Set Level (Delay)\", 1: \"On (Duration)\", 2: \"On (Delay)\", 3: \"Off (Delay)\", 4: \"Stop\", 5: \"Toggle\", 6: \"Memory Off\", 7: \"Save Scene\", 11: \"Ramp Brightness\", 12: \"Ramp Toggle\", 13: \"Ramp Up\", 14: \"Ramp Down\", 15: \"Ramp Up/Down\", 16: \"Ramp Up/Down Toggle\", 21: \"Lock\", 22: \"Unlock\", 31: \"Flash\", 32: \"Flash Momentary\" };\n    return commands[value] || `unknown command: ${value}`;\n}\n\n// Main Decode Function (Updated for July 31, 2025 Spec)\nfunction decodeDcDimmerCommand2Message(dgn, data) {\n    const result = {};\n    if (data.length < 7) return { error: \"Invalid data length for DGN 1FEDBh\" };\n    result.instance = data[0]; // [cite: 269]\n    const groupDetails = getGroupDetails(data[1]); // [cite: 269]\n    result.group_description = groupDetails.description;\n    result.desired_level = decodeDesiredLevel(data[2]); // [cite: 269]\n    result.command = decodeCommand(data[3]); // [cite: 269]\n    result.delay_duration = decodeDelayDuration(data[4]); // \n    const interlockValue = decodeBits(data[5], 0, 1); // \n    const interlocks = { 0: \"No Interlock active\", 1: \"Interlock A\", 2: \"Interlock B\" };\n    result.interlock = interlocks[interlockValue] || \"Invalid\";\n    result.ramp_time = decodeRampTime(data[6]); // \n    return result;\n}\n\n// === Main Logic ===\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(dataPayload.substring(i, i + 2), 16));\n}\n\nlet decodedData;\nif (dgn === '1FEDB') {\n    decodedData = decodeDcDimmerCommand2Message(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\nmsg.payload = { ...incomingPayload, ...decodedData };\ndelete msg.payload.dataPayload;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 640,
        "wires": [
            [
                "000b002344662b42",
                "4259c887eedd95ec",
                "c769cda1070372b2"
            ]
        ]
    },
    {
        "id": "44947b512cb27b5b",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": "DC_DIMMER_COMMAND_2",
        "links": [
            "37b11a996fc2757e"
        ],
        "x": 200,
        "y": 640,
        "wires": [
            [
                "a1beccb1a2803ca5"
            ]
        ],
        "l": true
    },
    {
        "id": "25e6f74b216427e5",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": " DC_DIMMER_COMMAND_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 640,
        "wires": []
    },
    {
        "id": "000b002344662b42",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "payload.instance",
        "x": 810,
        "y": 640,
        "wires": [
            [
                "25e6f74b216427e5"
            ]
        ]
    },
    {
        "id": "c769cda1070372b2",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": "Unique command",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueCommands = flow.get(\"uniqueCommands\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.instance);\n\n// Check if it's a new unique message\nif (!uniqueCommands.includes(newMsgStr)) {\n    uniqueCommands.push(newMsgStr);\n    flow.set(\"uniqueCommands\", uniqueCommands);\n\n    // Create a new msg with only payload\n    return { payload: msg.payload };\n}\n\n// Return nothing if duplicate\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 540,
        "wires": [
            [
                "57e45f522fc50a9b"
            ]
        ]
    },
    {
        "id": "0474640b44c5d2a9",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "a0885c7cb1a0a88f",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 910,
        "y": 740,
        "wires": [
            [
                "d137fb1314cb498b"
            ]
        ]
    },
    {
        "id": "d137fb1314cb498b",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "a0885c7cb1a0a88f",
        "name": "Reset function",
        "func": "flow.set(\"uniqueCommands\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1160,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "57e45f522fc50a9b",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": "command",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 540,
        "wires": []
    },
    {
        "id": "886a33cd8776ba5a",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 730,
        "y": 380,
        "wires": [
            [
                "6e2b753c50d28b2b"
            ]
        ]
    },
    {
        "id": "6e2b753c50d28b2b",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset function",
        "func": "flow.set(\"uniqueInstances\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "4259c887eedd95ec",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "852597de52df1703",
        "name": "debug 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 600,
        "wires": []
    },
    {
        "id": "3d64b0d9c219e954",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1020,
        "y": 220,
        "wires": []
    },
    {
        "id": "e8b62c33eab8e3ac",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset switches",
        "links": [
            "c1bf29f13e5e33d8"
        ],
        "x": 720,
        "y": 320,
        "wires": [
            [
                "6e2b753c50d28b2b"
            ]
        ],
        "l": true
    },
    {
        "id": "f4a9c2be960e7740",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "name": "Create Switch",
        "func": "/***********************************************************\n * Unified MQTT Discovery for Home Assistant\n * Creates switch entities for multiple device types with appropriate prefixes\n * Handles switches, pumps, and autofill devices\n *\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The device instance ID\n * - msg.payload.device_type (String): Device type (\"switch\", \"pump\", \"autofill\")\n ***********************************************************/\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst deviceType = msg.payload.device_type;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof deviceType !== 'string') {\n    node.error(\"Input missing 'device_type' (string).\", msg);\n    return null;\n}\n\nconst commandableTypes = [\"switch\", \"pump\", \"autofill\", \"lock\", \"shade\"];\nif (commandableTypes.includes(deviceType)) {\n    // RV-C valid instance range: 1-250\n    // Special values: 251=Error, 252=Not Supported, 253=Out of Range, 254=Reserved, 255=Not Available\n    if (instance < 1 || instance > 250) {\n        // Silently ignore special RV-C status values - these aren't real devices\n        if (instance >= 251 && instance <= 255) {\n            return null;\n        }\n        node.warn(`Instance ${instance} is outside the valid RV-C instance range (1-250) for a ${deviceType}. Entity will not be created.`);\n        return null;\n    }\n}\n\n// Device type configuration with HA component mapping\nlet prefix;\nlet displayPrefix;\nlet icon;\nlet componentType;\n\nswitch (deviceType) {\n    case \"switch\":\n        prefix = \"switch\";\n        displayPrefix = \"Switch\";\n        icon = \"mdi:light-recessed\";\n        componentType = \"switch\";\n        break;\n    case \"pump\":\n        prefix = \"pump\";\n        displayPrefix = \"Pump\";\n        icon = \"mdi:water-pump\";\n        componentType = \"switch\";\n        break;\n    case \"autofill\":\n        prefix = \"autofill\";\n        displayPrefix = \"Autofill\";\n        icon = \"mdi:water-plus\";\n        componentType = \"switch\";\n        break;\n    case \"lock\":\n        prefix = \"lock\";\n        displayPrefix = \"Lock\";\n        icon = \"mdi:lock\";\n        componentType = \"lock\";\n        break;\n    case \"shade\":\n        prefix = \"shade\";\n        displayPrefix = \"Shade\";\n        icon = \"mdi:window-shutter\";\n        componentType = \"switch\";\n        break;\n    default:\n        node.error(`Unsupported device_type: ${deviceType}`, msg);\n        return null;\n}\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\nconst displayName = `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    object_id: entityId,\n    icon: icon,\n\n    // Topics for Home Assistant to use\n    command_topic: commandTopic,\n    state_topic: stateTopic,\n\n    // Define what \"ON\" and \"OFF\" look like\n    payload_on: \"ON\",\n    payload_off: \"OFF\",\n\n    // Device information\n    device: {\n        name: \"RV Link\",\n        manufacturer: \"RV Link\",\n        identifiers: \"rv_link\"\n    }\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\nmsg.entityId = entityId;\nmsg.deviceType = deviceType;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "9f72e3b3a60b3b8a",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "name": "Unified STATUS",
        "func": "/***********************************************************\n * Unified HA Status Updater\n * Handles DC_DIMMER_STATUS, WATER_PUMP_STATUS, and AUTOFILL_STATUS\n * Routes to appropriate HA switch entities with different prefixes\n *\n * Expects input msg.payload to be an object with:\n * - msg.payload.instance (Number): The device instance ID\n * - msg.payload.dgn_name (String): DGN type for device type detection\n * - Status field varies by device type:\n *   - DC_DIMMER_STATUS: msg.payload.load_status\n *   - WATER_PUMP_STATUS: msg.payload.operating_state\n *   - AUTOFILL_STATUS: msg.payload.operating_status\n ***********************************************************/\n\n// Validate basic input structure\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst dgnName = msg.payload.dgn_name;\n\n// Validate required fields\nif (typeof instance !== 'number') {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof dgnName !== 'string') {\n    node.error(\"Input missing 'dgn_name' (string).\", msg);\n    return null;\n}\n\n// Device type mapping with HA component types and status field extraction\nlet devicePrefix;\nlet componentType;\nlet statusValue;\nlet haStatus = \"OFF\"; // Default\n\nswitch (dgnName) {\n    case \"DC_DIMMER_STATUS_3\":\n        devicePrefix = \"switch\";\n        componentType = \"switch\";\n        statusValue = msg.payload.load_status;\n\n        if (typeof statusValue !== 'string') {\n            node.error(`${dgnName} missing 'load_status' (string).`, msg);\n            return null;\n        }\n\n        // DC Dimmer: Check if load_status contains \"Off\"\n        haStatus = statusValue.includes(\"Off\") ? \"OFF\" : \"ON\";\n        break;\n\n    case \"WATER_PUMP_STATUS\":\n        devicePrefix = \"pump\";\n        componentType = \"switch\";\n        statusValue = msg.payload.operating_state;\n\n        if (typeof statusValue !== 'string') {\n            node.error(\"WATER_PUMP_STATUS missing 'operating_state' (string).\", msg);\n            return null;\n        }\n\n        // Water Pump: Check for active states\n        if (statusValue.includes(\"Running\") ||\n            statusValue.includes(\"On\") ||\n            statusValue.includes(\"Priming\") ||\n            statusValue === \"Self Test\") {\n            haStatus = \"ON\";\n        } else if (statusValue.includes(\"Off\") ||\n            statusValue.includes(\"Stop\") ||\n            statusValue === \"Standby\") {\n            haStatus = \"OFF\";\n        } else {\n            // Fault states default to OFF\n            haStatus = \"OFF\";\n        }\n        break;\n\n    case \"AUTOFILL_STATUS\":\n        devicePrefix = \"autofill\";\n        componentType = \"switch\";\n        statusValue = msg.payload.operating_status;\n\n        if (typeof statusValue !== 'string') {\n            node.error(\"AUTOFILL_STATUS missing 'operating_status' (string).\", msg);\n            return null;\n        }\n\n        // Autofill: Check for active states (case insensitive)\n        const lowerStatus = statusValue.toLowerCase();\n        if (lowerStatus.includes(\"on\") || lowerStatus.includes(\"auto\")) {\n            haStatus = \"ON\";\n        } else if (lowerStatus.includes(\"off\")) {\n            haStatus = \"OFF\";\n        } else {\n            haStatus = \"OFF\";\n        }\n        break;\n\n    default:\n        node.error(`Unsupported dgn_name: ${dgnName}`, msg);\n        return null;\n}\n\n// Construct the MQTT topic with appropriate component type\nconst stateTopic = `homeassistant/${componentType}/${devicePrefix}_${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus; // The payload is just the string \"ON\" or \"OFF\"\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "d4ef1d361f084b58",
        "type": "link out",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 990,
        "y": 140,
        "wires": [],
        "l": true
    },
    {
        "id": "61f4573c56915577",
        "type": "link in",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "TANK_STATUS",
        "links": [
            "45ae070eafc9a732"
        ],
        "x": 240,
        "y": 140,
        "wires": [
            [
                "6dc4171b23e1cc2a",
                "240af7ca01aa2041",
                "cc621fc63e303e1b"
            ]
        ],
        "l": true
    },
    {
        "id": "6dc4171b23e1cc2a",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Tank Level",
        "func": "/***********************************************************\n * HA Tank Status Updater\n * Takes a JSON payload as input and sends tank level updates\n * to the correct Home Assistant MQTT state topic for tank sensor entities.\n * Expects input msg.payload to be an object with:\n * - msg.payload.tank_type (String): The type of the tank (\"fresh\", \"gray\", \"black\", \"lpg\").\n * - msg.payload.level_percentage (Number): Tank level 0-100%.\n * - msg.payload.relative_level (String): Availability indicator.\n ***********************************************************/\n\n// Validate input and availability\nif (msg.payload?.relative_level === \"Not Available\" || msg.relative_level === \"Not Available\") {\n    return null; // Stop the flow if level data not available\n}\n\n// Extract values with fallback support (preserving original working logic)\nconst tankType = msg.payload?.tank_type ?? msg.tank_type;\nconst levelPercentage = msg.payload?.level_percentage ?? msg.level_percentage;\n\n// Validate tank type\nif (!tankType) {\n    node.error(\"Input missing 'tank_type'.\", msg);\n    return null; // Stop the flow\n}\n\n// Validate level percentage\nif (typeof levelPercentage !== 'number') {\n    node.error(\"Input missing 'level_percentage' (number).\", msg);\n    return null; // Stop the flow\n}\n\n// Ensure level is within valid range\nconst level = Math.max(0, Math.min(100, Math.round(levelPercentage)));\n\n// Create the state topic for this tank instance\nconst stateTopic = `homeassistant/sensor/tank_${tankType}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = level; // The payload is the numeric level percentage\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\n// Add debug information for troubleshooting\nmsg.debug_info = {\n    original_tank_type: tankType,\n    calculated_level: level,\n    raw_level_percentage: levelPercentage,\n    raw_relative_level: msg.payload?.relative_level ?? msg.relative_level\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 140,
        "wires": [
            [
                "d4ef1d361f084b58"
            ]
        ]
    },
    {
        "id": "f9f5381eb086c0e6",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Create Tank",
        "func": "/***********************************************************\n * Tank MQTT Discovery for Home Assistant\n * Creates a sensor entity based on tank type input.\n * Expects msg.payload to be a tank type string (e.g., \"fresh\", \"gray\", \"black\", \"lpg\").\n * Example Input: msg.payload = \"fresh\"\n * Resulting Entity ID: tank_fresh\n ***********************************************************/\n\n// Accept numeric instance ID from unique_tank.js\nif (typeof msg.payload !== 'number') {\n    node.error(\"Input payload must be a number (instance ID).\", msg);\n    return null;\n}\n\nconst instanceId = msg.payload;\n\n// Map instance ID to single-word tank type and display name\nconst tankTypeMap = {\n    0: { type: \"fresh\", name: \"Fresh Water\" },\n    1: { type: \"gray\", name: \"Gray Water\" },\n    2: { type: \"black\", name: \"Black Water\" },\n    3: { type: \"lpg\", name: \"LPG\" },\n    4: { type: \"fuel\", name: \"Fuel\" },\n    5: { type: \"hot\", name: \"Hot Water\" },\n    6: { type: \"hydraulic\", name: \"Hydraulic Fluid\" },\n    7: { type: \"livewell\", name: \"Live Well\" },\n    8: { type: \"ballast\", name: \"Ballast\" },\n    9: { type: \"oil\", name: \"Oil\" },\n    10: { type: \"coolant\", name: \"Coolant\" },\n    11: { type: \"def\", name: \"DEF\" },\n    12: { type: \"air\", name: \"Air\" },\n    13: { type: \"fresh2\", name: \"Fresh Water 2\" },\n    14: { type: \"gray2\", name: \"Gray Water 2\" },\n    15: { type: \"black2\", name: \"Black Water 2\" },\n    251: { type: \"error\", name: \"Error\" },\n    252: { type: \"notsupported\", name: \"Not Supported\" },\n    253: { type: \"outofrange\", name: \"Out of Range\" },\n    254: { type: \"reserved\", name: \"Reserved\" },\n    255: { type: \"notavailable\", name: \"Not Available\" }\n};\n\nconst tankInfo = tankTypeMap[instanceId] || { type: \"other\", name: `Unknown Tank ${instanceId}` };\nconst tankType = tankInfo.type;\nconst displayName = tankInfo.name;\n\nconst entityId = `tank_${tankType}`;\nconst componentType = \"sensor\";\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    object_id: entityId,\n    icon: \"mdi:water-percent\",\n\n    // Topics for Home Assistant to use\n    state_topic: stateTopic,\n\n    // Sensor configuration\n    unit_of_measurement: \"%\",\n    value_template: \"{{ value | float }}\", // Ensure it's parsed as a number\n\n    device: {\n        name: \"RV Link\",\n        manufacturer: \"RV Link\",\n        identifiers: \"rv_link\"\n    }\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 220,
        "wires": [
            [
                "d4ef1d361f084b58",
                "6ce8faba3e3bd3c3"
            ]
        ]
    },
    {
        "id": "bfc3dc28b23b2396",
        "type": "inject",
        "z": "7f95345534f00358",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 290,
        "y": 340,
        "wires": [
            [
                "d574ead42dd36caa"
            ]
        ]
    },
    {
        "id": "d574ead42dd36caa",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset function",
        "func": "flow.set(\"uniqueTanks\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "ea29386f9f8682bc",
        "type": "link out",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1130,
        "y": 580,
        "wires": [],
        "l": true
    },
    {
        "id": "663120adc5ec254f",
        "type": "link in",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS",
        "links": [
            "bff245b2ca47ef79"
        ],
        "x": 260,
        "y": 580,
        "wires": [
            [
                "a1c297b2d8067a0b"
            ]
        ],
        "l": true
    },
    {
        "id": "2c1151c97bb185f2",
        "type": "function",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Battery Level",
        "func": "/***********************************************************\n * HA Battery Status Updater\n * Takes a JSON payload as input and sends battery voltage updates\n * to the correct Home Assistant MQTT state topic for battery sensor entities.\n * Expects input msg.payload to be an object with:\n * - msg.payload.dc_instance_id (Number): The numeric battery instance ID.\n * - msg.payload.dc_voltage_V (Number): Battery voltage in volts.\n ***********************************************************/\n\n// Validate voltage availability - if it's \"Not Available\" string, skip\nif (msg.payload?.dc_voltage_V === \"Not Available\" || msg.dc_voltage_V === \"Not Available\") {\n    return null; // Stop the flow if voltage data not available\n}\n\n// Extract values with fallback support\nconst dcInstanceId = msg.payload?.dc_instance_id ?? msg.dc_instance_id;\nconst voltageValue = msg.payload?.dc_voltage_V ?? msg.dc_voltage_V;\n\n// Validate DC instance ID\nif (dcInstanceId === undefined || dcInstanceId === null) {\n    node.error(\"Input missing 'dc_instance_id'.\", msg);\n    return null; // Stop the flow\n}\n\n// Map instance ID to entity suffix (must match create_battery.js)\nconst batteryMap = {\n    0: \"0\",\n    1: \"house\",\n    2: \"chassis\",\n    3: \"house2\",\n    4: \"generator\"\n};\n\n// For instances 5-250, use numeric suffix\nlet entitySuffix;\nif (dcInstanceId >= 5 && dcInstanceId <= 250) {\n    entitySuffix = dcInstanceId.toString();\n} else {\n    entitySuffix = batteryMap[dcInstanceId] || dcInstanceId.toString();\n}\n\n// Validate voltage value\nif (typeof voltageValue !== 'number') {\n    node.error(\"Input missing 'dc_voltage_V' (number).\", msg);\n    return null; // Stop the flow\n}\n\n// Ensure voltage is within reasonable range and round to 2 decimal places\nconst voltage = Math.max(0, Math.min(50, Math.round(voltageValue * 100) / 100));\n\n// Create the state topic for this battery instance\nconst stateTopic = `homeassistant/sensor/battery_${entitySuffix}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = voltage; // The payload is the numeric voltage value\nmsg.retain = true; // Retain the status so HA shows the correct state after a restart\n\n// Add debug information for troubleshooting\nmsg.debug_info = {\n    dc_instance_id: dcInstanceId,\n    entity_suffix: entitySuffix,\n    calculated_voltage: voltage,\n    raw_voltage_V: voltageValue\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 580,
        "wires": [
            [
                "ea29386f9f8682bc"
            ]
        ]
    },
    {
        "id": "b6d90639c3fc122c",
        "type": "function",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Unique batteries",
        "func": "// Retrieve existing battery instances from flow context, or initialize as empty array\nlet uniqueBatteries = flow.get(\"uniqueBatteries\") || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.dc_instance_id;\n\n// Check if this instance ID has been seen before\nif (!uniqueBatteries.includes(instanceId)) {\n    uniqueBatteries.push(instanceId);\n    flow.set(\"uniqueBatteries\", uniqueBatteries);\n\n    // Pass the instance ID to create_battery.js\n    return { payload: instanceId };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 660,
        "wires": [
            [
                "86fa588a8393f6de"
            ]
        ]
    },
    {
        "id": "86fa588a8393f6de",
        "type": "function",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Create Battery",
        "func": "/***********************************************************\n * Battery MQTT Discovery for Home Assistant\n * Creates a sensor entity based on battery instance input.\n * Expects msg.payload to be a number (e.g., 1) or DC instance string (e.g., \"Main House Battery Bank\").\n * Example Input: msg.payload = 1 or msg.payload = \"Main House Battery Bank\"\n * Resulting Entity ID: battery_1, battery_2, etc.\n ***********************************************************/\n\n// Accept numeric instance ID from unique_batteries.js\nif (typeof msg.payload !== 'number') {\n    node.error(\"Input payload must be a number (instance ID).\", msg);\n    return null;\n}\n\nconst instanceId = msg.payload;\n\n// Map instance ID to entity suffix and display name per RV-C specification\nconst batteryMap = {\n    0: { suffix: \"0\", name: \"Invalid\" },\n    1: { suffix: \"house\", name: \"Main House Battery\" },\n    2: { suffix: \"chassis\", name: \"Chassis Battery\" },\n    3: { suffix: \"house2\", name: \"Secondary House Battery\" },\n    4: { suffix: \"generator\", name: \"Generator Battery\" }\n};\n\n// For instances 5-250, use generic \"battery_X\" naming\nlet entitySuffix;\nlet displayName;\nif (instanceId >= 5 && instanceId <= 250) {\n    entitySuffix = instanceId.toString();\n    displayName = `Battery ${instanceId}`;\n} else {\n    const batteryInfo = batteryMap[instanceId] || { suffix: instanceId.toString(), name: `Unknown Battery ${instanceId}` };\n    entitySuffix = batteryInfo.suffix;\n    displayName = batteryInfo.name;\n}\n\nconst entityId = `battery_${entitySuffix}`;\nconst componentType = \"sensor\";\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    object_id: entityId,\n    icon: \"mdi:home-battery-outline\",\n\n    // Topics for Home Assistant to use\n    state_topic: stateTopic,\n\n    // Sensor configuration\n    unit_of_measurement: \"V\",\n    device_class: \"voltage\",\n    value_template: \"{{ value | float | round(2) }}\",\n\n    device: {\n        name: \"RV Link\",\n        manufacturer: \"RV Link\",\n        identifiers: \"rv_link\"\n    }\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = JSON.stringify(payload);\nmsg.retain = true; // IMPORTANT: Ensures HA rediscovers on restart\n\n// (Optional) Add helper properties for debugging or downstream use\nmsg.stateTopic = stateTopic;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 660,
        "wires": [
            [
                "ea29386f9f8682bc"
            ]
        ]
    },
    {
        "id": "7c04541818436246",
        "type": "inject",
        "z": "7f95345534f00358",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 290,
        "y": 780,
        "wires": [
            [
                "738718a321d185e7"
            ]
        ]
    },
    {
        "id": "738718a321d185e7",
        "type": "function",
        "z": "7f95345534f00358",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset function",
        "func": "flow.set(\"uniqueBatteries\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 780,
        "wires": [
            []
        ]
    },
    {
        "id": "a1c297b2d8067a0b",
        "type": "switch",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DC_SOURCE_STATUS_1",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 450,
        "y": 580,
        "wires": [
            [
                "2c1151c97bb185f2",
                "b6d90639c3fc122c"
            ],
            []
        ]
    },
    {
        "id": "64578fa414def60a",
        "type": "comment",
        "z": "7f95345534f00358",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS types",
        "info": "DC_SOURCE_STATUS_1: This is the most basic status message. It provides the fundamental electrical readings: \n\nDC Voltage and DC Current. A positive current value indicates the source is discharging (power flowing out), while a negative value indicates it is charging.\n\nDC_SOURCE_STATUS_2: This message adds thermal and capacity information. It reports the \n\nSource Temperature, the battery's State of Charge (SOC) as a percentage, and the estimated Time Remaining until the battery is either full or empty.\n\nDC_SOURCE_STATUS_3: This provides more nuanced details about the battery's long-term health and capacity. It includes the \n\nState of Health (SOH), Capacity Remaining in amp-hours, and Relative Capacity, which is the state of charge adjusted for the state of health.\n\n\nDC_SOURCE_STATUS_5: This message is for high-precision measurement. It reports the \n\nDC Voltage with 0.001 V precision, allowing for more accurate remote voltage sensing without needing dedicated wires.",
        "x": 920,
        "y": 800,
        "wires": []
    },
    {
        "id": "240af7ca01aa2041",
        "type": "function",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "Unique tanks",
        "func": "// Retrieve existing tank instances from flow context, or initialize as empty array\nlet uniqueTanks = flow.get(\"uniqueTanks\") || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (!uniqueTanks.includes(instanceId)) {\n    uniqueTanks.push(instanceId);\n    flow.set(\"uniqueTanks\", uniqueTanks);\n\n    // Pass the instance ID to create_tank.js\n    return { payload: instanceId };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 220,
        "wires": [
            [
                "f9f5381eb086c0e6"
            ]
        ]
    },
    {
        "id": "6ce8faba3e3bd3c3",
        "type": "debug",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 950,
        "y": 220,
        "wires": []
    },
    {
        "id": "cc621fc63e303e1b",
        "type": "debug",
        "z": "7f95345534f00358",
        "g": "067069104a82b459",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 40,
        "wires": []
    },
    {
        "id": "9f88f215f3f07227",
        "type": "switch",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DIGITAL_INPUT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WATER_PUMP_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AUTOFILL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WINDOW_SHADE_CONTROL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "LOCK_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "TANK_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DC_SOURCE_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_AMBIENT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FLOOR_HEAT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FURNACE_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "GENERATOR_DEMAND_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ATS_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "CHARGER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHARGER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "INVERTER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_DC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AC_LOAD_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ATS_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "SOLAR_EQUALIZATION_CONFIGURATION_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_2",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 28,
        "x": 420,
        "y": 220,
        "wires": [
            [],
            [
                "9e8e5609c54fec82"
            ],
            [
                "96c3c21a4dd0b9bd"
            ],
            [
                "4a6d57460d64c76f"
            ],
            [
                "3b2f348b9326267c"
            ],
            [
                "eb3524b2b7bf51e5"
            ],
            [
                "2e5425d73a166c9b"
            ],
            [
                "010c5119a7e833b2"
            ],
            [
                "ccec30ad0f32bbdf"
            ],
            [
                "ae9f041c9cd36bb9"
            ],
            [
                "1bb521d55aeb5eba"
            ],
            [
                "cd9d55c23ebcee86"
            ],
            [
                "d76a4a48e1beaed6"
            ],
            [
                "6b27f0f99ea11a72"
            ],
            [
                "f82e60f4adb5e60b"
            ],
            [
                "e5d61c5724c6ed1b"
            ],
            [
                "bacdea9854675b01"
            ],
            [
                "f171dcbe8b5d2e05"
            ],
            [
                "b2bda5ef5e68c98d"
            ],
            [
                "cb64b7a9a87f03cc"
            ],
            [
                "9621acf15d833362"
            ],
            [
                "b91d72f6d383c0d6"
            ],
            [
                "c38d48059f463772"
            ],
            [
                "a0357de00b26b002"
            ],
            [
                "0ecfccb41b17f21b"
            ],
            [
                "1b079a5b225e1552"
            ],
            [
                "f945d56c437bfb38"
            ],
            [
                "b797e5a52b6db5b4"
            ]
        ]
    },
    {
        "id": "96c3c21a4dd0b9bd",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AUTOFILL_STATUS",
        "func": "// AUTOFILL_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes AUTOFILL_STATUS messages per RV-C specification\n// Handles automatic tank filling system status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === AUTOFILL_STATUS Specific Decoders ===\n\nfunction decodeOperatingStatus(value) {\n    // Operating status from bits 0-1 of byte 0\n    const states = {\n        0: \"AutoFill off\",\n        1: \"AutoFill on\"\n    };\n    return states[value] || `Unknown Status ${value}`;\n}\n\nfunction decodeValveStatus(value) {\n    // Valve status from bits 2-3 of byte 0\n    const states = {\n        0: \"Diverter valve closed\",\n        1: \"Valve open\"\n    };\n    return states[value] || `Unknown Valve Status ${value}`;\n}\n\nfunction decodeLastOperation(value) {\n    // Last operation from bits 4-7 of byte 0\n    const operations = {\n        0: \"Still running\",\n        1: \"Successful fill\",\n        2: \"Fill timed out\",\n        3: \"Fill manually aborted\",\n        4: \"Fill aborted due to error\"\n    };\n    return operations[value] || `Unknown Operation ${value}`;\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeAutofillMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AUTOFILL_STATUS\"\n    };\n\n    // Instance is not provided for AutoFill\n    result.instance = 1;\n\n    // Decode byte 0 based on RV-C spec\n    if (data.length > 0) {\n        const byte0 = data[0];\n\n        // Extract bit fields from byte 0\n        const operatingStatus = decodeBits(byte0, 0, 1);\n        const valveStatus = decodeBits(byte0, 2, 3);\n        const lastOperation = decodeBits(byte0, 4, 7);\n\n        result.operating_status = decodeOperatingStatus(operatingStatus);\n        result.valve_status = decodeValveStatus(valveStatus);\n        result.last_operation = decodeLastOperation(lastOperation);\n\n        // Raw bit values for debugging\n        result.raw_operating_status = operatingStatus;\n        result.raw_valve_status = valveStatus;\n        result.raw_last_operation = lastOperation;\n        result.raw_byte_0 = byte0;\n    }\n\n    // Add convenience fields\n    result.autofill_active = result.operating_status && result.operating_status.includes(\"on\");\n    result.valve_open = result.valve_status && result.valve_status.includes(\"open\");\n    result.has_error = result.last_operation && result.last_operation.includes(\"error\");\n    result.fill_successful = result.last_operation && result.last_operation.includes(\"successful\");\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the AUTOFILL_STATUS message\nconst decodedData = decodeAutofillMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 100,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "19307edfe4e5bd84",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 940,
        "wires": []
    },
    {
        "id": "b2bda5ef5e68c98d",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_AC_STATUS",
        "func": "// CHARGER_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes CHARGER_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC input status for battery chargers (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_AC_STATUS Specific Decoders ===\n\nfunction decodeChargerACInstance(value) {\n    // Charger AC instance interpretation per RV-C spec\n    // For chargers, this typically indicates the AC input line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    // Special handling for 0xFF (all bits set) - typically means \"Not Available\"\n    if (value === 255) {\n        return {\n            faults: \"No Faults\",\n            open_ground: false,\n            open_neutral: false,\n            reverse_polarity: false,\n            ground_current_fault: false,\n            any_fault: false\n        };\n    }\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeChargerACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.charging_capable = result.ac_available && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_AC_STATUS message\nconst decodedData = decodeChargerACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 940,
        "wires": [
            [
                "19307edfe4e5bd84"
            ]
        ]
    },
    {
        "id": "91cac903d306591a",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 1060,
        "wires": []
    },
    {
        "id": "9621acf15d833362",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_AC_STATUS",
        "func": "// INVERTER_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC output status for inverters (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_AC_STATUS Specific Decoders ===\n\nfunction decodeInverterACInstance(value) {\n    // Inverter AC instance interpretation per RV-C spec\n    // For inverters, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeInverterACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active = result.rms_voltage !== \"Not Available\" &&\n                             typeof result.rms_voltage === 'number' &&\n                             result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.inverter_loaded = result.rms_current !== \"Not Available\" &&\n                            typeof result.rms_current === 'number' &&\n                            result.rms_current > 0.1; // Some current flow\n\n    result.inverter_available = !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_AC_STATUS message\nconst decodedData = decodeInverterACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1060,
        "wires": [
            [
                "91cac903d306591a"
            ]
        ]
    },
    {
        "id": "9e8e5609c54fec82",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WATER_PUMP_STATUS",
        "func": "// WATER_PUMP_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes WATER_PUMP_STATUS messages per RV-C specification\n// Handles water pump operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === WATER_PUMP_STATUS Specific Decoders ===\n\nfunction decodeWaterPumpInstance(value) {\n    // Water pump instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Water pump operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Running\",\n        3: \"Priming\",\n        4: \"Self Test\",\n        5: \"Fault\",\n        6: \"Maintenance Required\",\n        7: \"Pressure Switch Open\",\n        8: \"Low Voltage\",\n        9: \"High Temperature\",\n        10: \"Dry Run Protection\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodePumpCommand(value) {\n    // Pump command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Auto\",\n        3: \"Manual\",\n        4: \"Prime\",\n        5: \"Test\",\n        6: \"Reset Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodePressure(value) {\n    // Pressure in kPa (0.5 kPa resolution)\n    if (value <= 500) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5 kPa per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFlowRate(value) {\n    // Flow rate in liters per minute (0.1 L/min resolution)\n    if (value <= 6500) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1 L/min per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrent(value) {\n    // Current in amperes (0.05A resolution)\n    // Handle special values first\n    if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    } else if (value <= 500) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodePumpSpeed(value) {\n    // Pump speed as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 0) {\n        return \"Standby\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Pump Running\");\n    if (value & 0x02) statusBits.push(\"Pressure OK\");\n    if (value & 0x04) statusBits.push(\"Flow Detected\");\n    if (value & 0x08) statusBits.push(\"Auto Mode\");\n    if (value & 0x10) statusBits.push(\"Prime Mode\");\n    if (value & 0x20) statusBits.push(\"Overtemperature\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overcurrent\",\n        2: \"Overvoltage\",\n        3: \"Undervoltage\",\n        4: \"Overtemperature\",\n        5: \"Dry Run\",\n        6: \"Pressure Switch Fault\",\n        7: \"Motor Fault\",\n        8: \"Communication Error\",\n        9: \"Sensor Fault\",\n        10: \"Flow Sensor Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeWaterPumpMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"WATER_PUMP_STATUS\"\n    };\n\n    // Decode based on water pump format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = data[0];\n        result.instance_name = decodeWaterPumpInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Command\n        result.command = decodePumpCommand(data[2]);\n\n        // Byte 3: Pump Speed\n        result.pump_speed = decodePumpSpeed(data[3]);\n\n        // Byte 4: Current\n        result.current = decodeCurrent(data[4]);\n\n        // Bytes 5-6: Pressure (uint16, little-endian)\n        const pressureRaw = data[5] | (data[6] << 8);\n        result.pressure = decodePressure(pressureRaw);\n\n        // Byte 7: System Status\n        if (data.length > 7) {\n            result.system_status = decodeSystemStatus(data[7]);\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_command = data[2];\n        result.raw_pump_speed = data[3];\n        result.raw_current = data[4];\n        result.raw_pressure = pressureRaw;\n        if (data.length > 7) {\n            result.raw_system_status = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.pump_running = result.operating_state && result.operating_state.includes(\"Running\");\n    result.pump_active = result.operating_state &&\n        (result.operating_state.includes(\"Running\") ||\n            result.operating_state.includes(\"Priming\") ||\n            result.operating_state.includes(\"On\"));\n    result.pump_available = result.operating_state &&\n        !result.operating_state.includes(\"Fault\") &&\n        !result.operating_state.includes(\"Error\") &&\n        result.operating_state !== \"Not Available\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the WATER_PUMP_STATUS message\nconst decodedData = decodeWaterPumpMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 40,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "b9d5913b9730b3e0",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_AMBIENT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 460,
        "wires": []
    },
    {
        "id": "1bb521d55aeb5eba",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_AMBIENT_STATUS",
        "func": "// THERMOSTAT_AMBIENT_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_AMBIENT_STATUS messages per RV-C specification\n// Handles ambient temperature and humidity sensors\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_AMBIENT_STATUS Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value <= 250) {\n        return \"Out of Range\"; // Values 201-250\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeHumidity(value) {\n    // Humidity as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDewPoint(value, isCelsius = false) {\n    // Dew point temperature with same encoding as ambient temperature\n    return decodeTemperature(value, isCelsius);\n}\n\nfunction decodeAirQuality(value) {\n    // Air quality index\n    const qualityLevels = {\n        0: \"Good\",\n        1: \"Moderate\",\n        2: \"Unhealthy for Sensitive\",\n        3: \"Unhealthy\",\n        4: \"Very Unhealthy\",\n        5: \"Hazardous\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return qualityLevels[value] || `Unknown Quality ${value}`;\n}\n\nfunction decodeSensorStatus(value) {\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 251) {\n        return \"Error\";\n    }\n\n    // Sensor status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Temperature Valid\");\n    if (value & 0x02) statusBits.push(\"Humidity Valid\");\n    if (value & 0x04) statusBits.push(\"Dew Point Valid\");\n    if (value & 0x08) statusBits.push(\"Air Quality Valid\");\n    if (value & 0x10) statusBits.push(\"Sensor Calibrated\");\n    if (value & 0x20) statusBits.push(\"Sensor Fault\");\n    if (value & 0x40) statusBits.push(\"Low Battery\");\n    if (value & 0x80) statusBits.push(\"Communication Error\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_AMBIENT_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'ambient temperature' || param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name.includes('humidity')) {\n            return decodeHumidity(value);\n        }\n        if (param.name === 'dew point' || param.name.includes('dew')) {\n            return decodeDewPoint(value);\n        }\n        if (param.name === 'air quality' || param.name.includes('quality')) {\n            return decodeAirQuality(value);\n        }\n        if (param.name === 'sensor status' || param.name.includes('status')) {\n            return decodeSensorStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatAmbientMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_AMBIENT_STATUS\"\n    };\n\n    // Decode based on THERMOSTAT_AMBIENT_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[1]);\n\n        // Byte 2: Humidity\n        result.humidity = decodeHumidity(data[2]);\n\n        // Byte 3: Dew Point\n        result.dew_point = decodeDewPoint(data[3]);\n\n        // Byte 4: Air Quality Index\n        result.air_quality = decodeAirQuality(data[4]);\n\n        // Byte 5: Sensor Status\n        result.sensor_status = decodeSensorStatus(data[5]);\n\n        // Bytes 6-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_ambient_temperature = data[1];\n        result.raw_humidity = data[2];\n        result.raw_dew_point = data[3];\n        result.raw_air_quality = data[4];\n        result.raw_sensor_status = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    if (result.ambient_temperature !== undefined && typeof result.ambient_temperature === 'number') {\n        result.temperature_fahrenheit = parseFloat(((result.ambient_temperature * 9 / 5) + 32).toFixed(1));\n    }\n\n    result.sensor_available = result.instance !== \"Not Available\" &&\n        result.ambient_temperature !== \"Not Available\";\n\n    result.humidity_available = typeof result.humidity === 'number';\n    result.air_quality_available = result.air_quality !== \"Not Available\" &&\n        result.air_quality !== \"Not Supported\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_AMBIENT_STATUS message\nconst decodedData = decodeThermostatAmbientMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 460,
        "wires": [
            [
                "b9d5913b9730b3e0"
            ]
        ]
    },
    {
        "id": "aefff6ed9ffdb709",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "FLOOR_HEAT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 520,
        "wires": []
    },
    {
        "id": "cd9d55c23ebcee86",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FLOOR_HEAT_STATUS",
        "func": "// FLOOR_HEAT_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes FLOOR_HEAT_STATUS messages per RV-C specification\n// Handles floor heating system control and status\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === FLOOR_HEAT_STATUS Specific Decoders ===\n\nfunction decodeFloorHeatInstance(value) {\n    // Floor heat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Heating\",\n        3: \"Standby\",\n        4: \"Test\",\n        5: \"Fault\",\n        6: \"Maintenance Required\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeHeatingLevel(value) {\n    // Heating level as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding for FLOOR_HEAT_STATUS uint16 values\n    // RV-C spec: 0.03125°C resolution with -273°C offset\n    // Special cases: 0 = Not Available, very low values likely invalid\n    if (value === 0) {\n        return \"Not Available\";\n    } else if (value <= 65530) {\n        const tempK = value * 0.03125; // Kelvin\n        const tempC = tempK - 273.15; // Convert to Celsius\n\n        // Sanity check: if temperature is extremely low, likely invalid data\n        if (tempC < -100) {\n            return \"Invalid Reading\";\n        }\n\n        if (isCelsius) {\n            return parseFloat(tempC.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((tempC * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSetpoint(value, isCelsius = false) {\n    // Temperature setpoint - same format as measured temperature\n    // RV-C spec: 0.03125°C resolution with -273°C offset\n    // Special cases: 0 = Not Available, very low values likely invalid\n    if (value === 0) {\n        return \"Not Available\";\n    } else if (value <= 65530) {\n        const tempK = value * 0.03125; // Kelvin\n        const tempC = tempK - 273.15; // Convert to Celsius\n\n        // Sanity check: if temperature is extremely low, likely invalid data\n        if (tempC < -100) {\n            return \"Invalid Reading\";\n        }\n\n        if (isCelsius) {\n            return parseFloat(tempC.toFixed(1));\n        } else {\n            // Convert to Fahrenheit\n            return parseFloat(((tempC * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTimer(value) {\n    // Timer in minutes\n    if (value <= 600) {\n        return value; // Minutes\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodePower(value) {\n    // Power consumption in watts\n    if (value <= 65000) {\n        return value; // Watts\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 0) {\n        return \"Normal\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Heating Active\");\n    if (value & 0x02) statusBits.push(\"Timer Active\");\n    if (value & 0x04) statusBits.push(\"Temperature Sensor OK\");\n    if (value & 0x08) statusBits.push(\"Overtemperature\");\n    if (value & 0x10) statusBits.push(\"Overcurrent\");\n    if (value & 0x20) statusBits.push(\"Communication Fault\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeFloorHeatMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"FLOOR_HEAT_STATUS\"\n    };\n\n    // Decode based on floor heat format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeFloorHeatInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Heating Level\n        result.heating_level = decodeHeatingLevel(data[2]);\n\n        // Bytes 3-4: Measured Temperature (uint16, little-endian)\n        const tempRaw = data[3] | (data[4] << 8);\n        result.measured_temperature = decodeTemperature(tempRaw);\n\n        // Bytes 5-6: Set Point (uint16, little-endian)\n        const setpointRaw = data[5] | (data[6] << 8);\n        result.set_point = decodeSetpoint(setpointRaw);\n\n        // Byte 7: System Status\n        if (data.length > 7) {\n            result.system_status = decodeSystemStatus(data[7]);\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_heating_level = data[2];\n        result.raw_temperature = tempRaw;\n        result.raw_setpoint = setpointRaw;\n        if (data.length > 7) {\n            result.raw_system_status = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.floor_heat_active = result.operating_state &&\n                              (result.operating_state.includes(\"On\") || result.operating_state.includes(\"Heating\"));\n    result.floor_heat_available = result.system_status &&\n                                 !result.system_status.includes(\"System Fault\") &&\n                                 result.system_status !== \"Not Available\";\n    result.heating_active = result.operating_state && result.operating_state.includes(\"Heating\");\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the FLOOR_HEAT_STATUS message\nconst decodedData = decodeFloorHeatMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 520,
        "wires": [
            [
                "aefff6ed9ffdb709"
            ]
        ]
    },
    {
        "id": "e06ff8584295e0bd",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 400,
        "wires": []
    },
    {
        "id": "ae9f041c9cd36bb9",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_2",
        "func": "// THERMOSTAT_STATUS_2 Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_STATUS_2 messages per RV-C specification\n// Handles thermostat scheduling and advanced features\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_2 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrentScheduleInstance(value) {\n    // Current schedule instance mapping per RV-C spec\n    if (value === 0) {\n        return \"Sleep\";\n    } else if (value === 1) {\n        return \"Wake\";\n    } else if (value === 2) {\n        return \"Away\";\n    } else if (value === 3) {\n        return \"Return\";\n    } else if (value >= 4 && value <= 249) {\n        return `Additional Instance ${value}`;\n    } else if (value === 250) {\n        return \"Storage\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeScheduleInstances(value) {\n    // Number of schedule instances capacity\n    if (value <= 200) {\n        return value; // Direct count\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeReducedNoiseMode(value) {\n    // Reduced noise mode from bit field\n    if (value === 0) {\n        return \"Disabled\";\n    } else if (value === 1) {\n        return \"Enabled\";\n    }\n    return \"Unknown\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_STATUS_2 parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'current schedule instance') {\n            return decodeCurrentScheduleInstance(value);\n        }\n        if (param.name === 'number of schedule instances') {\n            return decodeScheduleInstances(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit' || param.type === 'bit2' || (param.type.startsWith('uint') && param.bit)) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.name === 'reduced noise mode') {\n                return decodeReducedNoiseMode(bitValue);\n            }\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus2Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_2\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_2 format (typically 4-8 bytes)\n    if (data.length > 0) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Current Schedule Instance\n        if (data.length > 1) {\n            result.current_schedule_instance = decodeCurrentScheduleInstance(data[1]);\n        }\n\n        // Byte 2: Number of Schedule Instances\n        if (data.length > 2) {\n            result.number_of_schedule_instances = decodeScheduleInstances(data[2]);\n        }\n\n        // Byte 3: Reduced Noise Mode (bits 0-1)\n        if (data.length > 3) {\n            if (data[3] === 255) {\n                result.reduced_noise_mode = \"Not Available\";\n            } else if (data[3] === 254) {\n                result.reduced_noise_mode = \"Reserved\";\n            } else if (data[3] === 253) {\n                result.reduced_noise_mode = \"Out of Range\";\n            } else {\n                const noiseBits = decodeBits(data[3], 0, 1);\n                result.reduced_noise_mode = decodeReducedNoiseMode(noiseBits);\n            }\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        if (data.length > 1) result.raw_current_schedule = data[1];\n        if (data.length > 2) result.raw_schedule_count = data[2];\n        if (data.length > 3) result.raw_features_byte = data[3];\n        if (data.length > 4) result.raw_byte_4 = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.scheduling_supported = result.number_of_schedule_instances !== \"Not Available\" &&\n        typeof result.number_of_schedule_instances === 'number' &&\n        result.number_of_schedule_instances > 0;\n\n    result.current_mode = result.current_schedule_instance;\n\n    // Determine if in a standard schedule mode\n    if (typeof result.current_schedule_instance === 'string') {\n        const schedule = result.current_schedule_instance.toLowerCase();\n        result.in_sleep_mode = schedule === \"sleep\";\n        result.in_wake_mode = schedule === \"wake\";\n        result.in_away_mode = schedule === \"away\";\n        result.in_return_mode = schedule === \"return\";\n        result.in_standard_schedule = [\"sleep\", \"wake\", \"away\", \"return\"].includes(schedule);\n    }\n\n    result.quiet_mode_active = result.reduced_noise_mode === \"Enabled\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_2 message\nconst decodedData = decodeThermostatStatus2Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 400,
        "wires": [
            [
                "e06ff8584295e0bd"
            ]
        ]
    },
    {
        "id": "6a02f9f3c2b95dcc",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 640,
        "wires": []
    },
    {
        "id": "6b27f0f99ea11a72",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_STATUS",
        "func": "// GENERATOR_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_STATUS messages per RV-C specification\n// Handles generator operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_STATUS Specific Decoders ===\n\nfunction decodeGeneratorInstance(value) {\n    // Generator instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Generator operating state mapping per RV-C specification (extended)\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Cool Down\",\n        5: \"Prime/Pre-Heat\",\n        6: \"Exercise\",\n        7: \"Test\",\n        8: \"Fault\",\n        9: \"Maintenance Required\",\n        10: \"Remote Start\",\n        11: \"Warm Up\",\n        12: \"Load Test\",\n        13: \"Safety Shutdown\",\n        14: \"Over Temperature\",\n        15: \"Low Oil Pressure\",\n        16: \"Over Speed\",\n        17: \"Under Speed\",\n        18: \"Over Voltage\",\n        19: \"Under Voltage\",\n        20: \"Over Current\",\n        21: \"Under Current\",\n        22: \"Auto Start\",\n        23: \"Manual Start\",\n        24: \"Scheduled Start\",\n        25: \"Emergency Start\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeGeneratorCommand(value) {\n    // Generator command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Exercise\",\n        3: \"Test\",\n        4: \"Prime\",\n        5: \"Pre-Heat\",\n        6: \"Reset Fault\",\n        7: \"Clear Maintenance\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Gasoline\",\n        2: \"Diesel\",\n        3: \"Propane\",\n        4: \"Natural Gas\",\n        5: \"Dual Fuel\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeEngineRPM(value) {\n    // Engine RPM (4 RPM resolution)\n    if (value <= 16000) {\n        return value * 4; // 4 RPM per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeRunTime(value) {\n    // Run time in hours (0.1 hour resolution)\n    if (value <= 655300) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1 hour per step\n    } else if (value === 4294967293) {\n        return \"Out of Range\";\n    } else if (value === 4294967294) {\n        return \"Reserved\";\n    } else if (value === 4294967295) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFuelLevel(value) {\n    // Fuel level as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOilPressure(value) {\n    // Oil pressure in kPa (0.5 kPa resolution)\n    if (value <= 500) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5 kPa per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 1.2).toFixed(1)); // 1.2V per step, 0-300V range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 0.4).toFixed(1)); // 0.4A per step, 0-100A range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultStatus(value) {\n    // Fault status bit field\n    const faults = [];\n\n    if (value & 0x01) faults.push(\"Low Oil Pressure\");\n    if (value & 0x02) faults.push(\"High Temperature\");\n    if (value & 0x04) faults.push(\"Low Fuel\");\n    if (value & 0x08) faults.push(\"Overcurrent\");\n    if (value & 0x10) faults.push(\"Overvoltage\");\n    if (value & 0x20) faults.push(\"Undervoltage\");\n    if (value & 0x40) faults.push(\"Service Required\");\n    if (value & 0x80) faults.push(\"System Fault\");\n\n    return faults.length > 0 ? faults.join(\", \") : \"No Faults\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific GENERATOR_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeGeneratorInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeGeneratorCommand(value);\n        }\n        if (param.name === 'fuel type') {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'fuel level') {\n            return decodeFuelLevel(value);\n        }\n        if (param.name === 'oil pressure') {\n            return decodeOilPressure(value);\n        }\n        if (param.name === 'fault status' || param.name === 'faults') {\n            return decodeFaultStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'engine rpm' || param.name === 'rpm') {\n            return decodeEngineRPM(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'run time' || param.name === 'runtime') {\n            return decodeRunTime(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_STATUS\"\n    };\n\n    // Decode based on GENERATOR_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Bytes 3-4: Engine RPM (16-bit, little-endian)\n        const engineRPM = data[3] | (data[4] << 8);\n        result.engine_rpm = decodeEngineRPM(engineRPM);\n\n        // Byte 5: AC Voltage (single byte for generators)\n        result.ac_voltage = decodeACVoltage(data[5]);\n\n        // Byte 6: AC Current (single byte approximation)\n        result.ac_current = decodeACCurrent(data[6]);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_engine_rpm_bytes = [data[3], data[4]];\n        result.raw_ac_voltage = data[5];\n        result.raw_ac_current = data[6];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.generator_running = state === \"running\";\n        result.generator_available = ![\"fault\", \"maintenance required\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_exercising = state === \"exercise\";\n        result.needs_maintenance = state === \"maintenance required\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    // Engine status\n    result.engine_running = typeof result.engine_rpm === 'number' && result.engine_rpm > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_STATUS message\nconst decodedData = decodeGeneratorMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 640,
        "wires": [
            [
                "6a02f9f3c2b95dcc"
            ]
        ]
    },
    {
        "id": "f82e60f4adb5e60b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_AC_STATUS",
        "func": "// GENERATOR_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC output status for generators (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_AC_STATUS Specific Decoders ===\n\nfunction decodeGeneratorACInstance(value) {\n    // Generator AC instance interpretation per RV-C spec\n    // For generators, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active = result.rms_voltage !== \"Not Available\" &&\n                             typeof result.rms_voltage === 'number' &&\n                             result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.generator_loaded = result.rms_current !== \"Not Available\" &&\n                             typeof result.rms_current === 'number' &&\n                             result.rms_current > 0.1; // Some current flow\n\n    result.generator_ac_available = result.ac_output_active && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_AC_STATUS message\nconst decodedData = decodeGeneratorACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 700,
        "wires": [
            [
                "6b903512de37f1ad"
            ]
        ]
    },
    {
        "id": "6b903512de37f1ad",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 700,
        "wires": []
    },
    {
        "id": "bacdea9854675b01",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_AC_STATUS",
        "func": "// ATS_AC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes ATS_AC_STATUS_1/2/3/4 messages per RV-C specification\n// Handles AC input/output status for automatic transfer switches (follows AC_STATUS format)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_AC_STATUS Specific Decoders ===\n\nfunction decodeATSACInstance(value) {\n    // ATS AC instance interpretation per RV-C spec\n    // For ATS, this typically indicates the AC input/output line being monitored\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7 - ATS-specific fault interpretation\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeATSACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeATSACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields for ATS operations\n    result.ac_source_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.ats_load_present = result.rms_current !== \"Not Available\" &&\n        typeof result.rms_current === 'number' &&\n        result.rms_current > 0.1; // Some current flow\n\n    result.ac_source_qualified = result.ac_source_available &&\n        !result.any_fault &&\n        typeof result.frequency === 'number' &&\n        result.frequency >= 58 && result.frequency <= 62; // Reasonable frequency range\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_AC_STATUS message\nconst decodedData = decodeATSACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 820,
        "wires": [
            [
                "f80a9416a8e18e46"
            ]
        ]
    },
    {
        "id": "f80a9416a8e18e46",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 820,
        "wires": []
    },
    {
        "id": "f171dcbe8b5d2e05",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_STATUS",
        "func": "// CHARGER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes CHARGER_STATUS messages per RV-C specification\n// Handles battery charger operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_STATUS Specific Decoders ===\n\nfunction decodeChargerInstance(value) {\n    // Charger instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Charger operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"Bulk\",\n        2: \"Absorption\",\n        3: \"Overcharge\",\n        4: \"Equalize\",\n        5: \"Float\",\n        6: \"No Charge\",\n        7: \"Constant Voltage\",\n        8: \"Constant Current\",\n        9: \"Fault\",\n        10: \"Unavailable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeChargerCommand(value) {\n    // Charger command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Bulk\",\n        3: \"Absorption\",\n        4: \"Overcharge\",\n        5: \"Equalize\",\n        6: \"Float\",\n        7: \"Auto\",\n        8: \"Reset Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeChargerType(value) {\n    // Charger type mapping\n    const chargerTypes = {\n        0: \"Unknown\",\n        1: \"AC-DC Converter\",\n        2: \"Solar Controller\",\n        3: \"Wind Generator\",\n        4: \"Alternator\",\n        5: \"DC-DC Converter\",\n        6: \"Fuel Cell\",\n        7: \"Shore Power\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return chargerTypes[value] || `Unknown Type ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeEfficiency(value) {\n    // Efficiency as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Charging Active\");\n    if (value & 0x02) statusBits.push(\"AC Input Available\");\n    if (value & 0x04) statusBits.push(\"Battery Connected\");\n    if (value & 0x08) statusBits.push(\"Equalize Mode\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Reverse Polarity\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overvoltage Input\",\n        2: \"Undervoltage Input\",\n        3: \"Overtemperature\",\n        4: \"Fan Failure\",\n        5: \"Communication Error\",\n        6: \"Battery Fault\",\n        7: \"Ground Fault\",\n        8: \"Current Limit\",\n        9: \"Internal Fault\",\n        10: \"Reverse Polarity\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific CHARGER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeChargerInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeChargerCommand(value);\n        }\n        if (param.name === 'charger type' || param.name === 'type') {\n            return decodeChargerType(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'efficiency') {\n            return decodeEfficiency(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeChargerMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_STATUS\"\n    };\n\n    // Decode based on CHARGER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Charger Type\n        result.charger_type = decodeChargerType(data[2]);\n\n        // Bytes 3-4: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[3] | (data[4] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Bytes 5-6: DC Current (16-bit, little-endian)\n        const dcCurrent = data[5] | (data[6] << 8);\n        result.dc_current = decodeDCCurrent(dcCurrent);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_charger_type = data[2];\n        result.raw_dc_voltage_bytes = [data[3], data[4]];\n        result.raw_dc_current_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.charger_active = ![\"off\", \"no charge\", \"fault\", \"unavailable\", \"error\"].includes(state);\n        result.charger_charging = [\"bulk\", \"absorption\", \"float\", \"equalize\"].includes(state);\n        result.charger_available = ![\"fault\", \"unavailable\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.dc_voltage === 'number' && typeof result.dc_current === 'number') {\n        result.dc_power = parseFloat((result.dc_voltage * result.dc_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_STATUS message\nconst decodedData = decodeChargerMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 880,
        "wires": [
            [
                "78904d457471d1b2"
            ]
        ]
    },
    {
        "id": "78904d457471d1b2",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 880,
        "wires": []
    },
    {
        "id": "b91d72f6d383c0d6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_DC_STATUS",
        "func": "// INVERTER_DC_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_DC_STATUS messages per RV-C specification\n// Handles DC input status for inverters (DC battery connection monitoring)\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_DC_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance interpretation per RV-C spec\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCInstance(value) {\n    // DC Instance mapping per RV-C specification\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC Voltage in volts (0.05V resolution)\n    if (value <= 64000) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    // Handle signed 32-bit value\n    let signedValue = value;\n    if (value > 2147483647) {\n        signedValue = value - 4294967296; // Convert from unsigned to signed\n    }\n\n    if (Math.abs(signedValue) <= MAX_VALID) {\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeInverterState(value) {\n    // Inverter operational state\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Sleep Mode\",\n        5: \"Search Mode\",\n        6: \"Standby\",\n        7: \"Fault\",\n        8: \"Battery Low\",\n        9: \"Overload\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\nfunction decodeUint32(data, startByte) {\n    // Decode 32-bit value (little-endian)\n    if (!data || startByte + 3 >= data.length) {\n        return 4294967295; // Not available\n    }\n    return data[startByte] |\n           (data[startByte + 1] << 8) |\n           (data[startByte + 2] << 16) |\n           (data[startByte + 3] << 24);\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterDCMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_DC_STATUS\"\n    };\n\n    // Decode INVERTER_DC_STATUS message (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Inverter Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: DC Instance (battery bank)\n        result.dc_instance = decodeDCInstance(data[1]);\n\n        // Bytes 2-3: DC Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 2);\n        result.dc_voltage = decodeDCVoltage(voltageRaw);\n\n        // Bytes 4-7: DC Current (uint32, little-endian, signed)\n        const currentRaw = decodeUint32(data, 4);\n        result.dc_current = decodeDCCurrent(currentRaw);\n\n        // Additional bytes if available for extended status\n        if (data.length > 8) {\n            // Byte 8: Inverter State (if available)\n            result.inverter_state = decodeInverterState(data[8]);\n        }\n\n        if (data.length > 9) {\n            // Byte 9: Temperature (if available)\n            result.temperature = decodeTemperature(data[9]);\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n    }\n\n    // Add convenience fields\n    result.dc_input_available = result.dc_voltage !== \"Not Available\" &&\n                               typeof result.dc_voltage === 'number' &&\n                               result.dc_voltage > 10; // Reasonable DC voltage threshold\n\n    result.inverter_drawing_power = result.dc_current !== \"Not Available\" &&\n                                   typeof result.dc_current === 'number' &&\n                                   Math.abs(result.dc_current) > 0.5; // Some current flow\n\n    result.inverter_supplying_power = result.dc_current !== \"Not Available\" &&\n                                     typeof result.dc_current === 'number' &&\n                                     result.dc_current < -0.5; // Negative current = supplying power\n\n    if (result.inverter_state !== undefined) {\n        const state = result.inverter_state.toString().toLowerCase();\n        result.inverter_operational = [\"running\", \"search mode\", \"standby\"].includes(state);\n        result.inverter_faulted = [\"fault\", \"battery low\", \"overload\"].includes(state);\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_DC_STATUS message\nconst decodedData = decodeInverterDCMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1120,
        "wires": [
            [
                "04bc7637ee7139d8"
            ]
        ]
    },
    {
        "id": "04bc7637ee7139d8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_DC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 1120,
        "wires": []
    },
    {
        "id": "2e5425d73a166c9b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode TANK_STATUS",
        "func": "// TANK_STATUS Decoder (Updated with Flat Output) - Complete and Accurate RV-C Implementation\n// Decodes TANK_STATUS messages (1FFB7) per RV-C specification\n// Handles all RV tank types: Fresh Water, Gray Water, Black Water, LPG\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === TANK_STATUS Specific Decoders ===\n\nfunction decodeTankInstance(value) {\n    // Tank instance mapping per RV-C specification\n    const tankTypes = {\n        0: \"Fresh Water\",\n        1: \"Gray Water\",\n        2: \"Black Water\",\n        3: \"LPG\",\n        4: \"Fuel\",\n        5: \"Hot Water\",\n        6: \"Hydraulic Fluid\",\n        7: \"Live Well\",\n        8: \"Ballast\",\n        9: \"Oil\",\n        10: \"Coolant\",\n        11: \"Diesel Exhaust Fluid\",\n        12: \"Compressed Air\",\n        13: \"Fresh Water 2\",\n        14: \"Gray Water 2\",\n        15: \"Black Water 2\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return tankTypes[value] || `Unknown Tank ${value}`;\n}\n\nfunction decodeTankLevel(value) {\n    // Tank level as raw sensor reading (not percentage)\n    // Percentage calculated as: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw sensor reading\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankResolution(value) {\n    // Tank resolution as raw sensor resolution value\n    // Used in calculation: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw resolution value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankStatus(value) {\n    // Tank status bit field decoding\n    const statusBits = {\n        0: \"Tank OK\",\n        1: \"Tank Low\",\n        2: \"Tank Full\",\n        3: \"Tank Overfilled\",\n        4: \"Sensor Fault\",\n        5: \"Tank Disconnected\",\n        6: \"Reserved\",\n        7: \"Reserved\"\n    };\n\n    const activeStatuses = [];\n    for (let bit = 0; bit < 8; bit++) {\n        if (value & (1 << bit)) {\n            activeStatuses.push(statusBits[bit]);\n        }\n    }\n\n    return activeStatuses.length > 0 ? activeStatuses.join(\", \") : \"Tank OK\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    const value = data[byte];\n\n    if (param.type === 'uint8') {\n        // Handle specific TANK_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeTankInstance(value);\n        }\n        if (param.name === 'relative level' || param.name === 'level') {\n            return decodeTankLevel(value);\n        }\n        if (param.name === 'resolution') {\n            return decodeTankResolution(value);\n        }\n        if (param.name === 'temperature') {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'status' || param.name === 'tank status') {\n            return decodeTankStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeTankStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"TANK_STATUS\"\n    };\n\n    // Decode based on TANK_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Tank Instance\n        result.instance = data[0];\n        result.instance_name = decodeTankInstance(data[0]);\n\n        // Byte 1: Relative Level (0-200)\n        result.relative_level = decodeTankLevel(data[1]);\n\n        // Byte 2: Resolution (tank capacity steps)\n        result.resolution = decodeTankResolution(data[2]);\n\n        // Byte 3: Temperature\n        result.temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Tank Status (bit field)\n        result.status = decodeTankStatus(data[4]);\n\n        // Bytes 5-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_relative_level = data[1];\n        result.raw_resolution = data[2];\n        result.raw_temperature = data[3];\n        result.raw_status = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields for easier consumption\n    // Calculate tank percentage using RV-C formula: (relative_level / resolution) * 100\n    if (result.relative_level !== undefined && result.resolution !== undefined &&\n        typeof result.relative_level === 'number' && typeof result.resolution === 'number' &&\n        result.resolution > 0) {\n        result.level_percentage = Math.round((result.relative_level / result.resolution) * 100);\n    } else if (result.relative_level !== undefined && typeof result.relative_level === 'number') {\n        // Fallback if resolution is not available (direct percentage)\n        result.level_percentage = Math.round(result.relative_level * 0.5); // 0.5% per step\n    }\n\n    if (result.instance !== undefined) {\n        // Map numeric instance to single-word tank type\n        const tankTypeMap = {\n            0: \"fresh\",\n            1: \"gray\",\n            2: \"black\",\n            3: \"lpg\",\n            4: \"fuel\",\n            5: \"hot\",\n            6: \"hydraulic\",\n            7: \"livewell\",\n            8: \"ballast\",\n            9: \"oil\",\n            10: \"coolant\",\n            11: \"def\",\n            12: \"air\",\n            13: \"fresh2\",\n            14: \"gray2\",\n            15: \"black2\",\n            251: \"error\",\n            252: \"notsupported\",\n            253: \"outofrange\",\n            254: \"reserved\",\n            255: \"notavailable\"\n        };\n\n        result.tank_type = tankTypeMap[result.instance] || \"other\";\n    }\n\n    // Tank level status\n    if (typeof result.level_percentage === 'number') {\n        result.tank_empty = result.level_percentage <= 5;\n        result.tank_low = result.level_percentage <= 25;\n        result.tank_full = result.level_percentage >= 95;\n        result.tank_level_available = true;\n    } else {\n        result.tank_level_available = false;\n    }\n\n    // Temperature status\n    result.temperature_available = typeof result.temperature === 'number';\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the TANK_STATUS message\nconst decodedData = decodeTankStatusMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 220,
        "wires": [
            [
                "45ae070eafc9a732"
            ]
        ]
    },
    {
        "id": "e5d61c5724c6ed1b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_DEMAND_STATUS",
        "func": "// GENERATOR_DEMAND_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes GENERATOR_DEMAND_STATUS messages per RV-C specification\n// Handles automatic generator start (AGS) demand status and control flags\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_DEMAND_STATUS Specific Decoders ===\n\nfunction decodeDemandStatus(value) {\n    // Decode demand status bits (2-bit fields)\n    const states = {\n        0: \"No Demand\",\n        1: \"Demand Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeOverrideStatus(value) {\n    // Decode override/activity status bits (2-bit fields)\n    const states = {\n        0: \"Normal Operation\",\n        1: \"Override/Activity Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeTime(hour, minute) {\n    // Convert hour and minute to readable time format\n    if (hour === 255 || minute === 255) {\n        return \"Not Available\";\n    }\n    if (hour > 23 || minute > 59) {\n        return \"Invalid Time\";\n    }\n\n    // Format as 24-hour time\n    const hourStr = hour.toString().padStart(2, '0');\n    const minStr = minute.toString().padStart(2, '0');\n    return `${hourStr}:${minStr}`;\n}\n\nfunction decodeMinimumCycleTime(value) {\n    // Minimum cycle time in minutes\n    if (value === 0) {\n        return \"No Minimum\";\n    } else if (value <= 250) {\n        return `${value} minutes`;\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorDemandMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_DEMAND_STATUS\"\n    };\n\n    if (data.length >= 7) {\n        // Byte 0: Demand status bits\n        const byte0 = data[0];\n        result.generator_demand = decodeDemandStatus(decodeBits(byte0, 0, 1));\n        result.internal_demand = decodeDemandStatus(decodeBits(byte0, 2, 3));\n        result.network_demand = decodeDemandStatus(decodeBits(byte0, 4, 5));\n        result.external_activity_detected = decodeOverrideStatus(decodeBits(byte0, 6, 7));\n\n        // Byte 1: Override and control status bits\n        const byte1 = data[1];\n        result.manual_override_detected = decodeOverrideStatus(decodeBits(byte1, 0, 1));\n        result.quiet_time = decodeOverrideStatus(decodeBits(byte1, 2, 3));\n        result.quiet_time_override = decodeOverrideStatus(decodeBits(byte1, 4, 5));\n        result.generator_lock = decodeOverrideStatus(decodeBits(byte1, 6, 7));\n\n        // Bytes 2-3: Quiet time begin (DEPRECATED but still decoded)\n        result.quiet_time_begin = decodeTime(data[2], data[3]);\n\n        // Bytes 4-5: Quiet time end (DEPRECATED but still decoded)\n        if (data.length >= 6) {\n            result.quiet_time_end = decodeTime(data[4], data[5]);\n        }\n\n        // Byte 6: Minimum cycle time\n        if (data.length >= 7) {\n            result.minimum_cycle_time = decodeMinimumCycleTime(data[6]);\n        }\n\n        // Raw values for debugging\n        result.raw_demand_byte = byte0;\n        result.raw_control_byte = byte1;\n    }\n\n    // Add convenience fields for easier automation logic\n    result.generator_should_run = result.generator_demand === \"Demand Active\" ||\n        result.internal_demand === \"Demand Active\" ||\n        result.network_demand === \"Demand Active\";\n\n    result.automatic_start_allowed = result.external_activity_detected !== \"Override/Activity Active\" &&\n        result.generator_lock !== \"Override/Activity Active\";\n\n    result.quiet_time_active = result.quiet_time === \"Override/Activity Active\" &&\n        result.quiet_time_override !== \"Override/Activity Active\";\n\n    result.manual_control_active = result.manual_override_detected === \"Override/Activity Active\";\n\n    // Overall status assessment\n    result.demand_summary = result.generator_should_run ? \"Generator Requested\" : \"No Generator Demand\";\n\n    if (result.generator_lock === \"Override/Activity Active\") {\n        result.demand_summary = \"Generator Locked\";\n    } else if (result.external_activity_detected === \"Override/Activity Active\") {\n        result.demand_summary = \"External Activity Blocking\";\n    } else if (result.quiet_time_active) {\n        result.demand_summary = \"Quiet Time Active\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_DEMAND_STATUS message\nconst decodedData = decodeGeneratorDemandMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 760,
        "wires": [
            [
                "51e87f869d6aa2c5"
            ]
        ]
    },
    {
        "id": "51e87f869d6aa2c5",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_DEMAND_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 760,
        "wires": []
    },
    {
        "id": "cb64b7a9a87f03cc",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_STATUS",
        "func": "// INVERTER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes INVERTER_STATUS messages per RV-C specification\n// Handles inverter operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Inverter operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Inverting\",\n        3: \"Charging\",\n        4: \"Passthrough\",\n        5: \"Standby\",\n        6: \"Fault\",\n        7: \"Equalize\",\n        8: \"Bulk Charge\",\n        9: \"Absorption\",\n        10: \"Float\",\n        11: \"Search Mode\",\n        12: \"Sleep Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeInverterCommand(value) {\n    // Inverter command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Invert Only\",\n        3: \"Charge Only\",\n        4: \"Auto\",\n        5: \"Search Mode\",\n        6: \"Reset Fault\",\n        7: \"Equalize\",\n        8: \"Shore Power Priority\",\n        9: \"Battery Priority\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    if (value <= MAX_VALID) {\n        // Handle signed values for charging (positive) vs discharging (negative)\n        const signedValue = value > 2147483647 ? value - 4294967296 : value;\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency in Hz (0.1Hz resolution)\n    if (value <= 700) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1Hz per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"AC Output On\");\n    if (value & 0x02) statusBits.push(\"Charging Active\");\n    if (value & 0x04) statusBits.push(\"AC Input Available\");\n    if (value & 0x08) statusBits.push(\"Overload\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Low Battery\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overload\",\n        2: \"Overvoltage Input\",\n        3: \"Undervoltage Input\",\n        4: \"Overvoltage Output\",\n        5: \"Undervoltage Output\",\n        6: \"Overtemperature\",\n        7: \"Fan Failure\",\n        8: \"Ground Fault\",\n        9: \"DC Ripple\",\n        10: \"AC Frequency Error\",\n        11: \"Internal Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific INVERTER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeInverterInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeInverterCommand(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name === 'frequency') {\n            return decodeFrequency(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_STATUS\"\n    };\n\n    // Decode based on INVERTER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: AC Voltage\n        result.ac_voltage = decodeACVoltage(data[2]);\n\n        // Bytes 3-4: AC Current (16-bit, little-endian)\n        const acCurrent = data[3] | (data[4] << 8);\n        result.ac_current = decodeACCurrent(acCurrent);\n\n        // Bytes 5-6: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[5] | (data[6] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Byte 7: Temperature or Frequency\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_ac_voltage = data[2];\n        result.raw_ac_current_bytes = [data[3], data[4]];\n        result.raw_dc_voltage_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.inverter_active = state === \"inverting\";\n        result.charger_active = state === \"charging\";\n        result.inverter_available = ![\"fault\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_passthrough = state === \"passthrough\";\n        result.is_in_standby = state === \"standby\" || state === \"search mode\" || state === \"sleep mode\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_STATUS message\nconst decodedData = decodeInverterMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1000,
        "wires": [
            [
                "9f3a9fd8a4506e74"
            ]
        ]
    },
    {
        "id": "9f3a9fd8a4506e74",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1000,
        "wires": []
    },
    {
        "id": "010c5119a7e833b2",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_SOURCE_STATUS",
        "func": "// Corrected RV-C DC_SOURCE_STATUS Decoder for Node-RED\n// Decodes DC_SOURCE_STATUS messages 1, 2, and 3 based on their DGN.\n// Input: msg.payload with {dgn, dataPayload}\n// Output: msg.payload with decoded fields\n\n// === Helper Functions (Largely from your original code) ===\n\n// Decodes a bitfield from within a byte\nfunction decodeBits(byte, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (byte & mask) >> startBit;\n}\n\n// Decodes the DC Instance (Byte 0)\nfunction decodeDCInstance(value) {\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\"\n    };\n    // Per the spec, 5-250 are valid \"Other\" instances \n    if (value >= 5 && value <= 250) {\n        return `Other DC Instance ${value}`;\n    }\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\n// Decodes the Device Priority (Byte 1)\nfunction decodeDevicePriority(value) {\n    const priorities = {\n        20: \"Voltmeter\",\n        40: \"Voltmeter/Ammeter\",\n        60: \"Inverter\",\n        80: \"Charger\",\n        100: \"Inverter/Charger\",\n        120: \"Battery SOC/BMS Device\"\n    };\n    return priorities[value] || `Unknown Priority ${value}`;\n}\n\n// Decodes DC Voltage (uint16)\nfunction decodeDCVoltage(value) {\n    // NOTE: This logic is based on your original function, assuming a 0.05V resolution\n    // from the unprovided \"Table 5.3\" referenced in the spec.\n    if (value <= 64000) return parseFloat((value * 0.05).toFixed(2));\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes DC Current (32-bit signed)\nfunction decodeDCCurrent32bit(value) {\n    // NOTE: This logic is based on your original function, assuming a 0.05A resolution\n    // from the unprovided \"Table 5.3\" referenced in the spec.\n    if (value === 4294967295) return \"Not Available\";\n\n    // Convert 32-bit unsigned to signed\n    if (value > 2147483647) {\n        value = value - 4294967296;\n    }\n\n    // The spec does not define the range for current, using your original logic.\n    return parseFloat((value * 0.05).toFixed(2));\n}\n\n// Decodes Temperature (uint16)\nfunction decodeTemperature(value) {\n    // This is for the uint16 version in STATUS_2 [cite: 72]\n    // The spec does not define the scaling for this field, assuming offset of -40 C.\n    if (value <= 64000) return (value * 0.03125) - 273; // Example scaling\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes State of Charge / Health / Relative Capacity (uint8)\nfunction decodePercentage(value) {\n    // 0.5% per step from your original function.\n    if (value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\n\n\n// === DGN-Specific Decoders ===\n\nfunction decodeDCSourceStatus1(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_1\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_1\" };\n\n    result.dc_instance_id = data[0]; // Raw numeric instance ID\n    result.dc_instance = decodeDCInstance(data[0]);\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const voltage = (data[3] << 8) | data[2];\n    result.dc_voltage_V = decodeDCVoltage(voltage);\n\n    const current = (data[7] << 24) | (data[6] << 16) | (data[5] << 8) | data[4];\n    result.dc_current_A = decodeDCCurrent32bit(current);\n\n    return result;\n}\n\nfunction decodeDCSourceStatus2(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_2\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_2\" };\n\n    result.dc_instance_id = data[0]; // Raw numeric instance ID\n    result.dc_instance = decodeDCInstance(data[0]);\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const temp = (data[3] << 8) | data[2];\n    result.source_temp_C = decodeTemperature(temp);\n\n    result.state_of_charge_percent = decodePercentage(data[4]);\n\n    const time = (data[6] << 8) | data[5];\n    result.time_remaining_min = (time <= 64000) ? time : \"Not Available\";\n\n    const interp = decodeBits(data[7], 0, 1);\n    const interpMap = { 0: \"Time to Empty\", 1: \"Time to Full\", 3: \"Not Available\" };\n    result.time_remaining_interpretation = interpMap[interp] || \"Reserved\";\n\n    return result;\n}\n\nfunction decodeDCSourceStatus3(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_3\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_3\" };\n\n    result.dc_instance_id = data[0]; // Raw numeric instance ID\n    result.dc_instance = decodeDCInstance(data[0]);\n    result.device_priority = decodeDevicePriority(data[1]);\n    result.state_of_health_percent = decodePercentage(data[2]);\n\n    const cap = (data[4] << 8) | data[3];\n    result.capacity_remaining_Ah = (cap <= 64000) ? cap : \"Not Available\";\n\n    result.relative_capacity_percent = decodePercentage(data[5]);\n\n    const ripple = (data[7] << 8) | data[6];\n    result.ac_rms_ripple_mV = (ripple <= 65530) ? ripple : \"Not Available\";\n\n    return result;\n}\n\n// === Main Router Function ===\n\nfunction decodeDCSourceMessage(dgn, data) {\n    switch (dgn) {\n        case '1FFFD':\n            return decodeDCSourceStatus1(data);\n        case '1FFFC':\n            return decodeDCSourceStatus2(data);\n        case '1FFFB':\n            return decodeDCSourceStatus3(data);\n        default:\n            return {\n                dgn: dgn,\n                error: `Unsupported DGN for DC_SOURCE_STATUS decoding.`\n            };\n    }\n}\n\n// === Main Node-RED Logic ===\n\nconst incomingPayload = msg.payload;\nif (!incomingPayload || !incomingPayload.dgn || !incomingPayload.dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Convert hex payload to byte array\nconst dataBytes = [];\nfor (let i = 0; i < incomingPayload.dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(incomingPayload.dataPayload.substring(i, i + 2), 16));\n}\n\n// Decode the message by routing to the correct function based on DGN\nconst decodedData = decodeDCSourceMessage(incomingPayload.dgn, dataBytes);\n\n// Merge the original payload and the newly decoded data\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up by removing the raw hex payload\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 280,
        "wires": [
            [
                "bff245b2ca47ef79"
            ]
        ]
    },
    {
        "id": "c38d48059f463772",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AC_LOAD_STATUS",
        "func": "// AC_LOAD_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes AC_LOAD_STATUS messages per RV-C specification\n// Handles generic AC circuit loads with load management capabilities\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === AC_LOAD_STATUS Specific Decoders ===\n\nfunction decodeLoadInstance(value) {\n    // Load instance interpretation per RV-C spec\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << (i - 1); // Group 1 = bit 0, Group 2 = bit 1, etc.\n        if (!(value & groupBit)) { // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingLevel(value) {\n    // Operating status/level (0-100% for dimmable, or special values)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 252) {\n        return \"Load Delay Active\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return modes[value] || \"Unknown\";\n}\n\nfunction decodeVariableCapability(value) {\n    // Variable level capability (2-bit field)\n    const capabilities = {\n        0: \"Not Variable (Not Dimmable)\",\n        1: \"Variable (Dimmable)\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return capabilities[value] || \"Unknown\";\n}\n\nfunction decodePriority(value) {\n    // Load priority (4-bit field)\n    if (value <= 13) {\n        return `Priority ${value} (${value === 0 ? \"Highest\" : value === 13 ? \"Lowest\" : \"Medium\"})`;\n    } else if (value === 14) {\n        return \"Error\";\n    } else if (value === 15) {\n        return \"No Data\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDelay(value) {\n    // Delay before load activation\n    if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrent(value) {\n    // Current in amperes per Table 5.3 (0.05A resolution for small values)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeACLoadMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AC_LOAD_STATUS\"\n    };\n\n    // Determine if this is AC_LOAD_STATUS or AC_LOAD_STATUS_2\n    const dgnHex = dgn.toUpperCase();\n\n    if (dgnHex === \"1FFBF\") {\n        // AC_LOAD_STATUS (standard status)\n        result.status_type = \"AC_LOAD_STATUS\";\n\n        if (data.length >= 8) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Group membership bitmap\n            result.group_membership = decodeGroupBitmap(data[1]);\n\n            // Byte 2: Operating status (level)\n            result.operating_level = decodeOperatingLevel(data[2]);\n\n            // Byte 3: Mode, capability, and priority bits\n            const byte3 = data[3];\n            result.operating_mode = decodeOperatingMode(decodeBits(byte3, 0, 1));\n            result.variable_capability = decodeVariableCapability(decodeBits(byte3, 2, 3));\n            result.load_priority = decodePriority(decodeBits(byte3, 4, 7));\n\n            // Byte 4: Delay\n            result.activation_delay = decodeDelay(data[4]);\n\n            // Byte 5: Demanded current\n            result.demanded_current = decodeCurrent(data[5]);\n\n            // Bytes 6-7: Present current (uint16, little-endian)\n            const presentCurrentRaw = decodeUint16(data, 6);\n            result.present_current = decodeCurrent(Math.min(presentCurrentRaw, 255)); // Scale down if needed\n\n            // Raw values for debugging\n            result.raw_present_current = presentCurrentRaw;\n            result.raw_control_byte = byte3;\n        }\n\n    } else if (dgnHex === \"1FEDD\") {\n        // AC_LOAD_STATUS_2 (extended status)\n        result.status_type = \"AC_LOAD_STATUS_2\";\n\n        if (data.length >= 4) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Status bits\n            const byte1 = data[1];\n            const lockStatus = decodeBits(byte1, 0, 1);\n            const overcurrentStatus = decodeBits(byte1, 2, 3);\n            const overrideStatus = decodeBits(byte1, 4, 5);\n            const enableStatus = decodeBits(byte1, 6, 7);\n\n            const statusStates = [\"Normal\", \"Active/Fault\", \"Reserved\", \"Not Supported\"];\n            result.lock_status = lockStatus === 0 ? \"Unlocked\" : statusStates[lockStatus] || \"Unknown\";\n            result.overcurrent_status = statusStates[overcurrentStatus] || \"Unknown\";\n            result.override_status = statusStates[overrideStatus] || \"Unknown\";\n            result.enable_status = enableStatus === 0 ? \"Enabled\" : statusStates[enableStatus] || \"Unknown\";\n\n            // Byte 2: Last command\n            result.last_command = data[2]; // Command code - would need command lookup table for name\n\n            // Byte 3: Interlock status\n            if (data.length > 3) {\n                const interlockStatus = decodeBits(data[3], 0, 1);\n                result.interlock_status = interlockStatus === 0 ? \"Not Active\" :\n                    interlockStatus === 1 ? \"Active\" : \"Not Supported\";\n            }\n\n            // Raw values for debugging\n            result.raw_status_byte = byte1;\n        }\n    }\n\n    // Add convenience fields\n    if (result.operating_level !== undefined) {\n        result.load_active = typeof result.operating_level === 'number' && result.operating_level > 0;\n    }\n\n    if (result.variable_capability !== undefined) {\n        result.is_dimmable = result.variable_capability.includes(\"Dimmable\");\n    }\n\n    if (result.operating_mode !== undefined) {\n        result.can_auto_control = result.operating_mode === \"Automatic\";\n    }\n\n    // Load health assessment\n    result.load_healthy = true;\n    if (result.overcurrent_status === \"Active/Fault\") result.load_healthy = false;\n    if (result.enable_status === \"Active/Fault\") result.load_healthy = false;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the AC_LOAD_STATUS message\nconst decodedData = decodeACLoadMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1180,
        "wires": [
            [
                "77e3defd386ce8a8"
            ]
        ]
    },
    {
        "id": "77e3defd386ce8a8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AC_LOAD_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1180,
        "wires": []
    },
    {
        "id": "a0357de00b26b002",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_STATUS",
        "func": "// ATS_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes ATS_STATUS messages per RV-C specification\n// Handles automatic transfer switch status and source selection\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_STATUS Specific Decoders ===\n\nfunction decodeATSInstance(value) {\n    // ATS instance interpretation per RV-C spec\n    if (value >= 1 && value <= 6) {\n        return value; // Valid instances\n    } else if (value === 0 || value >= 7) {\n        return \"Invalid Instance\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSourceInUse(value) {\n    // Source currently in use\n    if (value === 0) {\n        return \"Primary\";\n    } else if (value >= 1 && value <= 6) {\n        return `Source ${value}`;\n    } else if (value === 253) {\n        return \"No Source Active\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid Source\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\"\n    };\n    return modes[value] || \"Unknown\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeATSMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_STATUS\"\n    };\n\n    if (data.length >= 3) {\n        // Byte 0: ATS Instance\n        result.instance = decodeATSInstance(data[0]);\n\n        // Byte 1: Source in use\n        result.source_in_use = decodeSourceInUse(data[1]);\n\n        // Byte 2: Operating mode (bits 0-1)\n        const byte2 = data[2];\n        result.operating_mode = decodeOperatingMode(decodeBits(byte2, 0, 1));\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_source = data[1];\n        result.raw_mode_byte = byte2;\n    }\n\n    // Add convenience fields\n    result.has_active_source = result.source_in_use !== \"No Source Active\" &&\n        result.source_in_use !== \"Not Available\" &&\n        !result.source_in_use.includes(\"Invalid\");\n\n    result.is_automatic_mode = result.operating_mode === \"Automatic\";\n    result.is_manual_mode = result.operating_mode === \"Manual\";\n\n    result.using_primary_source = result.source_in_use === \"Primary\";\n\n    // Overall status assessment\n    if (result.has_active_source) {\n        result.transfer_switch_status = `Active on ${result.source_in_use}`;\n    } else {\n        result.transfer_switch_status = \"No Active Source\";\n    }\n\n    if (result.operating_mode === \"Manual\") {\n        result.transfer_switch_status += \" (Manual Mode)\";\n    } else if (result.operating_mode === \"Automatic\") {\n        result.transfer_switch_status += \" (Automatic Mode)\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_STATUS message\nconst decodedData = decodeATSMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1240,
        "wires": [
            [
                "fa30f6cf9bede7e9"
            ]
        ]
    },
    {
        "id": "fa30f6cf9bede7e9",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 1240,
        "wires": []
    },
    {
        "id": "4a6d57460d64c76f",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_DIMMER_STATUS_3",
        "func": "// DC_DIMMER_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes DC_DIMMER_STATUS_1/2/3 messages per RV-C specification\n// Handles RGB/RGBW dimmer loads with brightness, current, and fault monitoring\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === DC_DIMMER_STATUS Specific Decoders ===\n\nfunction decodeDimmerInstance(value) {\n    // Dimmer instance interpretation per RV-C spec\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeBrightnessLevel(value) {\n    // Brightness level (0-200% per Table 5.3)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Value Changing (Ramp)\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current per Table 5.3 (0.05A resolution for small currents)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeChannelFault(value) {\n    // Channel fault status (2-bit field)\n    const faultStates = {\n        0: \"No Fault\",\n        1: \"Undercurrent (Open Circuit)\",\n        2: \"Overcurrent\",\n        3: \"Reserved\"\n    };\n    return faultStates[value] || \"Unknown\";\n}\n\nfunction decodeFaultByte(value) {\n    // Decode fault bits from byte 5 (STATUS_2)\n    const masterFault = decodeBits(value, 0, 1);\n    const redFault = decodeBits(value, 2, 3);\n    const greenFault = decodeBits(value, 4, 5);\n    const blueFault = decodeBits(value, 6, 7);\n\n    const faults = [];\n    if (masterFault > 0) faults.push(`Master: ${decodeChannelFault(masterFault)}`);\n    if (redFault > 0) faults.push(`Red: ${decodeChannelFault(redFault)}`);\n    if (greenFault > 0) faults.push(`Green: ${decodeChannelFault(greenFault)}`);\n    if (blueFault > 0) faults.push(`Blue: ${decodeChannelFault(blueFault)}`);\n\n    return {\n        fault_summary: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        master_fault: decodeChannelFault(masterFault),\n        red_fault: decodeChannelFault(redFault),\n        green_fault: decodeChannelFault(greenFault),\n        blue_fault: decodeChannelFault(blueFault),\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << i;\n        if (!(value & groupBit)) { // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingStatus(value) {\n    // Operating status for STATUS_3\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step\n    } else if (value === 251) {\n        return \"Value Changing (Ramp)\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeStatus3Byte3(value) {\n    // Decode status bits from byte 3 (STATUS_3)\n    const lockStatus = decodeBits(value, 0, 1);\n    const overcurrentStatus = decodeBits(value, 2, 3);\n    const overrideStatus = decodeBits(value, 4, 5);\n    const enableStatus = decodeBits(value, 6, 7);\n\n    const lockStates = [\"Unlocked\", \"Locked\", \"Reserved\", \"Not Supported\"];\n    const statusStates = [\"Normal/Inactive\", \"Active/Abnormal\", \"Reserved\", \"Not Supported\"];\n    const enableStates = [\"Enabled\", \"Disabled\", \"Reserved\", \"Not Supported\"];\n\n    return {\n        lock_status: lockStates[lockStatus] || \"Unknown\",\n        overcurrent_status: statusStates[overcurrentStatus] || \"Unknown\",\n        override_status: statusStates[overrideStatus] || \"Unknown\",\n        enable_status: enableStates[enableStatus] || \"Unknown\"\n    };\n}\n\nfunction decodeLastCommand(value) {\n    // Last executed command (STATUS_3)\n    const commands = {\n        0: \"Set Brightness\",\n        1: \"ON\",\n        2: \"ON Delay\",\n        3: \"OFF\",\n        4: \"Stop\",\n        5: \"Toggle\",\n        6: \"Memory OFF\",\n        7: \"Save Scene\",\n        11: \"Ramp Brightness\",\n        12: \"Ramp Toggle\",\n        13: \"Ramp Up\",\n        14: \"Ramp Down\",\n        15: \"Ramp Up/Down\",\n        16: \"Ramp Up/Down Toggle\",\n        21: \"Lock\",\n        22: \"Unlock\",\n        31: \"Flash\",\n        32: \"Flash Momentary\",\n        33: \"Flash Pattern\",\n        34: \"Scene Recall\",\n        35: \"Scene Store\",\n        36: \"Group Command\",\n        37: \"Reset\",\n        38: \"Factory Reset\",\n        39: \"Calibrate\",\n        40: \"Test Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeDelayDuration(value) {\n    // Delay/Duration field (STATUS_3)\n    if (value === 0) {\n        return \"Expired\";\n    } else if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 252) {\n        return \"Flashing\";\n    } else if (value === 253) {\n        return \">240 seconds\";\n    } else if (value === 255) {\n        return \"No delay active\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeStatus3Byte6(value) {\n    // Decode status bits from byte 6 (STATUS_3)\n    const interlockStatus = decodeBits(value, 0, 1);\n    const loadStatus = decodeBits(value, 2, 3);\n    const undercurrentStatus = decodeBits(value, 6, 7);\n\n    const interlockStates = [\"Not Active\", \"Active\", \"Reserved\", \"Not Supported\"];\n    const loadStates = [\"Off (status=0)\", \"On (status>0 or flashing)\", \"Reserved\", \"Reserved\"];\n    const undercurrentStates = [\"Normal\", \"Active\", \"Timeout Error\", \"Not Supported\"];\n\n    return {\n        interlock_status: interlockStates[interlockStatus] || \"Unknown\",\n        load_status: loadStates[loadStatus] || \"Unknown\",\n        undercurrent_status: undercurrentStates[undercurrentStatus] || \"Unknown\"\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeDCDimmerMessage(dgn, data) {\n    // Map DGN hex codes to specific names for unified routing\n    let dgnName = \"DC_DIMMER_STATUS\"; // fallback\n    const dgnHex = dgn.toUpperCase();\n    if (dgnHex === \"1FFBB\") {\n        dgnName = \"DC_DIMMER_STATUS_1\";\n    } else if (dgnHex === \"1FFBA\") {\n        dgnName = \"DC_DIMMER_STATUS_2\";\n    } else if (dgnHex === \"1FEDA\") {\n        dgnName = \"DC_DIMMER_STATUS_3\";\n    }\n\n    const result = {\n        dgn: dgn,\n        dgn_name: dgnName\n    };\n\n    // Determine which STATUS message based on DGN and decode accordingly\n\n    if (dgnHex === \"1FFBB\") {\n        // DC_DIMMER_STATUS_1 - Brightness levels and timing\n        result.status_type = \"STATUS_1\";\n\n        if (data.length >= 7) {\n            result.instance = data[0];\n            result.instance_name = decodeDimmerInstance(data[0]);\n            result.master_brightness = decodeBrightnessLevel(data[1]);\n            result.red_brightness = decodeBrightnessLevel(data[2]);\n            result.green_brightness = decodeBrightnessLevel(data[3]);\n            result.blue_brightness = decodeBrightnessLevel(data[4]);\n\n            // Byte 5: On/Off Duration (4 bits each)\n            result.on_duration = decodeBits(data[5], 0, 3); // 0-14 seconds\n            result.off_duration = decodeBits(data[5], 4, 7); // 0-14 seconds\n\n            if (data.length > 6) {\n                result.white_brightness = decodeBrightnessLevel(data[6]);\n            }\n        }\n\n    } else if (dgnHex === \"1FFBA\") {\n        // DC_DIMMER_STATUS_2 - Current measurements and faults\n        result.status_type = \"STATUS_2\";\n\n        if (data.length >= 8) {\n            result.instance = data[0];\n            result.instance_name = decodeDimmerInstance(data[0]);\n            result.red_current = decodeDCCurrent(data[2]);\n            result.green_current = decodeDCCurrent(data[3]);\n            result.blue_current = decodeDCCurrent(data[4]);\n\n            // Byte 5: Fault bits\n            const faultInfo = decodeFaultByte(data[5]);\n            Object.assign(result, faultInfo);\n\n            if (data.length > 6) {\n                result.white_current = decodeDCCurrent(data[6]);\n            }\n\n            if (data.length > 7) {\n                // Byte 7: White fault (bits 0-1)\n                const whiteFault = decodeBits(data[7], 0, 1);\n                result.white_fault = decodeChannelFault(whiteFault);\n            }\n        }\n\n    } else if (dgnHex === \"1FEDA\") {\n        // DC_DIMMER_STATUS_3 - Comprehensive operational status\n        result.status_type = \"STATUS_3\";\n\n        if (data.length >= 8) {\n            result.instance = decodeDimmerInstance(data[0]);\n            result.group_membership = decodeGroupBitmap(data[1]);\n            result.operating_status = decodeOperatingStatus(data[2]);\n\n            // Byte 3: Status bits\n            const status3Info = decodeStatus3Byte3(data[3]);\n            Object.assign(result, status3Info);\n\n            result.delay_duration = decodeDelayDuration(data[4]);\n            result.last_command = decodeLastCommand(data[5]);\n\n            // Byte 6: More status bits\n            const status6Info = decodeStatus3Byte6(data[6]);\n            Object.assign(result, status6Info);\n\n            result.master_memory_value = decodeBrightnessLevel(data[7]);\n        }\n    }\n\n    // Add convenience fields\n    if (result.master_brightness !== undefined) {\n        result.dimmer_on = typeof result.master_brightness === 'number' && result.master_brightness > 0;\n    }\n\n    if (result.operating_status !== undefined) {\n        result.dimmer_active = typeof result.operating_status === 'number' && result.operating_status > 0;\n    }\n\n    if (result.any_fault !== undefined) {\n        result.dimmer_healthy = !result.any_fault;\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the DC_DIMMER_STATUS message\nconst decodedData = decodeDCDimmerMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 160,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "d76a4a48e1beaed6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FURNACE_STATUS",
        "func": "// FURNACE_STATUS Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes FURNACE_STATUS messages per RV-C specification\n// Handles gas/diesel furnace operation status and control\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === FURNACE_STATUS Specific Decoders ===\n\nfunction decodeFurnaceInstance(value) {\n    // Furnace instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Furnace operating state mapping per RV-C specification\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Pre-Purge\",\n        3: \"Ignition\",\n        4: \"Flame Established\",\n        5: \"Running\",\n        6: \"Post-Purge\",\n        7: \"Shutdown\",\n        8: \"Lockout\",\n        9: \"Fault\",\n        10: \"Safety Check\",\n        11: \"Cool Down\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeFurnaceCommand(value) {\n    // Furnace command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Reset Fault\",\n        3: \"Test\",\n        4: \"Service Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Propane\",\n        2: \"Diesel\",\n        3: \"Gasoline\",\n        4: \"Natural Gas\",\n        5: \"Electric\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeAirFlow(value) {\n    // Air flow in CFM (Cubic Feet per Minute)\n    if (value <= 65000) {\n        return value; // Direct CFM value\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Ignition Failure\",\n        2: \"Flame Loss\",\n        3: \"High Temperature\",\n        4: \"Low Gas Pressure\",\n        5: \"High Gas Pressure\",\n        6: \"Fan Failure\",\n        7: \"Igniter Failure\",\n        8: \"Flame Sensor Failure\",\n        9: \"Control Board Fault\",\n        10: \"Safety Lockout\",\n        11: \"Overheat\",\n        12: \"Airflow Problem\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Flame Present\");\n    if (value & 0x02) statusBits.push(\"Igniter On\");\n    if (value & 0x04) statusBits.push(\"Gas Valve Open\");\n    if (value & 0x08) statusBits.push(\"Fan Running\");\n    if (value & 0x10) statusBits.push(\"Safety Circuit OK\");\n    if (value & 0x20) statusBits.push(\"High Limit OK\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific FURNACE_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeFurnaceInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeFurnaceCommand(value);\n        }\n        if (param.name === 'fuel type') {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'fan speed') {\n            return decodeFanSpeed(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'air flow' || param.name.includes('flow')) {\n            return decodeAirFlow(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeFurnaceMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"FURNACE_STATUS\"\n    };\n\n    // Decode based on FURNACE_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeFurnaceInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Byte 3: Exhaust Temperature\n        result.exhaust_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Intake Temperature\n        result.intake_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[5]);\n\n        // Bytes 6-7: Air Flow (16-bit, little-endian)\n        const airFlow = data[6] | (data[7] << 8);\n        result.air_flow = decodeAirFlow(airFlow);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_exhaust_temperature = data[3];\n        result.raw_intake_temperature = data[4];\n        result.raw_fan_speed = data[5];\n        result.raw_air_flow_bytes = [data[6], data[7]];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.furnace_running = state === \"running\";\n        result.furnace_heating = [\"flame established\", \"running\"].includes(state);\n        result.furnace_available = ![\"fault\", \"lockout\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"lockout\") || state.includes(\"error\");\n        result.is_starting = [\"starting\", \"pre-purge\", \"ignition\"].includes(state);\n        result.is_shutting_down = [\"post-purge\", \"shutdown\", \"cool down\"].includes(state);\n    }\n\n    // Temperature status\n    result.exhaust_temp_available = typeof result.exhaust_temperature === 'number';\n    result.intake_temp_available = typeof result.intake_temperature === 'number';\n\n    // Fan status\n    result.fan_running = typeof result.fan_speed === 'number' && result.fan_speed > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the FURNACE_STATUS message\nconst decodedData = decodeFurnaceMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 580,
        "wires": [
            [
                "9d90b7163a12d5ed"
            ]
        ]
    },
    {
        "id": "9d90b7163a12d5ed",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "FURNACE_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 580,
        "wires": []
    },
    {
        "id": "fbc5efde2c447eda",
        "type": "link in",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS in",
        "links": [
            "02bdfc59de71b5a5"
        ],
        "x": 220,
        "y": 220,
        "wires": [
            [
                "9f88f215f3f07227"
            ]
        ],
        "l": true
    },
    {
        "id": "ffd5bc5ca5695602",
        "type": "inject",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 660,
        "wires": [
            [
                "09640adb1fd08fbb"
            ]
        ]
    },
    {
        "id": "09640adb1fd08fbb",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecodedStatus\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "b797e5a52b6db5b4",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Unique STATUS",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecodedStatus = flow.get(\"uniqueDecodedStatus\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgnName);\n\n// Check if it's a new unique message\nif (!uniqueDecodedStatus.includes(newMsgStr)) {\n    uniqueDecodedStatus.push(newMsgStr);\n    flow.set(\"uniqueDecodedStatus\", uniqueDecodedStatus);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 140,
        "y": 720,
        "wires": [
            [
                "48e6dda2b2d9575e"
            ]
        ]
    },
    {
        "id": "48e6dda2b2d9575e",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "New Unique Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 720,
        "wires": []
    },
    {
        "id": "d0e2cc417cf65b90",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 340,
        "wires": []
    },
    {
        "id": "ccec30ad0f32bbdf",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_1",
        "func": "// THERMOSTAT_STATUS_1 Decoder (Updated with Flat Output) - Complete RV-C Implementation\n// Decodes THERMOSTAT_STATUS_1 messages per RV-C specification\n// Handles primary thermostat control and status information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_1 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode mapping per RV-C specification (extended)\n    const modes = {\n        0: \"Off\",\n        1: \"Auto\",\n        2: \"Heat\",\n        3: \"Cool\",\n        4: \"Furnace\",\n        5: \"Fan Only\",\n        6: \"Dry\",\n        7: \"Emergency Heat\",\n        8: \"Heat Pump\",\n        9: \"Defrost\",\n        10: \"Aux Heat\",\n        11: \"Eco Mode\",\n        12: \"Sleep Mode\",\n        13: \"Away Mode\",\n        14: \"Manual Override\",\n        15: \"Vacation Mode\",\n        16: \"Schedule Mode\",\n        17: \"Temperature Hold\",\n        18: \"Energy Save\",\n        19: \"Quick Heat\",\n        20: \"Quick Cool\",\n        21: \"System Test\",\n        22: \"Calibration\",\n        23: \"Service Mode\",\n        24: \"Installation Mode\",\n        25: \"Demo Mode\",\n        26: \"Lock Mode\",\n        27: \"Filter Mode\",\n        28: \"Humidity Control\",\n        29: \"Dehumidify\",\n        30: \"Humidify\",\n        31: \"Air Quality Mode\",\n        32: \"Zone Control\",\n        33: \"Multi-Stage Heat\",\n        34: \"Multi-Stage Cool\",\n        35: \"Heat Recovery\",\n        36: \"Ventilation Mode\",\n        37: \"Fresh Air Mode\",\n        38: \"Recirculate Mode\",\n        39: \"Purge Mode\",\n        40: \"Startup Mode\",\n        41: \"Shutdown Mode\",\n        42: \"Fault Recovery\",\n        43: \"Performance Test\",\n        44: \"Efficiency Mode\",\n        45: \"Comfort Mode\",\n        46: \"Advanced Auto\",\n        47: \"Smart Mode\",\n        48: \"Remote Control\",\n        49: \"Mobile App Control\",\n        50: \"Voice Control\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return modes[value] || `Unknown Mode ${value}`;\n}\n\nfunction decodeFanMode(value) {\n    // Fan mode mapping\n    const fanModes = {\n        0: \"Auto\",\n        1: \"On\",\n        2: \"Low\",\n        3: \"Medium\",\n        4: \"High\",\n        5: \"Variable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fanModes[value] || `Unknown Fan Mode ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset (-40°C to +170°C range)\n    if (value <= 210) {\n        const temp = value - 40; // Offset by 40 degrees\n        if (isCelsius) {\n            return parseFloat(temp.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9/5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Heating Active\");\n    if (value & 0x02) statusBits.push(\"Cooling Active\");\n    if (value & 0x04) statusBits.push(\"Fan Running\");\n    if (value & 0x08) statusBits.push(\"Aux Heat Active\");\n    if (value & 0x10) statusBits.push(\"Defrost Active\");\n    if (value & 0x20) statusBits.push(\"System Fault\");\n    if (value & 0x40) statusBits.push(\"Filter Change Required\");\n    if (value & 0x80) statusBits.push(\"Service Required\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage (0-100%)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus1Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_1\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_1 format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Operating Mode\n        result.operating_mode = decodeOperatingMode(data[1]);\n\n        // Byte 2: Fan Mode\n        result.fan_mode = decodeFanMode(data[2]);\n\n        // Byte 3: Set Point Temperature\n        result.set_point_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: System Status\n        result.system_status = decodeSystemStatus(data[5]);\n\n        // Byte 6: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[6]);\n\n        // Byte 7: Reserved/Future use\n        // Typically 0xFF in current implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_mode = data[1];\n        result.raw_fan_mode = data[2];\n        result.raw_set_point_temperature = data[3];\n        result.raw_ambient_temperature = data[4];\n        result.raw_system_status = data[5];\n        result.raw_fan_speed = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.thermostat_available = result.instance !== \"Not Available\" &&\n                                  result.operating_mode !== \"Not Available\";\n\n    result.temperature_available = typeof result.ambient_temperature === 'number' &&\n                                   typeof result.set_point_temperature === 'number';\n\n    // Calculate temperature difference if both temps available\n    if (result.temperature_available) {\n        result.temperature_difference = parseFloat((result.ambient_temperature - result.set_point_temperature).toFixed(1));\n        result.needs_heating = result.temperature_difference < -1; // More than 1°F below setpoint\n        result.needs_cooling = result.temperature_difference > 1;  // More than 1°F above setpoint\n    }\n\n    // System operating status\n    if (typeof result.system_status === 'string' && result.system_status !== \"Not Available\") {\n        result.heating_active = result.system_status.includes(\"Heating Active\");\n        result.cooling_active = result.system_status.includes(\"Cooling Active\");\n        result.fan_running = result.system_status.includes(\"Fan Running\");\n        result.aux_heat_active = result.system_status.includes(\"Aux Heat Active\");\n        result.defrost_active = result.system_status.includes(\"Defrost Active\");\n        result.system_fault = result.system_status.includes(\"System Fault\");\n        result.filter_change_required = result.system_status.includes(\"Filter Change Required\");\n        result.service_required = result.system_status.includes(\"Service Required\");\n        result.system_active = result.heating_active || result.cooling_active || result.defrost_active;\n    } else {\n        result.heating_active = false;\n        result.cooling_active = false;\n        result.fan_running = false;\n        result.aux_heat_active = false;\n        result.defrost_active = false;\n        result.system_fault = false;\n        result.filter_change_required = false;\n        result.service_required = false;\n        result.system_active = false;\n    }\n\n    // Operating mode status\n    result.is_off = result.operating_mode === \"Off\";\n    result.is_auto_mode = result.operating_mode === \"Auto\";\n    result.is_heating_mode = result.operating_mode === \"Heat\" || result.operating_mode === \"Furnace\" ||\n                             result.operating_mode === \"Heat Pump\" || result.operating_mode === \"Emergency Heat\";\n    result.is_cooling_mode = result.operating_mode === \"Cool\";\n\n    // Fan status\n    result.fan_auto_mode = result.fan_mode === \"Auto\";\n    result.fan_on_mode = result.fan_mode === \"On\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_1 message\nconst decodedData = decodeThermostatStatus1Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 340,
        "wires": [
            [
                "d0e2cc417cf65b90"
            ]
        ]
    },
    {
        "id": "45ae070eafc9a732",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "TANK_STATUS",
        "mode": "link",
        "links": [
            "61f4573c56915577"
        ],
        "x": 1200,
        "y": 220,
        "wires": [],
        "l": true
    },
    {
        "id": "bff245b2ca47ef79",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_SOURCE_STATUS",
        "mode": "link",
        "links": [
            "663120adc5ec254f"
        ],
        "x": 1230,
        "y": 280,
        "wires": [],
        "l": true
    },
    {
        "id": "7af7fb2178a714cf",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "switch_types",
        "mode": "link",
        "links": [
            "7313d7c724d31538"
        ],
        "x": 1190,
        "y": 100,
        "wires": [],
        "l": true
    },
    {
        "id": "0ecfccb41b17f21b",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "SOLAR_EQUALIZATION_CONFIGURATION_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1300,
        "wires": []
    },
    {
        "id": "1b079a5b225e1552",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1360,
        "wires": []
    },
    {
        "id": "f945d56c437bfb38",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1420,
        "wires": []
    },
    {
        "id": "3b2f348b9326267c",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WINDOW_SHADE_CONTROL_STATUS",
        "func": "// WINDOW_SHADE_CONTROL_STATUS Decoder - Complete RV-C Implementation\n// Decodes WINDOW_SHADE_CONTROL_STATUS messages per RV-C specification Section 6.39.2\n// Handles window shade operating status, motor control, and position information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === WINDOW_SHADE_CONTROL_STATUS Specific Decoders ===\n\nfunction decodeInstance(value) {\n    // Window shade instance mapping\n    if (value >= 1 && value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 0) {\n        return \"All Instances\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeGroupDetails(value) {\n    // Group membership bitmap decoding\n    if (value === 0xFF) {\n        return { type: 'special', description: 'No data' };\n    }\n    if (value === 0x00) {\n        return { type: 'special', description: 'Member of all groups' };\n    }\n\n    const groups = [];\n    for (let bit = 0; bit < 7; bit++) {\n        if (!(value & (1 << bit))) {\n            groups.push(bit + 1);\n        }\n    }\n\n    if (groups.length > 0) {\n        return {\n            type: 'standard',\n            groups: groups,\n            description: `Groups: ${groups.join(', ')}`\n        };\n    } else {\n        return {\n            type: 'standard',\n            groups: [],\n            description: \"No group membership\"\n        };\n    }\n}\n\nfunction decodeOperatingStatus(value) {\n    // Operating status (motor duty) as percentage per Table 5.3\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Value Changing\";\n    } else if (value === 252) {\n        return \"Output Flashing\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLockStatus(value) {\n    // Lock status (bits 0-1)\n    const lockMap = {\n        0: \"Load is unlocked\",\n        1: \"Load is locked\",\n        3: \"Lock command not supported\"\n    };\n    return lockMap[value] || `Unknown Lock Status ${value}`;\n}\n\nfunction decodeMotorStatus(value) {\n    // Motor status (bits 2-3)\n    const motorMap = {\n        0: \"Neither 'Forward' nor 'Reverse' output is on\",\n        1: \"Either 'Forward' or 'Reverse' output is on (Motor active)\"\n    };\n    return motorMap[value] || `Unknown Motor Status ${value}`;\n}\n\nfunction decodeForwardStatus(value) {\n    // Forward status (bits 4-5)\n    const forwardMap = {\n        0: \"'Forward' output not on\",\n        1: \"'Forward' output is on (Shade raising/opening)\"\n    };\n    return forwardMap[value] || `Unknown Forward Status ${value}`;\n}\n\nfunction decodeReverseStatus(value) {\n    // Reverse status (bits 6-7)\n    const reverseMap = {\n        0: \"'Reverse' output not on\",\n        1: \"'Reverse' output is on (Shade lowering/closing)\"\n    };\n    return reverseMap[value] || `Unknown Reverse Status ${value}`;\n}\n\nfunction decodeDuration(value) {\n    // Duration decoding\n    if (value === 0) {\n        return \"Delay/duration expired\";\n    } else if (value >= 1 && value <= 239) {\n        return `${value} seconds remaining`;\n    } else if (value === 240) {\n        return \"240 or more seconds remaining\";\n    } else if (value === 255) {\n        return \"No delay/duration active\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLastCommand(value) {\n    // Last command executed mapping per Table 6.39.3c\n    const commandMap = {\n        4: \"Stop\",\n        129: \"Forward (Open Shade)\", // 0x81\n        65: \"Reverse (Close Shade)\", // 0x41\n        133: \"Toggle Forward\", // 0x85\n        69: \"Toggle Reverse\", // 0x45\n        16: \"Tilt\", // 0x10\n        33: \"Lock\", // 0x21\n        34: \"Unlock\" // 0x22\n    };\n    return commandMap[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeOvercurrentStatus(value) {\n    // Overcurrent status (bits 0-1)\n    const overcurrentMap = {\n        0: \"Load output not in overcurrent\",\n        1: \"Load output has drawn overcurrent\",\n        3: \"Overcurrent status unavailable or not supported\"\n    };\n    return overcurrentMap[value] || `Unknown Overcurrent Status ${value}`;\n}\n\nfunction decodeOverrideStatus(value) {\n    // Override status (bits 2-3)\n    const overrideMap = {\n        0: \"External override is inactive\",\n        1: \"External override is active\",\n        3: \"Override status is unavailable or not supported\"\n    };\n    return overrideMap[value] || `Unknown Override Status ${value}`;\n}\n\nfunction decodeDisableStatus(value, disableNumber) {\n    // Disable status for Disable1 (bits 4-5) or Disable2 (bits 6-7)\n    const disableMap = {\n        0: `Disable ${disableNumber} is not active`,\n        1: `Disable ${disableNumber} is active`,\n        3: `Disable ${disableNumber} is not supported`\n    };\n    return disableMap[value] || `Unknown Disable${disableNumber} Status ${value}`;\n}\n\n// === Main Decode Function ===\n\nfunction decodeWindowShadeControlStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"WINDOW_SHADE_CONTROL_STATUS\"\n    };\n\n    if (data.length < 7) {\n        return { error: \"Invalid data length for WINDOW_SHADE_CONTROL_STATUS - expected at least 7 bytes\" };\n    }\n\n    // Byte 0: Instance\n    result.instance = decodeInstance(data[0]);\n\n    // Byte 1: Group\n    const groupDetails = decodeGroupDetails(data[1]);\n    result.group_description = groupDetails.description;\n    if (groupDetails.groups) {\n        result.groups = groupDetails.groups;\n    }\n\n    // Byte 2: Operating Status (Motor Duty)\n    result.operating_status = decodeOperatingStatus(data[2]);\n\n    // Byte 3: Lock Status, Motor Status, Forward Status, Reverse Status\n    const byte3 = data[3];\n    const lockStatusRaw = decodeBits(byte3, 0, 1);\n    const motorStatusRaw = decodeBits(byte3, 2, 3);\n    const forwardStatusRaw = decodeBits(byte3, 4, 5);\n    const reverseStatusRaw = decodeBits(byte3, 6, 7);\n\n    result.lock_status = decodeLockStatus(lockStatusRaw);\n    result.motor_status = decodeMotorStatus(motorStatusRaw);\n    result.forward_status = decodeForwardStatus(forwardStatusRaw);\n    result.reverse_status = decodeReverseStatus(reverseStatusRaw);\n\n    // Byte 4: Duration\n    result.duration = decodeDuration(data[4]);\n\n    // Byte 5: Last Command\n    result.last_command = decodeLastCommand(data[5]);\n\n    // Byte 6: Overcurrent Status, Override Status, Disable1 Status, Disable2 Status\n    const byte6 = data[6];\n    const overcurrentStatusRaw = decodeBits(byte6, 0, 1);\n    const overrideStatusRaw = decodeBits(byte6, 2, 3);\n    const disable1StatusRaw = decodeBits(byte6, 4, 5);\n    const disable2StatusRaw = decodeBits(byte6, 6, 7);\n\n    result.overcurrent_status = decodeOvercurrentStatus(overcurrentStatusRaw);\n    result.override_status = decodeOverrideStatus(overrideStatusRaw);\n    result.disable1_status = decodeDisableStatus(disable1StatusRaw, 1);\n    result.disable2_status = decodeDisableStatus(disable2StatusRaw, 2);\n\n    // Raw values for debugging\n    result.raw_instance = data[0];\n    result.raw_group = data[1];\n    result.raw_operating_status = data[2];\n    result.raw_byte3 = byte3;\n    result.raw_lock_status = lockStatusRaw;\n    result.raw_motor_status = motorStatusRaw;\n    result.raw_forward_status = forwardStatusRaw;\n    result.raw_reverse_status = reverseStatusRaw;\n    result.raw_duration = data[4];\n    result.raw_last_command = data[5];\n    result.raw_byte6 = byte6;\n    result.raw_overcurrent_status = overcurrentStatusRaw;\n    result.raw_override_status = overrideStatusRaw;\n    result.raw_disable1_status = disable1StatusRaw;\n    result.raw_disable2_status = disable2StatusRaw;\n\n    // Add convenience fields for Home Assistant integration\n    result.is_locked = lockStatusRaw === 1;\n    result.motor_active = motorStatusRaw === 1;\n    result.shade_opening = forwardStatusRaw === 1;\n    result.shade_closing = reverseStatusRaw === 1;\n    result.shade_moving = result.shade_opening || result.shade_closing;\n    result.has_overcurrent = overcurrentStatusRaw === 1;\n    result.override_active = overrideStatusRaw === 1;\n    result.disable1_active = disable1StatusRaw === 1;\n    result.disable2_active = disable2StatusRaw === 1;\n    result.any_disable_active = result.disable1_active || result.disable2_active;\n\n    // Determine shade position status\n    if (typeof result.operating_status === 'number') {\n        result.shade_position_percent = result.operating_status;\n        result.shade_fully_open = result.operating_status >= 99;\n        result.shade_fully_closed = result.operating_status <= 1;\n        result.shade_partially_open = result.operating_status > 1 && result.operating_status < 99;\n    } else {\n        result.shade_position_percent = null;\n        result.shade_fully_open = false;\n        result.shade_fully_closed = false;\n        result.shade_partially_open = false;\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the WINDOW_SHADE_CONTROL_STATUS message\nlet decodedData;\nif (dgn === '1FEDE') {\n    decodedData = decodeWindowShadeControlStatusMessage(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 160,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "eb3524b2b7bf51e5",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode LOCK_STATUS",
        "func": "// LOCK_STATUS Decoder - Complete RV-C Implementation\n// Decodes LOCK_STATUS messages per RV-C specification Section 6.40.2\n// Handles door/window lock status, motion detection, and position information\n// Input: msg.payload with {dgn, dataPayload, ...other fields}\n// Output: msg.payload with decoded fields merged at top level\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === LOCK_STATUS Specific Decoders ===\n\nfunction decodeInstance(value) {\n    // Lock instance mapping per Section 6.40.1\n    if (value >= 1 && value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 0) {\n        return \"Invalid\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLockStatus(value) {\n    // Lock status (bits 0-1)\n    const lockMap = {\n        0: \"Unlocked\",\n        1: \"Locked\"\n    };\n    return lockMap[value] || `Unknown Lock Status ${value}`;\n}\n\nfunction decodeMotion(value) {\n    // Motion status\n    const motionMap = {\n        0: \"No Motion\",\n        1: \"Opening\",\n        2: \"Closing\"\n    };\n    return motionMap[value] || `Unknown Motion ${value}`;\n}\n\nfunction decodePosition(value) {\n    // Position as percentage per Table 5.3 (100% = Fully Open)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeVoltage(value) {\n    // Voltage decoding per Table 5.3 (16-bit, little-endian)\n    if (value === 65535) {\n        return \"Not Available\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65532) {\n        return \"Error\";\n    } else if (value <= 65530) {\n        // Voltage in mV with 0.1V resolution\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1V per step\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeLockStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"LOCK_STATUS\"\n    };\n\n    if (data.length < 6) {\n        return { error: \"Invalid data length for LOCK_STATUS - expected at least 6 bytes\" };\n    }\n\n    // Byte 0: Instance\n    result.instance = decodeInstance(data[0]);\n\n    // Byte 1: Lock Status (bits 0-1)\n    const byte1 = data[1];\n    const lockStatusRaw = decodeBits(byte1, 0, 1);\n    result.lock_status = decodeLockStatus(lockStatusRaw);\n\n    // Byte 2: Motion\n    result.motion = decodeMotion(data[2]);\n\n    // Byte 3: Position\n    result.position = decodePosition(data[3]);\n\n    // Bytes 4-5: Voltage (16-bit, little-endian)\n    const voltageRaw = decodeUint16(data, 4);\n    result.voltage = decodeVoltage(voltageRaw);\n\n    // Raw values for debugging\n    result.raw_instance = data[0];\n    result.raw_byte1 = byte1;\n    result.raw_lock_status = lockStatusRaw;\n    result.raw_motion = data[2];\n    result.raw_position = data[3];\n    result.raw_voltage_bytes = data.length >= 6 ? [data[4], data[5]] : null;\n    result.raw_voltage = voltageRaw;\n\n    // Include additional bytes if present\n    if (data.length > 6) {\n        for (let i = 6; i < data.length; i++) {\n            result[`raw_byte${i}`] = data[i];\n        }\n    }\n\n    // Add convenience fields for Home Assistant integration\n    result.is_locked = lockStatusRaw === 1;\n    result.is_unlocked = lockStatusRaw === 0;\n    result.is_moving = data[2] === 1 || data[2] === 2;\n    result.is_opening = data[2] === 1;\n    result.is_closing = data[2] === 2;\n    result.is_stationary = data[2] === 0;\n\n    // Position status (if available)\n    if (typeof result.position === 'number') {\n        result.position_percent = result.position;\n        result.fully_open = result.position >= 99;\n        result.fully_closed = result.position <= 1;\n        result.partially_open = result.position > 1 && result.position < 99;\n    } else {\n        result.position_percent = null;\n        result.fully_open = false;\n        result.fully_closed = false;\n        result.partially_open = false;\n    }\n\n    // Voltage status (if available)\n    if (typeof result.voltage === 'number') {\n        result.voltage_volts = result.voltage;\n        result.low_voltage = result.voltage < 11.0; // Typical 12V system low voltage threshold\n        result.high_voltage = result.voltage > 15.0; // Typical 12V system high voltage threshold\n        result.normal_voltage = result.voltage >= 11.0 && result.voltage <= 15.0;\n    } else {\n        result.voltage_volts = null;\n        result.low_voltage = false;\n        result.high_voltage = false;\n        result.normal_voltage = false;\n    }\n\n    // Lock and motion combination status\n    result.locked_and_closed = result.is_locked && result.fully_closed;\n    result.unlocked_and_open = result.is_unlocked && result.fully_open;\n    result.secure_status = result.locked_and_closed ? \"Secure\" : \"Not Secure\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\n\nif (!dgn || !dataPayload) {\n    node.warn('Missing required fields: dgn and/or dataPayload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof dataPayload !== 'string' || dataPayload.length % 2 !== 0) {\n    node.warn('Invalid dataPayload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    const hexByte = dataPayload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in dataPayload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the LOCK_STATUS message\nlet decodedData;\nif (dgn === '1FEE5') {\n    decodedData = decodeLockStatusMessage(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.dataPayload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 200,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "7e609140970f546c",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Load on Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 200,
        "y": 80,
        "wires": [
            [
                "74c7e4a6cc2508eb"
            ]
        ]
    },
    {
        "id": "74c7e4a6cc2508eb",
        "type": "file in",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Read DGN table",
        "filename": "/config/projects/rv-link/rvc/dgn-summary-table.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "allProps": false,
        "x": 400,
        "y": 80,
        "wires": [
            [
                "c78420a075d43408"
            ]
        ]
    },
    {
        "id": "cd670f6465b6374b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Store dgnTable",
        "func": "// Convert the data to a Map when initially storing it\nconst dgnMap = new Map(\n    msg.payload.map(entry => [\n        entry.Hex.toString().toUpperCase(),\n        entry.DGN\n    ])\n);\n\n// Add the special case for FECA\n//if (dgnMap.has('FECA')) {\n//    dgnMap.set('1FECA', dgnMap.get('FECA'));\n//}\n\n// Store the Map in global context\nglobal.set('dgnMap', dgnMap);\n\n// Count the number of records\nconst decoderCount = dgnMap.size;\n\n// Update the node status to indicate success\nnode.status({ fill: 'green', shape: 'dot', text: `Config loaded, ${decoderCount} records` });\nreturn null;",
        "outputs": 0,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 80,
        "wires": []
    },
    {
        "id": "c78420a075d43408",
        "type": "json",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 610,
        "y": 80,
        "wires": [
            [
                "cd670f6465b6374b"
            ]
        ]
    },
    {
        "id": "cacf35b859af22a9",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out: Retain FALSE",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 670,
        "y": 580,
        "wires": []
    },
    {
        "id": "e7ae35364ce60f3f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 640,
        "wires": []
    },
    {
        "id": "f658418a7b9b4857",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out: Retain TRUE",
        "links": [
            "a2334b77d3764815",
            "d38c75bc1474be23",
            "d3a13b531babee66",
            "d4ef1d361f084b58",
            "ea29386f9f8682bc"
        ],
        "x": 210,
        "y": 580,
        "wires": [
            [
                "cacf35b859af22a9",
                "e7ae35364ce60f3f"
            ]
        ],
        "l": true
    },
    {
        "id": "b86f82e84d961549",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/+/+/set",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 460,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "64c5e5cfd4382453",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "mode": "link",
        "links": [
            "a3b957142479c075"
        ],
        "x": 610,
        "y": 460,
        "wires": [],
        "l": true
    },
    {
        "id": "2110ea4d0b85f784",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "topic": "can/raw",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 400,
        "wires": [
            [
                "32add109922d428a",
                "4ad3b304d4f1e27b",
                "a922fdb6b43bbced"
            ]
        ]
    },
    {
        "id": "958fed9f12301f59",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "mode": "link",
        "links": [
            "2fcbc4d630144362"
        ],
        "x": 620,
        "y": 400,
        "wires": [],
        "l": true
    },
    {
        "id": "8d7d5d3ea117cf79",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decode RVC CAN",
        "func": "// RVC CAN Message Parser\n// Decodes a raw RVC CAN message string into a structured object.\n// Input: msg.payload (string) - e.g., \"19FEDA8C#3AFF00FDFF2100FF\"\n// Output: msg.payload (object) with decoded CAN message components\n\nconst originalMessage = msg.payload;\n\n// 1. Validate input\nif (!originalMessage || typeof originalMessage !== 'string') {\n    node.warn(\"Invalid message payload: expected string, got \" + typeof originalMessage);\n    return null;\n}\n\nconst dgnMap = global.get('dgnMap');\nif (!dgnMap) {\n    node.error(\"dgnMap not found in global context. Ensure the map is initialized.\");\n    return null;\n}\n\n// 2. Parse CAN message format: CANID#PAYLOAD\nconst parts = originalMessage.split('#');\nif (parts.length !== 2) {\n    node.warn(\"Invalid CAN message format: \" + originalMessage);\n    return null;\n}\n\nconst canIdHex = parts[0];\nconst dataPayload = parts[1];\n\nconst canIdNum = parseInt(canIdHex, 16);\nif (isNaN(canIdNum) || canIdHex.length > 8) {\n    node.warn(\"Invalid CAN ID: \" + canIdHex);\n    return null;\n}\n\n// 3. Extract CAN ID fields and determine DGN\nconst priority = (canIdNum >> 26) & 0x7;\nconst sourceAddress = (canIdNum & 0xFF).toString(16).toUpperCase().padStart(2, '0');\n\nlet dgn = ((canIdNum >> 8) & 0x1FFFF).toString(16).toUpperCase();\nlet dgnName = dgnMap.get(dgn);\n\n// If the lookup fails and the DGN is 4 characters, try prepending a '1'\nif (!dgnName && dgn.length === 4) {\n    const alternateDgn = '1' + dgn;\n    const alternateName = dgnMap.get(alternateDgn);\n\n    if (alternateName) {\n        dgn = alternateDgn;\n        dgnName = alternateName;\n    }\n}\n\n// If still not found, check for specific proprietary overrides or the general proprietary range\nif (!dgnName) {\n    if (dgn === 'EF64') {\n        dgnName = \"AQUAHOT\";\n    } else if (dgn.startsWith('EF')) {\n        dgnName = \"PROPRIETARY\";\n    }\n}\n\n// If it's still not found after all checks, set it to UNKNOWN\nif (!dgnName) {\n    dgnName = \"UNKNOWN\";\n}\n\n// 4. Create structured output\nmsg.payload = {\n    originalMessage: originalMessage,\n    dgn: dgn,\n    dgnName: dgnName,\n    sourceAddress: sourceAddress,\n    priority: priority,\n    dataPayload: dataPayload,\n    canIdHex: canIdHex,\n    canIdDecimal: canIdNum,\n    dataLength: dataPayload.length / 2\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 980,
        "wires": [
            [
                "ac47ce53a9fc3f21",
                "698efabc308fece6",
                "a16ce99da6a2a88f",
                "2e131d4d25819c93",
                "a2dad25eb05117f7",
                "fc66c16576e28548",
                "c6fb02a17f709e08",
                "a6594a9464d8fe4e"
            ]
        ]
    },
    {
        "id": "ac47ce53a9fc3f21",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decoded",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 1100,
        "wires": []
    },
    {
        "id": "698efabc308fece6",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dataPayload",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dataPayload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 610,
        "y": 1060,
        "wires": []
    },
    {
        "id": "a16ce99da6a2a88f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgn",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgn",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 860,
        "wires": []
    },
    {
        "id": "2e131d4d25819c93",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgnName",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgnName",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 900,
        "wires": []
    },
    {
        "id": "a2dad25eb05117f7",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "originalMessage",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.originalMessage",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 820,
        "wires": []
    },
    {
        "id": "fc66c16576e28548",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "sourceAddress",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.sourceAddress",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 940,
        "wires": []
    },
    {
        "id": "c6fb02a17f709e08",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "priority",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.priority",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 1020,
        "wires": []
    },
    {
        "id": "2fcbc4d630144362",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "CAN in",
        "links": [
            "958fed9f12301f59"
        ],
        "x": 150,
        "y": 980,
        "wires": [
            [
                "8d7d5d3ea117cf79"
            ]
        ],
        "l": true
    },
    {
        "id": "a6594a9464d8fe4e",
        "type": "switch",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DM-RV",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DATE_TIME_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_COMMAND_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ADDRESS_CLAIMED",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AQUAHOT",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "PROPRIETARY",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "UNKNOWN",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 9,
        "x": 830,
        "y": 980,
        "wires": [
            [],
            [],
            [
                "02bdfc59de71b5a5"
            ],
            [
                "37b11a996fc2757e"
            ],
            [
                "45414bacecada477"
            ],
            [
                "8f99241c9a1cfbde"
            ],
            [
                "5f6336442bfb9808"
            ],
            [
                "c781b519a9f9b156"
            ],
            [
                "d0150fd6556514e6"
            ]
        ]
    },
    {
        "id": "32add109922d428a",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "can/raw",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 340,
        "wires": []
    },
    {
        "id": "a4028527eb23fa04",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset uniqueDecoded",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1100,
        "y": 1340,
        "wires": [
            [
                "092c751dcdd12270"
            ]
        ]
    },
    {
        "id": "092c751dcdd12270",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset function",
        "func": "flow.set(\"uniqueUNKNOWN\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 1340,
        "wires": [
            []
        ]
    },
    {
        "id": "c781b519a9f9b156",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Unique UNKNOWN",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueUNKNOWN = flow.get(\"uniqueUNKNOWN\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload);\n\n// Check if it's a new unique message\nif (!uniqueUNKNOWN.includes(newMsgStr)) {\n    uniqueUNKNOWN.push(newMsgStr);\n    flow.set(\"uniqueUNKNOWN\", uniqueUNKNOWN);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 1400,
        "wires": [
            [
                "eea1641469efb23f"
            ]
        ]
    },
    {
        "id": "eea1641469efb23f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "New UNKNOWN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1350,
        "y": 1400,
        "wires": []
    },
    {
        "id": "c6fd91cf9695813b",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "Open/Close",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "control",
        "payload": "toggle",
        "payloadType": "str",
        "x": 190,
        "y": 340,
        "wires": [
            [
                "4ad3b304d4f1e27b"
            ]
        ]
    },
    {
        "id": "4ad3b304d4f1e27b",
        "type": "gate",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "",
        "controlTopic": "control",
        "defaultState": "closed",
        "openCmd": "open",
        "closeCmd": "close",
        "toggleCmd": "toggle",
        "defaultCmd": "default",
        "statusCmd": "status",
        "persist": false,
        "x": 370,
        "y": 400,
        "wires": [
            [
                "958fed9f12301f59"
            ]
        ]
    },
    {
        "id": "02bdfc59de71b5a5",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "STATUS out",
        "mode": "link",
        "links": [
            "fbc5efde2c447eda"
        ],
        "x": 1030,
        "y": 820,
        "wires": [],
        "l": true
    },
    {
        "id": "d34a8c1fd2cc4320",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 610,
        "y": 520,
        "wires": []
    },
    {
        "id": "37b11a996fc2757e",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "DC_DIMMER_COMMAND_2",
        "mode": "link",
        "links": [
            "44947b512cb27b5b"
        ],
        "x": 1080,
        "y": 880,
        "wires": [],
        "l": true
    },
    {
        "id": "515386b6b0d01893",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Load on Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 200,
        "y": 1600,
        "wires": [
            [
                "b846bc1605dae821"
            ]
        ]
    },
    {
        "id": "b846bc1605dae821",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim request",
        "func": "// RV-C Address Claim - Send Initial Claim\n// Generates a persistent unique ID, selects an address, and broadcasts the\n// ADDRESS_CLAIMED message (DGN EE00h) to claim the address.\n\n// --- Step 1: Handle Manual Reset Command (if triggered) ---\nif (msg.topic === \"reset_device_id\") {\n  // Clear the saved unique ID from persistent storage\n  global.set(\"my_persistent_rvc_id\", null);\n  // Reset the address attempt counter to start fresh\n  context.set(\"address_attempt\", null);\n  node.warn(\"Persistent DEVICE_NAME cleared. Generating a new one and starting claim...\");\n  // By not returning, we allow the script to continue and generate a new ID immediately.\n}\n\n\n// --- Configuration ---\nconst STARTING_ADDRESS = 223;\nconst MIN_ADDRESS = 208;\n\n\n// --- Step 2: Create or Retrieve a Persistent Unique DEVICE_NAME ---\nlet uniqueId = global.get(\"my_persistent_rvc_id\");\n\nif (!uniqueId) {\n  // No ID found, so generate a new one.\n  const randomSerial = Math.floor(Math.random() * 0x1FFFFF);\n  const randomSerialHex = randomSerial.toString(16).padStart(6, '0').toUpperCase();\n  uniqueId = \"8000000000\" + randomSerialHex;\n\n  // Save this new ID to the global context for future use.\n  global.set(\"my_persistent_rvc_id\", uniqueId);\n  //node.warn(\"Generated and saved a new persistent DEVICE_NAME: \" + uniqueId);\n}\nconst DEVICE_NAME = uniqueId;\n\n\n// --- Step 3: Select an Address to Claim ---\nconst usedAddresses = new Set(flow.get(\"used_addresses\") || []);\nlet addressToTry = context.get(\"address_attempt\") || STARTING_ADDRESS;\n\nif (msg.topic === \"address_claim_retry\") {\n  addressToTry--;\n  node.warn(`Lost address conflict. Trying next address: ${addressToTry}`);\n}\n\nwhile (usedAddresses.has(addressToTry) && addressToTry >= MIN_ADDRESS) {\n  addressToTry--;\n  node.warn(`Address ${addressToTry + 1} is known to be in use, skipping to ${addressToTry}`);\n}\n\nif (addressToTry < MIN_ADDRESS) {\n  node.error(`Exhausted all addresses in the valid range (${STARTING_ADDRESS}-${MIN_ADDRESS}). Address claiming failed.`);\n  flow.set(\"claim_in_progress\", false);\n  return null;\n}\n\ncontext.set(\"address_attempt\", addressToTry);\n\n\n// --- Step 4: Build and Send the Claim Message ---\nconst DGN = \"EE00\";\nconst priority = 6;\nconst canIdNum = (priority << 26) | (parseInt(DGN, 16) << 8) | addressToTry;\nconst canIdHex = canIdNum.toString(16).padStart(8, '0').toUpperCase();\nconst dataPayload = DEVICE_NAME;\nconst canMessage = `${canIdHex}#${dataPayload}`;\n\nflow.set(\"claiming_address\", addressToTry);\nflow.set(\"claim_in_progress\", true);\nflow.set(\"our_device_name\", DEVICE_NAME);\n\nmsg.payload = canMessage;\nmsg.topic = \"can/send\";\nmsg.claiming_address = addressToTry;\n\nnode.log(`Attempting to claim address ${addressToTry} (0x${addressToTry.toString(16).toUpperCase()})`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 1600,
        "wires": [
            [
                "55071115a3fe7c2c",
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "55071115a3fe7c2c",
        "type": "delay",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 930,
        "y": 1660,
        "wires": [
            [
                "6423c433e099d2a5"
            ]
        ]
    },
    {
        "id": "4e46ba83df00a31b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim monitor",
        "func": "// RV-C Address Claim Monitor Function\n// Assumes it ONLY receives decoded ADDRESS_CLAIMED messages (DGN EE00)\n// Compares device NAMEs to determine winner in case of conflict\n\nconst claimInProgress = flow.get(\"claim_in_progress\");\nif (!claimInProgress) {\n    return null; // Not in the claiming process\n}\n\nconst claimingAddress = flow.get(\"claiming_address\");\nconst ourDeviceName = flow.get(\"our_device_name\");\nconst competitorName = msg.payload.dataPayload.toUpperCase();\nconst sourceAddressInt = parseInt(msg.payload.sourceAddress, 16);\n\n// Check if a message is for the same address we are trying to claim\nif (sourceAddressInt === claimingAddress) {\n\n    // *** NEW CHECK ***\n    // First, verify this isn't our own message being echoed back.\n    // If the NAMEs are identical, it's our own claim. Ignore it and let the timer run.\n    if (competitorName === ourDeviceName) {\n        // This is our own message, not a real conflict.\n        return null;\n    }\n    // *** END OF NEW CHECK ***\n\n    // If we get here, it's a real conflict from a different device.\n    node.warn(`Address ${claimingAddress} conflict detected!`);\n    node.warn(`Our NAME: ${ourDeviceName}, Competitor NAME: ${competitorName}`);\n\n    // Compare NAMEs - Lower numerical value wins\n    const ourNameValue = BigInt(\"0x\" + ourDeviceName);\n    const competitorNameValue = BigInt(\"0x\" + competitorName);\n\n    if (ourNameValue < competitorNameValue) {\n        // WE WIN\n        node.warn(`We WIN the conflict. Continuing to claim address ${claimingAddress}`);\n        return null;\n    } else {\n        // WE LOSE\n        node.warn(`We LOSE the conflict. Cancelling timer and trying next address.`);\n        flow.set(\"claim_in_progress\", false);\n\n        const retryMsg = { topic: \"address_claim_retry\" };\n        const resetTimerMsg = { reset: true };\n\n        return [retryMsg, resetTimerMsg];\n    }\n}\n\n// If we reach here, it's a claim for a different address, so ignore it.\nreturn null;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 1660,
        "wires": [
            [
                "b846bc1605dae821"
            ],
            [
                "55071115a3fe7c2c"
            ]
        ]
    },
    {
        "id": "45414bacecada477",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "ADDRESS_CLAIMED",
        "mode": "link",
        "links": [
            "f01db5ebc3ae2e18"
        ],
        "x": 1060,
        "y": 940,
        "wires": [],
        "l": true
    },
    {
        "id": "f01db5ebc3ae2e18",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "ADDRESS_CLAIMED",
        "links": [
            "45414bacecada477"
        ],
        "x": 200,
        "y": 1660,
        "wires": [
            [
                "4e46ba83df00a31b"
            ]
        ],
        "l": true
    },
    {
        "id": "a2334b77d3764815",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "MQTT Out",
        "mode": "link",
        "links": [
            "f658418a7b9b4857",
            "74329f13cbbc528a"
        ],
        "x": 1370,
        "y": 1600,
        "wires": [],
        "l": true
    },
    {
        "id": "6423c433e099d2a5",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim success",
        "func": "// RV-C Address Claim Success Function\n// Called after 250ms timer expires - finalizes address claim if no conflict lost\n// Reference: RV-C Spec Section 3.3.2 - Source Address Claiming\n//\n// IMPORTANT: This does NOT send a second ADDRESS_CLAIMED message.\n// We already sent ADDRESS_CLAIMED at the start of the process.\n// Success = 250ms timer expires without losing a conflict.\n\n// Get the address we were trying to claim when this timer started\nconst claimedAddress = msg.claiming_address;\n\nif (claimedAddress === undefined || claimedAddress === null) {\n    node.error(\"No address to claim - timer message missing claiming_address\");\n    return null;\n}\n\n// Check if this timer is still valid (claim hasn't been cancelled by monitor)\nconst claimInProgress = flow.get(\"claim_in_progress\");\nif (!claimInProgress) {\n    // Claim was cancelled during the 250ms window (we lost a conflict)\n    node.warn(`Timer expired for address ${claimedAddress}, but claim was cancelled - ignoring`);\n    return null;\n}\n\n// Verify we're still trying to claim the same address\nconst currentClaimingAddress = flow.get(\"claiming_address\");\nif (currentClaimingAddress !== claimedAddress) {\n    node.warn(`Timer expired for address ${claimedAddress}, but we're now trying ${currentClaimingAddress} - ignoring stale timer`);\n    return null;\n}\n\n// SUCCESS! No conflict detected during the 250ms monitoring window\n// Store the claimed address to global context\nglobal.set(\"rvc_source_address\", claimedAddress);\n\n// Clear claiming flags\nflow.set(\"claim_in_progress\", false);\nflow.set(\"claiming_address\", null);\nflow.set(\"our_device_name\", null);\n\n//node.warn(`Successfully claimed address ${claimedAddress} (0x${claimedAddress.toString(16).toUpperCase()})`);\n//node.warn(`Address stored to global.rvc_source_address: ${claimedAddress}`);\n\n// Return null - No CAN message to send\n// We already broadcast ADDRESS_CLAIMED at the beginning of the process\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 1660,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "a922fdb6b43bbced",
        "type": "function",
        "z": "292e70a6ba25b323",
        "d": true,
        "g": "3c819b7900145438",
        "name": "function 1",
        "func": "// Filters raw incoming CAN messages to ONLY pass messages sent by this HA system\n// Shows ALL messages transmitted by HA regardless of DGN type\n// Input: msg.payload (string) - raw CAN message e.g., \"19FEDB8C#03FFC805FF00FFFF\"\n// Output: null (block) or original msg (pass through)\n\nconst originalMessage = msg.payload;\n\n// Validate input\nif (!originalMessage || typeof originalMessage !== 'string') {\n    return null;\n}\n\n// Parse CAN message format: CANID#PAYLOAD\nconst parts = originalMessage.split('#');\nif (parts.length !== 2) {\n    return null;\n}\n\nconst canId = parts[0];\n\n// Parse CAN ID as hexadecimal\nconst canIdNum = parseInt(canId, 16);\nif (isNaN(canIdNum)) {\n    return null;\n}\n\n// Extract Source Address (lowest 8 bits of CAN ID)\nconst sourceAddress = canIdNum & 0xFF;\n\n// Get the RVC source address claimed by this HA system\nconst ourSourceAddress = global.get(\"rvc_source_address\");\n\n// ONLY allow messages from our claimed source address\nif (sourceAddress === ourSourceAddress) {\n    return msg;\n}\n\n// Block all other messages\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 360,
        "wires": [
            [
                "982faa37c0038bf4"
            ]
        ]
    },
    {
        "id": "4f33fad10d85b69d",
        "type": "function",
        "z": "292e70a6ba25b323",
        "d": true,
        "g": "3c819b7900145438",
        "name": "Decode DC_DIMMER_COMMAND_2",
        "func": "// === Main Decode Function (Updated for July 31, 2025 Spec) ===\nfunction decodeDcDimmerCommand2Message(dgn, data) {\n    const result = {};\n    if (data.length < 7) return { error: \"Invalid data length for DGN 1FEDBh\" };\n\n    // Byte 0: Instance\n    result.instance = data[0]; // [cite: 269]\n\n    // Byte 1: Group (bitmap)\n    const groupDetails = getGroupDetails(data[1]); // [cite: 269]\n    result.group_description = groupDetails.description;\n    \n    // Byte 2: Desired Level\n    result.desired_level = decodeDesiredLevel(data[2]); // [cite: 269]\n    \n    // Byte 3: Command\n    result.command = decodeCommand(data[3]); // [cite: 269]\n    \n    // --- UPDATED SECTION ---\n    \n    // Byte 4: Delay/Duration\n    result.delay_duration = decodeDelayDuration(data[4]); // \n    \n    // Byte 5: Interlock\n    const interlockValue = decodeBits(data[5], 0, 1); // \n    const interlocks = { 0: \"No Interlock active\", 1: \"Interlock A\", 2: \"Interlock B\" };\n    result.interlock = interlocks[interlockValue] || \"Invalid\";\n\n    // Byte 6: Ramp Time\n    result.ramp_time = decodeRampTime(data[6]); // \n    \n    // --- END UPDATED SECTION ---\n    \n    return result;\n}\n\n// === Full Node-RED Function (with all helpers) ===\n\n// Helper Functions (assumed to be correct from previous versions)\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\nfunction decodeRampTime(value) {\n    if (value === 0) return 0;\n    if (value >= 1 && value <= 250) return parseFloat((value * 0.1).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\nfunction decodeDesiredLevel(value) {\n    if (value >= 0 && value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value >= 230 && value <= 249) return `Scene ${value - 229}`;\n    if (value === 250) return \"Dimmed Memory\";\n    if (value === 251) return \"Master Memory\";\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\nfunction getGroupDetails(value) {\n    if (value === 0xFF) return { type: 'special', description: 'No data' };\n    if (value & 0x80) return { type: 'non-group', description: 'Non-group or Node Group command' };\n    if (value === 0x00) return { type: 'special', description: 'Member of all groups' };\n    const groups = []; const groupBits = value & 0x7F;\n    for (let bit = 0; bit < 7; bit++) { if (!(groupBits & (1 << bit))) { groups.push(bit + 1); } }\n    return { type: 'standard', groups: groups, description: groups.length > 0 ? `Groups: ${groups.join(', ')}` : \"No group membership\"};\n}\nfunction decodeDelayDuration(value) {\n    if (value >= 0 && value <= 240) return `${value} seconds`;\n    if (value >= 241 && value <= 250) return `${value - 236} minutes`;\n    if (value === 255) return \"Continuous\";\n    return \"Invalid\";\n}\nfunction decodeCommand(value) {\n    const commands = { 0: \"Set Level (Delay)\", 1: \"On (Duration)\", 2: \"On (Delay)\", 3: \"Off (Delay)\", 4: \"Stop\", 5: \"Toggle\", 6: \"Memory Off\", 7: \"Save Scene\", 11: \"Ramp Brightness\", 12: \"Ramp Toggle\", 13: \"Ramp Up\", 14: \"Ramp Down\", 15: \"Ramp Up/Down\", 16: \"Ramp Up/Down Toggle\", 21: \"Lock\", 22: \"Unlock\", 31: \"Flash\", 32: \"Flash Momentary\" };\n    return commands[value] || `unknown command: ${value}`;\n}\n\n// Main Decode Function (Updated for July 31, 2025 Spec)\nfunction decodeDcDimmerCommand2Message(dgn, data) {\n    const result = {};\n    if (data.length < 7) return { error: \"Invalid data length for DGN 1FEDBh\" };\n    result.instance = data[0]; // [cite: 269]\n    const groupDetails = getGroupDetails(data[1]); // [cite: 269]\n    result.group_description = groupDetails.description;\n    result.desired_level = decodeDesiredLevel(data[2]); // [cite: 269]\n    result.command = decodeCommand(data[3]); // [cite: 269]\n    result.delay_duration = decodeDelayDuration(data[4]); // \n    const interlockValue = decodeBits(data[5], 0, 1); // \n    const interlocks = { 0: \"No Interlock active\", 1: \"Interlock A\", 2: \"Interlock B\" };\n    result.interlock = interlocks[interlockValue] || \"Invalid\";\n    result.ramp_time = decodeRampTime(data[6]); // \n    return result;\n}\n\n// === Main Logic ===\nconst incomingPayload = msg.payload;\nconst { dgn, dataPayload } = incomingPayload;\nconst dataBytes = [];\nfor (let i = 0; i < dataPayload.length; i += 2) {\n    dataBytes.push(parseInt(dataPayload.substring(i, i + 2), 16));\n}\n\nlet decodedData;\nif (dgn === '1FEDB') {\n    decodedData = decodeDcDimmerCommand2Message(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\nmsg.payload = { ...incomingPayload, ...decodedData };\ndelete msg.payload.dataPayload;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 420,
        "wires": [
            [
                "51910a93d572e95c"
            ]
        ]
    },
    {
        "id": "51910a93d572e95c",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "d": true,
        "g": "3c819b7900145438",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 420,
        "wires": []
    },
    {
        "id": "982faa37c0038bf4",
        "type": "function",
        "z": "292e70a6ba25b323",
        "d": true,
        "g": "3c819b7900145438",
        "name": "Decode RVC CAN",
        "func": "// RVC CAN Message Parser\n// Decodes a raw RVC CAN message string into a structured object.\n// Input: msg.payload (string) - e.g., \"19FEDA8C#3AFF00FDFF2100FF\"\n// Output: msg.payload (object) with decoded CAN message components\n\nconst originalMessage = msg.payload;\n\n// Validate input\nif (!originalMessage || typeof originalMessage !== 'string') {\n    node.warn(\"Invalid message payload: expected string, got \" + typeof originalMessage);\n    return null;\n}\n\n// Retrieve the DGN map from global context\nconst dgnMap = global.get('dgnMap');\nif (!dgnMap) {\n    node.error(\"dgnMap not found in global context. Ensure the map is initialized before this node receives messages.\");\n    return null;\n}\n\n// Parse CAN message format: CANID#PAYLOAD\nconst parts = originalMessage.split('#');\nif (parts.length !== 2) {\n    node.warn(\"Invalid CAN message format received: \" + originalMessage + \". Expected format: CANID#PAYLOAD\");\n    return null;\n}\n\nconst canId = parts[0];\nconst dataPayload = parts[1];\n\n// Validate CAN ID length (should be 8 hex characters for 29-bit CAN ID)\nif (canId.length < 3 || canId.length > 8) {\n    node.warn(\"Invalid CAN ID length: \" + canId + \". Expected 3-8 hex characters.\");\n    return null;\n}\n\n// Validate CAN ID is valid hexadecimal\nconst canIdNum = parseInt(canId, 16);\nif (isNaN(canIdNum)) {\n    node.warn(\"Invalid CAN ID format: \" + canId + \". Must be hexadecimal.\");\n    return null;\n}\n\n// Validate data payload is even length (hex bytes)\nif (dataPayload.length % 2 !== 0) {\n    node.warn(\"Invalid data payload length: \" + dataPayload + \". Must be even number of hex characters.\");\n    return null;\n}\n\n// Extract CAN ID fields using proper bitwise operations for 29-bit CAN ID\n// CAN ID structure: [Priority:3][Reserved:1][Data Page:1][PDU Format:8][PDU Specific:8][Source Address:8]\n\n// Extract Priority (top 3 bits of the 29-bit ID)\nconst priority = (canIdNum >> 26) & 0x7;\n\n// Extract Source Address (lowest 8 bits)\nconst sourceAddress = (canIdNum & 0xFF).toString(16).toUpperCase().padStart(2, '0');\n\n// Extract DGN (Parameter Group Number - 17 bits: bits 8-24)\nconst dgnRaw = (canIdNum >> 8) & 0x1FFFF;\nconst dgn = dgnRaw.toString(16).toUpperCase();\n\n// Fix 4-character DGNs: All should start with '1' except GPS_POSITION (FEF3)\n// This is the only 4-character DGN in the RV-C spec; all others are 5 characters\nlet lookupDgn = dgn;\nif (dgn.length === 4 && dgn !== 'FEF3') {\n    lookupDgn = '1' + dgn;  // Prepend missing '1' to correct parsing error\n}\n\n// Look up DGN name using corrected value\nlet dgnName = dgnMap.get(lookupDgn) || \"UNKNOWN\";\n\n// Manufacturer-specific DGN overrides\nif (dgn === \"EF64\") {\n    dgnName = \"AQUAHOT\";\n}\n\n// Create structured output\nmsg.payload = {\n    originalMessage: originalMessage,\n    dgn: dgn,\n    dgnName: dgnName,\n    sourceAddress: sourceAddress,\n    priority: priority,\n    dataPayload: dataPayload,\n    // Additional fields for debugging/analysis\n    canIdHex: canId,\n    canIdDecimal: canIdNum,\n    dataLength: dataPayload.length / 2 // Number of data bytes\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 360,
        "wires": [
            [
                "4f33fad10d85b69d"
            ]
        ]
    },
    {
        "id": "5f6336442bfb9808",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "PROPRIETARY",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 1060,
        "wires": []
    },
    {
        "id": "8f99241c9a1cfbde",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "AQUAHOT",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 1000,
        "wires": []
    },
    {
        "id": "89f2d386ecc80a69",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Reset Device Name",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset_device_id",
        "payload": "",
        "payloadType": "date",
        "x": 450,
        "y": 1560,
        "wires": [
            [
                "b846bc1605dae821"
            ]
        ]
    },
    {
        "id": "1e93f7b73c40091a",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1070,
        "y": 1160,
        "wires": [
            [
                "38606e245b70b98e"
            ]
        ]
    },
    {
        "id": "38606e245b70b98e",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecoded\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "d0150fd6556514e6",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "Unique decoded messages",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecoded = flow.get(\"uniqueDecoded\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload);\n\n// Check if it's a new unique message\nif (!uniqueDecoded.includes(newMsgStr)) {\n    uniqueDecoded.push(newMsgStr);\n    flow.set(\"uniqueDecoded\", uniqueDecoded);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 1220,
        "wires": [
            [
                "8f7381d08bf2b8a8"
            ]
        ]
    },
    {
        "id": "8f7381d08bf2b8a8",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "01b53bba61cb7227",
        "name": "New Unique Dgn",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1350,
        "y": 1220,
        "wires": []
    },
    {
        "id": "1ac6e0fa1cbb3852",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out: Retain TRUE",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 670,
        "y": 700,
        "wires": []
    },
    {
        "id": "74329f13cbbc528a",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out: Retain FALSE",
        "links": [
            "1bf17ae955275cf0",
            "a2334b77d3764815",
            "6aa079d768e1571c",
            "8203b055d9149eff"
        ],
        "x": 210,
        "y": 700,
        "wires": [
            [
                "1ac6e0fa1cbb3852",
                "e7ae35364ce60f3f"
            ]
        ],
        "l": true
    },
    {
        "id": "97f9cc8db4a66114",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "ff07f63b9271ea10",
        "name": "Poll all lights",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1130,
        "y": 120,
        "wires": [
            [
                "73abad3deeed31e8",
                "c1bf29f13e5e33d8",
                "695ef0ed6d78a244",
                "3f5eb271f702c8f3"
            ]
        ]
    },
    {
        "id": "8203b055d9149eff",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "ff07f63b9271ea10",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 1630,
        "y": 120,
        "wires": [],
        "l": true
    },
    {
        "id": "73abad3deeed31e8",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "ff07f63b9271ea10",
        "name": "Poll all lights",
        "func": "// Generates an RV-C \"Request\" message to poll all lights for their status.\n// DGN EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FEDA).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for DC_DIMMER_STATUS_3 (1FEDA), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"DAFE01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll Lights] Sending global request for light status. CAN: ${msg.payload}`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 80,
        "wires": [
            [
                "8203b055d9149eff"
            ]
        ]
    },
    {
        "id": "c1bf29f13e5e33d8",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "ff07f63b9271ea10",
        "name": "Reset switches",
        "mode": "link",
        "links": [
            "e8b62c33eab8e3ac"
        ],
        "x": 1380,
        "y": 220,
        "wires": [],
        "l": true
    },
    {
        "id": "695ef0ed6d78a244",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "ff07f63b9271ea10",
        "name": "Poll all locks",
        "func": "// Generates an RV-C \"Request\" message to poll all locks for their status.\n// DGN 18EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FEE5).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for LOCK_STATUS (1FEE5), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"E5FE01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll Locks] Sending global request for lock status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 120,
        "wires": [
            [
                "8203b055d9149eff"
            ]
        ]
    },
    {
        "id": "3f5eb271f702c8f3",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "ff07f63b9271ea10",
        "name": "Poll all shades",
        "func": "// Generates an RV-C \"Request\" message to poll all window shades for their status.\n// DGN 18EAFF is a broadcast request.\n// Payload contains the DGN of the status to be returned (1FEDE).\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// 1. Build the data payload\n// This is the DGN for WINDOW_SHADE_CONTROL_STATUS (1FEDE), sent in little-endian format (least-significant byte first).\nconst dataPayload = \"DEFE01FFFFFFFF\";\n\n// 2. Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// 3. Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataPayload.toUpperCase()}`;\n\n//node.warn(`[Poll Shades] Sending global request for shade status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 160,
        "wires": [
            [
                "8203b055d9149eff"
            ]
        ]
    },
    {
        "id": "802228bc8d89d80a",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "black",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "a2d2ed96ff4615f9",
        "type": "function",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${type}_${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 160,
        "wires": [
            [
                "d38c75bc1474be23"
            ]
        ]
    },
    {
        "id": "d38c75bc1474be23",
        "type": "link out",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 630,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "abd1e06a1927df6d",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "switch",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "58",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 200,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "68c09ec9b9f984fd",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "tank_other",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 360,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "da1b195a794a61f2",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "battery_1",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 420,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "356ca3617c50f06b",
        "type": "function",
        "z": "222c995b7790b8de",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 380,
        "wires": [
            [
                "d38c75bc1474be23",
                "578d3f3784c2f9d1"
            ]
        ]
    },
    {
        "id": "578d3f3784c2f9d1",
        "type": "debug",
        "z": "222c995b7790b8de",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 380,
        "wires": []
    },
    {
        "id": "bed6707bca15029d",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "gray",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 480,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "80011a285355da55",
        "type": "link in",
        "z": "ee904ab46f56578e",
        "name": "HomeKit In",
        "links": [],
        "x": 160,
        "y": 120,
        "wires": [
            [
                "6e4cdf00d6531664"
            ]
        ],
        "l": true
    },
    {
        "id": "6e4cdf00d6531664",
        "type": "function",
        "z": "ee904ab46f56578e",
        "name": "HomeKit IN",
        "func": "let State;\nif (msg.state == \"ON\") {\n    State = true;\n} else if (msg.state == \"OFF\") {\n    State = false;\n}\nmsg = {\n    \"payload\": {\n        \"On\": State\n    }\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 120,
        "wires": [
            [
                "352f4c207b613014"
            ]
        ]
    },
    {
        "id": "352f4c207b613014",
        "type": "homekit-service",
        "z": "ee904ab46f56578e",
        "d": true,
        "isParent": true,
        "hostType": "0",
        "bridge": "481f3f804361a6fd",
        "accessoryId": "",
        "parentService": "",
        "name": "4_state_Entry_Lights",
        "serviceName": "Switch",
        "topic": "4_state_Entry_Lights",
        "filter": false,
        "manufacturer": "NRCHKB",
        "model": "1.7.3",
        "serialNo": "Default Serial Number",
        "firmwareRev": "1.7.3",
        "hardwareRev": "1.7.3",
        "softwareRev": "1.7.3",
        "cameraConfigVideoProcessor": "ffmpeg",
        "cameraConfigSource": "",
        "cameraConfigStillImageSource": "",
        "cameraConfigMaxStreams": 2,
        "cameraConfigMaxWidth": 1280,
        "cameraConfigMaxHeight": 720,
        "cameraConfigMaxFPS": 10,
        "cameraConfigMaxBitrate": 300,
        "cameraConfigVideoCodec": "libx264",
        "cameraConfigAudioCodec": "libfdk_aac",
        "cameraConfigAudio": false,
        "cameraConfigPacketSize": 1316,
        "cameraConfigVerticalFlip": false,
        "cameraConfigHorizontalFlip": false,
        "cameraConfigMapVideo": "0:0",
        "cameraConfigMapAudio": "0:1",
        "cameraConfigVideoFilter": "scale=1280:720",
        "cameraConfigAdditionalCommandLine": "-tune zerolatency",
        "cameraConfigDebug": false,
        "cameraConfigSnapshotOutput": "disabled",
        "cameraConfigInterfaceName": "",
        "characteristicProperties": "{}",
        "waitForSetupMsg": false,
        "outputs": 2,
        "adaptiveLightingOptionsEnable": false,
        "adaptiveLightingOptionsCustomTemperatureAdjustment": "",
        "x": 550,
        "y": 120,
        "wires": [
            [
                "cb7cb161a1362911"
            ],
            []
        ]
    },
    {
        "id": "cb7cb161a1362911",
        "type": "link out",
        "z": "ee904ab46f56578e",
        "name": "HomeKit out",
        "mode": "link",
        "links": [
            "9428382ab57f3f5d"
        ],
        "x": 760,
        "y": 120,
        "wires": [],
        "l": true
    },
    {
        "id": "faf503bfdd48519a",
        "type": "function",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "command_dc_dimmer",
        "func": "// Initialize global status if it doesn't exist\nif (!global.get('status')) {\n    global.set('status', { lights: {} });\n}\n\n// Get or initialize the lights status\nlet status = global.get('status') || { lights: {} };\nif (!status.lights) {\n    status.lights = {};\n}\n\n// Log incoming message for debugging\n//node.warn(\"Incoming message: \" + JSON.stringify(msg));\n\n// Parse the topic to get the instance number\nlet instance = parseInt(msg.topic.split('_')[0]);\nlet command = msg.payload;\n\n// Determine brightness based on command\nlet brightness = 0;\nif (command === 'ON') {\n    brightness = 100;\n} else if (command === 'dim') {\n    // If dim command, use previous brightness or default to 50%\n    brightness = (status.lights[instance] && status.lights[instance].brightness) || 50;\n} else if (command === 'OFF') {\n    brightness = 0;\n}\n\n// Initialize the light instance if it doesn't exist\nif (!status.lights[instance]) {\n    status.lights[instance] = {\n        state: command,\n        brightness: brightness\n    };\n}\n\n// Update global status\nstatus.lights[instance].state = command;\nstatus.lights[instance].brightness = brightness;\nglobal.set('status', status);\n\n// Prepare CAN message\nconst prio = 6;\nconst dgnhi = '1FE';\nconst dgnlo = 'DB';\nconst srcAD = 99;\n\n// Convert brightness to RV-C format (0-200)\nlet rvcBrightness = Math.min(Math.max(brightness * 2, 0), 200);\nlet rvcCommand = 0; // Set Level(delay)\nlet duration = 255;\n\ntry {\n    // Calculate CAN ID\n    const binCanId = parseInt(prio).toString(2).padStart(3, '0') +\n                     parseInt(dgnhi, 16).toString(2).padStart(16, '0') +\n                     parseInt(dgnlo, 16).toString(2).padStart(8, '0') +\n                     parseInt(srcAD).toString(2).padStart(8, '0');\n\n    const hexCanId = parseInt(binCanId, 2).toString(16).toUpperCase().padStart(8, '0');\n\n    // Prepare data bytes\n    const hexData = `${instance.toString(16).padStart(2, '0')}FF${\n        rvcBrightness.toString(16).padStart(2, '0')}${\n        rvcCommand.toString(16).padStart(2, '0')}${\n        duration.toString(16).padStart(2, '0')}00FFFF`;\n\n    // Create the command string for socketcan\n    const canCommand = `${hexCanId}#${hexData}`;\n\n    // Log the outgoing command for debugging\n    //node.warn(\"Outgoing CAN command: \" + canCommand);\n    msg.payload = canCommand;\n    return msg;\n\n} catch (error) {\n    node.error(\"Error processing CAN message: \" + error.message);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 380,
        "wires": [
            [
                "7c30a3bc33fa2315",
                "1bf17ae955275cf0"
            ]
        ]
    },
    {
        "id": "107cff91357ef6da",
        "type": "function",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "HomeKit Out",
        "func": "msg = {\n    \"topic\": msg.topic,\n    \"payload\": msg.payload.On ? \"ON\" : \"OFF\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 380,
        "wires": [
            [
                "9104e3fb894083ee",
                "faf503bfdd48519a"
            ]
        ]
    },
    {
        "id": "9104e3fb894083ee",
        "type": "debug",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "Homekit Out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 440,
        "wires": []
    },
    {
        "id": "b7cc11c60eb56768",
        "type": "link in",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "RVC In",
        "links": [],
        "x": 500,
        "y": 320,
        "wires": [
            [
                "faf503bfdd48519a"
            ]
        ],
        "l": true
    },
    {
        "id": "7c30a3bc33fa2315",
        "type": "debug",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "command_dc_dimmer",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 440,
        "wires": []
    },
    {
        "id": "9428382ab57f3f5d",
        "type": "link in",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "HomeKit out v2",
        "links": [
            "cb7cb161a1362911"
        ],
        "x": 190,
        "y": 380,
        "wires": [
            [
                "107cff91357ef6da"
            ]
        ],
        "l": true
    },
    {
        "id": "1bf17ae955275cf0",
        "type": "link out",
        "z": "ee904ab46f56578e",
        "g": "0b18891888586798",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 970,
        "y": 380,
        "wires": [],
        "l": true
    }
]