[
    {
        "id": "b3d80c5dc947ec88",
        "type": "tab",
        "label": "HA Commands",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3470febb2cd6e952",
        "type": "tab",
        "label": "HA Entities",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "3e5f038a4f5a8b9a",
        "type": "tab",
        "label": "Status",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "292e70a6ba25b323",
        "type": "tab",
        "label": "Config",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7ecdba18640c1184",
        "type": "tab",
        "label": "Command",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "222c995b7790b8de",
        "type": "tab",
        "label": "Delete HA Entity",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "9cfcca5efde78052",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "Load RV-C Dgn Names",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7e609140970f546c",
            "74c7e4a6cc2508eb",
            "cd670f6465b6374b",
            "c78420a075d43408"
        ],
        "x": 134,
        "y": 1539,
        "w": 852,
        "h": 82
    },
    {
        "id": "aea9d97e0563bd83",
        "type": "group",
        "z": "b3d80c5dc947ec88",
        "name": "Home Assistant message encoding",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a37da245aba53b96",
            "a3b957142479c075",
            "6aa079d768e1571c",
            "89946e1c7a570ed0",
            "927786f8f3f21075",
            "c19a749621bffe0c",
            "58d9a2789e4a1391",
            "8a5082e9f29a8080",
            "d367ea017bd41347",
            "778971897d2a7fdc",
            "1521d3d47869af7c",
            "32c25c048171f507",
            "86a191e1f24d802a",
            "ed9920dce79a233a",
            "a8882b1f35300448",
            "df1a21e8d68bc7ea",
            "ae2d2a4f790d7cf9"
        ],
        "x": 34,
        "y": 59,
        "w": 1372,
        "h": 662
    },
    {
        "id": "3c819b7900145438",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "MQTT",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "cacf35b859af22a9",
            "e7ae35364ce60f3f",
            "f658418a7b9b4857",
            "b86f82e84d961549",
            "64c5e5cfd4382453",
            "2110ea4d0b85f784",
            "958fed9f12301f59",
            "d34a8c1fd2cc4320",
            "74329f13cbbc528a",
            "1ac6e0fa1cbb3852",
            "0e65ff3bc0a0795c",
            "9e9b11b9441e51db",
            "54cd7e4a8959a77c",
            "32add109922d428a"
        ],
        "x": 134,
        "y": 59,
        "w": 732,
        "h": 482
    },
    {
        "id": "f09f79586501cb0b",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "CAN message routing",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "8d7d5d3ea117cf79",
            "ac47ce53a9fc3f21",
            "698efabc308fece6",
            "a16ce99da6a2a88f",
            "2e131d4d25819c93",
            "a2dad25eb05117f7",
            "fc66c16576e28548",
            "c6fb02a17f709e08",
            "2fcbc4d630144362",
            "a6594a9464d8fe4e",
            "02bdfc59de71b5a5",
            "45414bacecada477",
            "463dfbbef66b51c2",
            "9c4e4196e56cc471",
            "4fa9b9fdc36c83da",
            "9dd6a98018824be9"
        ],
        "x": 934,
        "y": 279,
        "w": 1558,
        "h": 582
    },
    {
        "id": "eb51c1f2d0d389d1",
        "type": "group",
        "z": "3e5f038a4f5a8b9a",
        "name": "Reset unique STATUS list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ffd5bc5ca5695602",
            "09640adb1fd08fbb",
            "b797e5a52b6db5b4",
            "48e6dda2b2d9575e"
        ],
        "x": 754,
        "y": 1959,
        "w": 492,
        "h": 142
    },
    {
        "id": "e2dc4d711cc9dc94",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Switches",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d3a13b531babee66",
            "7313d7c724d31538",
            "f0083147745c8366",
            "48e3b18cb440da52",
            "25162d774c052102",
            "32ec19602e928185",
            "52e43edcfad810dd",
            "2d6bf3e8aa77a8c6",
            "4d7e38077918190f",
            "bc185e54ce871b11",
            "a9779b1f38edf18d",
            "0a397108bc1143ea"
        ],
        "x": 114,
        "y": 99,
        "w": 1092,
        "h": 348
    },
    {
        "id": "04e375b0c463df72",
        "type": "group",
        "z": "222c995b7790b8de",
        "name": "Delete Home Assistant Entity",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "802228bc8d89d80a",
            "a2d2ed96ff4615f9",
            "d38c75bc1474be23",
            "abd1e06a1927df6d"
        ],
        "x": 94,
        "y": 79,
        "w": 672,
        "h": 162
    },
    {
        "id": "8ef86a1c4b59d8e1",
        "type": "group",
        "z": "292e70a6ba25b323",
        "name": "Claim CAN source address",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "515386b6b0d01893",
            "b846bc1605dae821",
            "55071115a3fe7c2c",
            "4e46ba83df00a31b",
            "f01db5ebc3ae2e18",
            "a2334b77d3764815",
            "6423c433e099d2a5",
            "73abad3deeed31e8",
            "695ef0ed6d78a244",
            "3f5eb271f702c8f3",
            "1e244bad0304bb74",
            "07b8bcce03f19e8f",
            "d3cc901dd2fbd359",
            "ba0c52ff61838986",
            "922f2738c2000150"
        ],
        "x": 134,
        "y": 1019,
        "w": 1652,
        "h": 402
    },
    {
        "id": "97615854748deb3d",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Locks",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ec1d9a742ca6e420",
            "c853244d3f2e753d",
            "1d2d33ef4e57dd39",
            "f9f3986645a75789",
            "d5b86b351963235f",
            "b94bb12a8c0a7027",
            "942c2aa2bb3167c9"
        ],
        "x": 114,
        "y": 559,
        "w": 1112,
        "h": 328
    },
    {
        "id": "da39e5020d511fa6",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Shades",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "05ad1b190633010c",
            "ad388870b71549ef",
            "f9a04003db7d8e4a",
            "fa9fcf7b64a31948",
            "927340668e7942e4",
            "ac41981e9754eca5",
            "8eb8085bb7cfee43"
        ],
        "x": 1434,
        "y": 559,
        "w": 1112,
        "h": 328
    },
    {
        "id": "067069104a82b459",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Tanks",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d4ef1d361f084b58",
            "61f4573c56915577",
            "6dc4171b23e1cc2a",
            "f9f5381eb086c0e6",
            "b6d3cd6d2e6fbc66",
            "240af7ca01aa2041",
            "da2041e2faba86a3",
            "cd562cd08d6d5f00"
        ],
        "x": 114,
        "y": 999,
        "w": 1112,
        "h": 368
    },
    {
        "id": "5d1ecae7ac09586c",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Batteries",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "ea29386f9f8682bc",
            "663120adc5ec254f",
            "2c1151c97bb185f2",
            "b6d90639c3fc122c",
            "86fa588a8393f6de",
            "d68c2206e3379850",
            "64578fa414def60a",
            "0d54f0db9a010394",
            "ccc056e90ff9e046"
        ],
        "x": 1434,
        "y": 999,
        "w": 1112,
        "h": 368
    },
    {
        "id": "84183171172657f8",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Water pump",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "bc627a6a37117bc0",
            "efb5c968a0a43c7d",
            "5a307ecdca9415b1",
            "c3c4a8bcea0243e9",
            "141bdcfc9aec9232",
            "77cecc17525bec45",
            "81de1ec667d84484",
            "7be8c253befcb861"
        ],
        "x": 114,
        "y": 1499,
        "w": 1092,
        "h": 348
    },
    {
        "id": "ad77b71440e42dc4",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Autofill",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "cff02a511add6887",
            "93a2783b5bb8d93d",
            "2f36862dec231b98",
            "5004281b11ec3bd7",
            "89855c1c4c586196",
            "2a121d2dbd94eecd",
            "dd0bc2a54fe2a072",
            "ffa4fd1f650f7371"
        ],
        "x": 1434,
        "y": 1499,
        "w": 1092,
        "h": 348
    },
    {
        "id": "daeff1de077d7dbb",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Floor heat",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "f0ba2779795efdae",
            "bd2d1b59183b99bb",
            "aa518caf7366cec9",
            "f183a66e28426985",
            "b3e18602b6affaf5",
            "1f7fde87c1ab1f51",
            "6e53b4f33db9f29c",
            "ee5f54f521f5ecda",
            "7562815aa04a7d55"
        ],
        "x": 1434,
        "y": 39,
        "w": 1092,
        "h": 348
    },
    {
        "id": "9c7621e8a8850053",
        "type": "group",
        "z": "3470febb2cd6e952",
        "name": "Aqua-Hot",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "1c1403c14b577fb4",
            "2ee0ed60af1beb40",
            "6841e5cff3b5e0e1",
            "43cd836c21f66b26",
            "2a97f79a308ff4fd",
            "54e6abd033b704f2",
            "08d4c674d7359aee",
            "8e14c79fdeec919c",
            "97e39646a29a8c55",
            "555850888ece5c2e",
            "f8f8ab87f8e56976",
            "1a54fd912ec1457b",
            "200991401297fc91",
            "e85f1a65658e35b8",
            "bde0564e43c0c68f",
            "fd53207a07863f6c",
            "13bcd21ae463ef4b",
            "baa7afeefe7f84eb"
        ],
        "x": 114,
        "y": 1939,
        "w": 1092,
        "h": 422
    },
    {
        "id": "081183d6c363e792",
        "type": "group",
        "z": "7ecdba18640c1184",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "b2cbbdbaab1fc227",
            "f96e5b3b013a2b8f",
            "bc59e15bf069f17d",
            "03744ec33f2e6776"
        ],
        "x": 674,
        "y": 519,
        "w": 532,
        "h": 142
    },
    {
        "id": "54c9dde7767b8935",
        "type": "group",
        "z": "7ecdba18640c1184",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "86dc00dfc2dbcd9e",
            "4f86998be2551032",
            "0f09356f283bfae7",
            "54bee06f72b5c1f5"
        ],
        "x": 674,
        "y": 159,
        "w": 572,
        "h": 142
    },
    {
        "id": "ea5519f0372a650f",
        "type": "group",
        "z": "7ecdba18640c1184",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "738e5a8857696209",
            "dc9f6facce21379f",
            "d825c1e1a2850fa5",
            "c95a503942e20c78"
        ],
        "x": 674,
        "y": 339,
        "w": 552,
        "h": 142
    },
    {
        "id": "9dd6a98018824be9",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a4028527eb23fa04",
            "092c751dcdd12270",
            "eea1641469efb23f",
            "c781b519a9f9b156"
        ],
        "x": 1914,
        "y": 639,
        "w": 552,
        "h": 142
    },
    {
        "id": "32ec19602e928185",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "886a33cd8776ba5a",
            "6e2b753c50d28b2b",
            "e8b62c33eab8e3ac"
        ],
        "x": 694,
        "y": 279,
        "w": 472,
        "h": 142
    },
    {
        "id": "ec1d9a742ca6e420",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "d37e08438396819b",
            "d240e935bd38ebd0",
            "54c6beb1daaa00bb"
        ],
        "x": 694,
        "y": 719,
        "w": 472,
        "h": 142
    },
    {
        "id": "05ad1b190633010c",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "779a4359a0980b2c",
            "81bed51dd2f37032",
            "84e908d542084d74"
        ],
        "x": 2014,
        "y": 719,
        "w": 472,
        "h": 142
    },
    {
        "id": "b6d3cd6d2e6fbc66",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "bfc3dc28b23b2396",
            "d574ead42dd36caa",
            "21799a7e71f6c5b4"
        ],
        "x": 694,
        "y": 1199,
        "w": 472,
        "h": 142
    },
    {
        "id": "d68c2206e3379850",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "5d1ecae7ac09586c",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "7c04541818436246",
            "738718a321d185e7",
            "b9f27aaa32da92c0"
        ],
        "x": 2014,
        "y": 1199,
        "w": 472,
        "h": 142
    },
    {
        "id": "77cecc17525bec45",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "3e1cb0098e246ca4",
            "876c4f2ff7fb1ae4",
            "99381e18a0d5f318"
        ],
        "x": 694,
        "y": 1679,
        "w": 472,
        "h": 142
    },
    {
        "id": "2a121d2dbd94eecd",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "4119a569e77d3350",
            "f6151272dcfe1559",
            "d192b275aac0824e"
        ],
        "x": 2014,
        "y": 1679,
        "w": 472,
        "h": 142
    },
    {
        "id": "9c4e4196e56cc471",
        "type": "group",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Rest unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "17b175c97c0551d4",
            "9f47dc231ecd50cd",
            "5968e8ee034f8751",
            "3d5ce3e925ee2f04"
        ],
        "x": 1914,
        "y": 459,
        "w": 552,
        "h": 142
    },
    {
        "id": "1f7fde87c1ab1f51",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "a9069efd6410088f",
            "7a0956cdace18b52",
            "893d80d1125057e8"
        ],
        "x": 2014,
        "y": 219,
        "w": 472,
        "h": 142
    },
    {
        "id": "ee5f54f521f5ecda",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "Reset floor levels (Don't do this)",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "56aa8b5c045b391d",
            "870bf91817db9d08"
        ],
        "x": 1494,
        "y": 279,
        "w": 412,
        "h": 82
    },
    {
        "id": "54e6abd033b704f2",
        "type": "group",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "Reset unique list",
        "style": {
            "stroke": "#ffffff",
            "label": true
        },
        "nodes": [
            "b4d0c623dc0cd7ed",
            "a11c02011307fe95",
            "aa12f93df2087d62"
        ],
        "x": 694,
        "y": 2119,
        "w": 472,
        "h": 142
    },
    {
        "id": "80727e60a251c36c",
        "type": "mqtt-broker",
        "name": "Mosquitto",
        "broker": "127.0.0.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a37da245aba53b96",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Decode HA command",
        "func": "// Parse Home Assistant MQTT command topics\n\n// --- Cover (Shade) entities ---\nconst rvcTopicMatch = msg.topic.match(\n    /^homeassistant\\/cover\\/shade_(\\d+)\\/set$/,\n);\nif (rvcTopicMatch) {\n    const instance = parseInt(rvcTopicMatch[1], 10);\n    const command = String(msg.payload).toUpperCase();\n    msg.routingKey = \"cover\";\n    msg.instance = instance;\n    msg.command = command;\n    msg.entityType = \"cover\";\n    msg.entityId = `shade_${instance}`;\n    return msg;\n}\n\n// --- Lock entities ---\nconst lockTopicMatch = msg.topic.match(\n    /^homeassistant\\/lock\\/lock_(\\d+)\\/set$/,\n);\nif (lockTopicMatch) {\n    const instance = parseInt(lockTopicMatch[1], 10);\n    const command = String(msg.payload).toUpperCase();\n    msg.routingKey = \"lock\";\n    msg.instance = instance;\n    msg.command = command;\n    msg.entityType = \"lock\";\n    msg.entityId = `lock_${instance}`;\n    return msg;\n}\n\n// --- Climate (Floor Heat) Preset entities ---\nconst climatePresetMatch = msg.topic.match(\n    /^homeassistant\\/climate\\/floor_heat_(\\d+)\\/set_preset_mode$/,\n);\nif (climatePresetMatch) {\n    const instance = parseInt(climatePresetMatch[1], 10);\n    msg.routingKey = \"floor_heat\";\n    msg.instance = instance;\n    msg.entityType = \"climate\";\n    msg.entityId = `floor_heat_${instance}`;\n    msg.command = \"SET_PRESET\";\n    msg.value = String(msg.payload); // e.g., \"Level 5\"\n    return msg;\n}\n\n// --- Climate (Floor Heat) Mode entities ---\nconst climateTopicMatch = msg.topic.match(\n    /^homeassistant\\/climate\\/floor_heat_(\\d+)\\/set_mode$/,\n);\nif (climateTopicMatch) {\n    const instance = parseInt(climateTopicMatch[1], 10);\n    msg.routingKey = \"floor_heat\";\n    msg.instance = instance;\n    msg.entityType = \"climate\";\n    msg.entityId = `floor_heat_${instance}`;\n    msg.command = String(msg.payload).toUpperCase(); // \"HEAT\" or \"OFF\"\n    return msg;\n}\n\n// --- Aqua-Hot entities ---\nconst aquahotTopicMatch = msg.topic.match(\n    /^homeassistant\\/light\\/aquahot_(burner|ac_1|ac_2|engine)\\/set$/,\n);\nif (aquahotTopicMatch) {\n    const instance = aquahotTopicMatch[1]; // \"burner\", \"ac_1\", \"ac_2\", or \"engine\"\n    const command = String(msg.payload).toUpperCase();\n    msg.routingKey = \"aquahot\";\n    msg.instance = instance;\n    msg.command = command;\n    msg.entityType = \"light\";\n    msg.entityId = `aquahot_${instance}`;\n    return msg;\n}\n\n// --- Switch and Light entities (Fallback) ---\nconst topicParts = msg.topic.split(\"/\");\nif (\n    topicParts.length === 4 &&\n    topicParts[0] === \"homeassistant\" &&\n    (topicParts[1] === \"switch\" || topicParts[1] === \"light\") &&\n    topicParts[3] === \"set\"\n) {\n    const entityId = topicParts[2];\n    const command = String(msg.payload).toUpperCase();\n    msg.entityType = topicParts[1];\n    msg.entityId = entityId;\n    msg.command = command;\n\n    if (entityId === \"water_pump\" || entityId === \"autofill\") {\n        msg.instance = entityId;\n        msg.routingKey = entityId;\n    } else {\n        const entityIdParts = entityId.split(\"_\");\n        const instanceStr = entityIdParts[entityIdParts.length - 1];\n        const instanceNum = parseInt(instanceStr, 10);\n        if (isNaN(instanceNum)) {\n            node.warn(`Could not parse instance number from entityId: ${entityId}`);\n            return null;\n        }\n        msg.instance = instanceNum;\n        msg.routingKey = entityIdParts.slice(0, -1).join(\"_\");\n    }\n    return msg;\n}\n\nnode.warn(`Unhandled MQTT topic: ${msg.topic}`);\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 200,
        "wires": [
            [
                "89946e1c7a570ed0",
                "32c25c048171f507"
            ]
        ]
    },
    {
        "id": "a3b957142479c075",
        "type": "link in",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA in",
        "links": [
            "64c5e5cfd4382453"
        ],
        "x": 110,
        "y": 200,
        "wires": [
            [
                "a37da245aba53b96",
                "1521d3d47869af7c"
            ]
        ],
        "l": true
    },
    {
        "id": "6aa079d768e1571c",
        "type": "link out",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 1270,
        "y": 180,
        "wires": [],
        "l": true
    },
    {
        "id": "89946e1c7a570ed0",
        "type": "switch",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "",
        "property": "routingKey",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "switch",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "water_pump",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "cover",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "lock",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "autofill",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "floor_heat",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "aquahot",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 570,
        "y": 200,
        "wires": [
            [
                "86a191e1f24d802a"
            ],
            [
                "927786f8f3f21075"
            ],
            [
                "58d9a2789e4a1391"
            ],
            [
                "8a5082e9f29a8080"
            ],
            [
                "d367ea017bd41347"
            ],
            [
                "ed9920dce79a233a"
            ],
            [
                "a8882b1f35300448"
            ],
            [
                "778971897d2a7fdc"
            ]
        ]
    },
    {
        "id": "927786f8f3f21075",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode water pump command",
        "func": "// Encodes WATER_PUMP_COMMAND messages (1FFB2)\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FFB2\";\n\n// --- Input Validation ---\nconst command = msg.command; // Expects \"ON\" or \"OFF\"\n\n// --- Command Mapping ---\nlet pumpCommandValue;\nswitch (command) {\n  case \"ON\":\n    pumpCommandValue = 1; // 01b = Enable pump (standby)\n    break;\n  case \"OFF\":\n    pumpCommandValue = 0; // 00b = Disable pump\n    break;\n  default:\n    node.warn(\n      `[encode_water_pump_command] Invalid command: \"${command}\". Expected \"ON\" or \"OFF\"`,\n    );\n    return null;\n}\n\n// --- Build Payload ---\n// Byte 0 contains the command. All other bytes are set to 0xFF (Not Available)\nconst dataBytes = new Array(8).fill(0xff);\ndataBytes[0] = pumpCommandValue; // Byte 0: Pump command\n\nconst dataHex = dataBytes\n  .map((byte) => byte.toString(16).padStart(2, \"0\"))\n  .join(\"\");\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n// --- Return Message ---\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 160,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "c19a749621bffe0c",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA command",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 120,
        "wires": []
    },
    {
        "id": "58d9a2789e4a1391",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode shade command",
        "func": "// Encodes WINDOW_SHADE_COMMAND messages (1FEDF)\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEDF\";\n\n// --- Input Validation ---\nconst instance = msg.instance;\nconst command = msg.command; // Expects \"OPEN\", \"CLOSE\", or \"STOP\"\n\nif (typeof instance !== \"number\" || instance < 1 || instance > 250) {\n    node.warn(`[encode_shade_command] Invalid instance: ${instance}`);\n    return null;\n}\n\n// --- Command Mapping ---\nlet shadeCommand;\nlet duration = 30; // 30 seconds duration (matches switch panel)\n\nswitch (command) {\n    case \"OPEN\":\n        shadeCommand = 0x85; // Toggle Forward (Raise/Open)\n        break;\n    case \"CLOSE\":\n        shadeCommand = 0x45; // Toggle Reverse (Lower/Close)\n        break;\n    case \"STOP\":\n        shadeCommand = 0x04; // Stop\n        duration = 0; // Duration is ignored for STOP\n        break;\n    default:\n        node.warn(\n            `[encode_shade_command] Invalid command: \"${command}\". Expected \"OPEN\", \"CLOSE\", or \"STOP\"`,\n        );\n        return null;\n}\n\n// --- Build Payload ---\nconst motorDuty = 200; // Use 200% motor duty (matches switch panel)\nconst dataBytes = new Array(8).fill(0xff);\ndataBytes[0] = instance; // Byte 0: Instance Number\ndataBytes[1] = 0xff; // Byte 1: Group (Non-group command)\ndataBytes[2] = motorDuty; // Byte 2: Motor Duty Cycle\ndataBytes[3] = shadeCommand; // Byte 3: Command Code\ndataBytes[4] = duration; // Byte 4: Duration\ndataBytes[5] = 0x00; // Byte 5: Interlock (No Interlock)\ndataBytes[6] = 0xff; // Byte 6: Not Available\ndataBytes[7] = 0xff; // Byte 7: Not Available\n\nconst dataHex = dataBytes\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n// --- Return Message ---\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 200,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "8a5082e9f29a8080",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode lock command",
        "func": "// Encodes LOCK_COMMAND messages (1FEE4)\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEE4\";\n\n// --- Input Validation ---\nconst instance = msg.instance;\nconst command = msg.command; // Expects \"LOCK\" or \"UNLOCK\"\n\n// Accept Instance 0 (broadcast to all locks)\nif (typeof instance !== \"number\" || instance < 0 || instance > 250) {\n    node.warn(`[encode_lock_command] Invalid instance: ${instance}`);\n    return null;\n}\n\n// --- Command Mapping ---\nlet lockCommand;\nswitch (command) {\n    case \"UNLOCK\":\n        lockCommand = 0; // Unlock\n        break;\n    case \"LOCK\":\n        lockCommand = 1; // Lock\n        break;\n    default:\n        node.warn(\n            `[encode_lock_command] Invalid command: \"${command}\". Expected \"LOCK\" or \"UNLOCK\"`,\n        );\n        return null;\n}\n\n// --- Build Payload ---\nconst dataBytes = new Array(8).fill(0xff);\ndataBytes[0] = instance; // Byte 0: Instance Number\ndataBytes[1] = lockCommand; // Byte 1: Lock Command (0=unlock, 1=lock)\ndataBytes[2] = 0; // Byte 2: Additional Command (0=no action)\ndataBytes[3] = 0xff; // Byte 3: Not Available\ndataBytes[4] = 0xff; // Byte 4: Not Available\ndataBytes[5] = 0xff; // Byte 5: Not Available\ndataBytes[6] = 0xff; // Byte 6: Not Available\ndataBytes[7] = 0xff; // Byte 7: Not Available\n\nconst dataHex = dataBytes\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n// --- Return Message ---\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 240,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "d367ea017bd41347",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode autofill command",
        "func": "// Encodes AUTOFILL_COMMAND messages (1FFB0)\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FFB0\"; // AUTOFILL_COMMAND\n\n// --- Input Validation ---\nconst command = msg.command; // Expects \"ON\" or \"OFF\"\n\n// --- Command Mapping ---\nlet commandValue;\nswitch (command) {\n    case \"ON\":\n        // Universal ON command that works on standard and non-standard systems\n        commandValue = 0xfd;\n        break;\n    case \"OFF\":\n        // Universal OFF command\n        commandValue = 0xfc;\n        break;\n    default:\n        node.warn(\n            `[encode_autofill_command] Invalid command: \"${command}\". Expected \"ON\" or \"OFF\"`,\n        );\n        return null;\n}\n\n// --- Build Payload ---\nconst dataBytes = new Array(8).fill(0xff);\ndataBytes[0] = commandValue; // Byte 0: Command value\n\nconst dataHex = dataBytes\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n// --- Return Message ---\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 280,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "778971897d2a7fdc",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "otherwise",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 420,
        "wires": []
    },
    {
        "id": "1521d3d47869af7c",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "HA in",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 230,
        "y": 100,
        "wires": []
    },
    {
        "id": "32c25c048171f507",
        "type": "debug",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Decode HA command",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 500,
        "y": 100,
        "wires": []
    },
    {
        "id": "86a191e1f24d802a",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode dc_dimmer_command_2",
        "func": "// Encodes DC_DIMMER_COMMAND_2 messages (1FEDB)\n\n// --- Configuration ---\nconst RVC_COMMAND = 0x05; // Toggle command\nconst CMD_UNLOCK = 0x22; // Remove lock condition\nconst LEVEL_ON = 250; // Brightness level (0xFA)\nconst NON_GROUP = 0xff;\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEDB\";\n\n// --- Input Validation ---\nconst instance = msg.instance;\nconst command = msg.command; // \"ON\" or \"OFF\"\n\nif (typeof instance !== \"number\" || instance < 1 || instance > 250) {\n    node.warn(`[encode_dc_dimmer_command_2] Invalid instance: ${instance}`);\n    return null;\n}\n\n// --- Command Mapping ---\n// Toggle command uses same payload for ON and OFF\nconst desiredLevel = LEVEL_ON;\n\n// --- Helper Functions ---\nfunction buildCanMessage(instance, desiredLevel, commandCode) {\n    const dataBytes = new Array(8).fill(0xff);\n    dataBytes[0] = instance; // Byte 0: Instance\n    dataBytes[1] = NON_GROUP; // Byte 1: Group (non-group)\n    dataBytes[2] = desiredLevel; // Byte 2: Desired Level\n    dataBytes[3] = commandCode; // Byte 3: Command\n    dataBytes[4] = 0xff; // Byte 4: Delay/Duration\n    dataBytes[5] = 0x00; // Byte 5: Interlock\n    dataBytes[6] = 0xff; // Byte 6: Ramp Time\n    dataBytes[7] = 0xff; // Byte 7: Reserved\n\n    const dataHex = dataBytes\n        .map((byte) => byte.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n\n    const dgnInt = parseInt(DGN, 16);\n    const canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\n    const canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n    return `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n}\n\n// --- Build Payload ---\n// Message 1: UNLOCK\nconst unlockMessage = {\n    topic: \"can/send\",\n    payload: buildCanMessage(instance, desiredLevel, CMD_UNLOCK),\n};\n\n// Message 2: TOGGLE\nconst toggleMessage = {\n    topic: \"can/send\",\n    payload: buildCanMessage(instance, desiredLevel, RVC_COMMAND),\n};\n\n// --- Return Message ---\n// Send both messages sequentially\nnode.send(unlockMessage);\nnode.send(toggleMessage);\n\n// Return null to prevent duplicate sending\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 120,
        "wires": [
            [
                "6aa079d768e1571c",
                "c19a749621bffe0c"
            ]
        ]
    },
    {
        "id": "ed9920dce79a233a",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode floor heat command",
        "func": "// Encodes FLOOR_HEAT_COMMAND messages (1FEFB)\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;\nconst DGN = \"1FEFB\";\n\n// --- Input Validation ---\nconst instance = msg.instance;\nconst command = msg.command;\n\nif (typeof instance !== \"number\") {\n  node.warn(`[encode_floor_heat_command] Invalid instance: ${instance}`);\n  return null;\n}\n\n// --- Get Context ---\nconst levelMap = global.get(\"floorHeatLevelMap\", \"file\");\nconst scheduleContextKey = `floorHeat_${instance}_ScheduleOn`;\nconst isScheduleOn = global.get(scheduleContextKey, \"file\") || false;\n\n// Store and retrieve the last used non-store preset's rawValue\nconst lastPresetKey = `floorHeat_${instance}_LastRawSetpoint`;\nconst lastRawSetpoint = global.get(lastPresetKey, \"file\") || 0;\n\n// Get the currently active preset name from the status flow\nconst currentPresetKey = `floorHeat_${instance}_CurrentPreset`;\nconst currentPresetName = global.get(currentPresetKey, \"file\") || \"level_1\";\n// 0x4820 is the RVC raw value for 50°F / 10°C (a safe default)\nconst defaultRawValue =\n  levelMap?.[\"level_1\"]?.rawValue || lastRawSetpoint || 0x4820;\n\nif (!levelMap && command !== \"OFF\") {\n  node.warn(\n    \"[encode_floor_heat_command] Floor heat level map not found. Levels must be discovered first.\",\n  );\n  if (command !== \"OFF\") {\n    return null;\n  }\n}\n\n// Determine the raw value to send during mode changes (HEAT/AUTO)\nlet rawValueToSend;\nconst storeLevelInfo = levelMap?.[\"store\"];\n\nif (currentPresetName === \"store\" && storeLevelInfo) {\n  rawValueToSend = storeLevelInfo.rawValue;\n} else {\n  rawValueToSend = lastRawSetpoint > 0 ? lastRawSetpoint : defaultRawValue;\n}\n\n// --- Build Payload ---\nconst dataBytes = new Array(8).fill(0xff);\ndataBytes[0] = instance; // Byte 0: Instance\n\n// --- Command Mapping ---\nif (command === \"OFF\") {\n  dataBytes[1] = 0xc0; // Byte 1: Command (Off)\n  dataBytes[2] = 0x00; // Byte 2: Setpoint LSB\n  dataBytes[3] = 0x00; // Byte 3: Setpoint MSB\n  global.set(scheduleContextKey, false, \"file\");\n} else if (command === \"HEAT\") {\n  // HEAT command: Turn ON, force Schedule OFF (Manual Mode)\n  dataBytes[1] = 0xc4; // Byte 1: Command (ON + Schedule OFF)\n  dataBytes[2] = rawValueToSend & 0xff; // Byte 2: Setpoint LSB\n  dataBytes[3] = (rawValueToSend >> 8) & 0xff; // Byte 3: Setpoint MSB\n  global.set(scheduleContextKey, false, \"file\");\n} else if (command === \"AUTO\") {\n  // AUTO command: Turn ON, force Schedule ON (Automatic Mode)\n  dataBytes[1] = 0xd7; // Byte 1: Command (ON + Schedule ON)\n  dataBytes[2] = rawValueToSend & 0xff; // Byte 2: Setpoint LSB\n  dataBytes[3] = (rawValueToSend >> 8) & 0xff; // Byte 3: Setpoint MSB\n  global.set(scheduleContextKey, true, \"file\");\n} else if (command === \"SET_PRESET\") {\n  if (!levelMap) {\n    node.error(\n      \"[encode_floor_heat_command] Cannot set preset, level map is missing.\",\n    );\n    return null;\n  }\n\n  const presetName = msg.value;\n  const normalizedPresetName =\n    presetName === \"none\" || !presetName ? \"store\" : presetName;\n  const levelInfo = levelMap[normalizedPresetName];\n\n  if (!levelInfo || typeof levelInfo.rawValue === \"undefined\") {\n    node.warn(`[encode_floor_heat_command] Unknown preset name: ${presetName}`);\n    return null;\n  }\n\n  const rawValue = levelInfo.rawValue;\n  dataBytes[1] = isScheduleOn ? 0xd4 : 0xc4; // Byte 1: Command (maintain schedule state)\n  dataBytes[2] = rawValue & 0xff; // Byte 2: Setpoint LSB\n  dataBytes[3] = (rawValue >> 8) & 0xff; // Byte 3: Setpoint MSB\n\n  // Update last non-store setpoint\n  if (normalizedPresetName !== \"store\") {\n    global.set(lastPresetKey, rawValue, \"file\");\n  }\n} else {\n  node.warn(`[encode_floor_heat_command] Invalid command: \"${command}\"`);\n  return null;\n}\n\nconst dataHex = dataBytes\n  .map((byte) => byte.toString(16).padStart(2, \"0\"))\n  .join(\"\");\n\n// --- Construct CAN ID ---\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (PRIORITY << 26) | (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n// --- Return Message ---\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 320,
        "wires": [
            [
                "c19a749621bffe0c",
                "6aa079d768e1571c"
            ]
        ]
    },
    {
        "id": "a8882b1f35300448",
        "type": "function",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "Encode Aqua-Hot command",
        "func": "// Encodes AquaHot Commands (EF64)\n\n// --- Configuration ---\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254; // FE (Default) - Not used in PDU1 CAN ID\nconst DESTINATION_ADDRESS = 0x9f; // Aqua-Hot Module\nconst PRIORITY = 6; // Confirmed priority for Aqua-Hot control\nconst PGN = \"EF64\";\nconst PGN_INT = parseInt(PGN, 16);\nconst CONTROL_BYTE = 0xab; // First data byte for all commands\n\n// --- Command Mapping (PGN EF64) ---\nconst COMMAND_MAP = {\n    // Diesel Burner Control\n    burner: {\n        ON: 0xfd,\n        OFF: 0xfc,\n    },\n    // AC Element 1 Control\n    ac_1: {\n        ON: 0xc7,\n        OFF: 0xc3,\n    },\n    // AC Element 2 Control\n    ac_2: {\n        ON: 0xcb,\n        OFF: 0xc3,\n    },\n    // Engine Pre-heat Control\n    engine: {\n        ON: 0x7f,\n        OFF: 0x3f,\n    },\n};\n\n// --- Input Validation ---\nconst instance = msg.instance; // Expects \"burner\", \"ac_1\", \"ac_2\", or \"engine\"\nconst command = msg.command; // Expects \"ON\" or \"OFF\"\n\n// Validate instance\nif (!instance || !COMMAND_MAP[instance]) {\n    node.warn(\n        `[encode_aquahot] Invalid instance: \"${instance}\". Expected one of: burner, ac_1, ac_2, engine`,\n    );\n    return null;\n}\n\n// Validate command\nif (!command || !COMMAND_MAP[instance][command]) {\n    node.warn(\n        `[encode_aquahot] Invalid command: \"${command}\". Expected \"ON\" or \"OFF\"`,\n    );\n    return null;\n}\n\n// --- Build Payload ---\nconst dataByte2 = COMMAND_MAP[instance][command];\n\n// Build the 8-byte data payload\nconst dataBytes = new Array(8).fill(0xff);\ndataBytes[0] = CONTROL_BYTE; // AB\ndataBytes[1] = dataByte2; // The specific command byte\n\nconst dataHex = dataBytes\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n\n// --- Construct CAN ID ---\n// PGN EF64 is a PDU1 format (PF < 240) so the destination address (0x9F) goes in the last byte\nconst canIdInt = (PRIORITY << 26) | (PGN_INT << 8) | DESTINATION_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, \"0\");\n\n// --- Return Message ---\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${dataHex.toUpperCase()}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 360,
        "wires": [
            [
                "c19a749621bffe0c",
                "6aa079d768e1571c"
            ]
        ]
    },
    {
        "id": "df1a21e8d68bc7ea",
        "type": "inject",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "can/send",
        "payload": "19FED99F#FF7EC8FFFFFF00FF",
        "payloadType": "str",
        "x": 930,
        "y": 620,
        "wires": [
            [
                "6aa079d768e1571c"
            ]
        ]
    },
    {
        "id": "ae2d2a4f790d7cf9",
        "type": "inject",
        "z": "b3d80c5dc947ec88",
        "g": "aea9d97e0563bd83",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "can/send",
        "payload": "19FED99F#FF7E00FFFFFF00FF",
        "payloadType": "str",
        "x": 930,
        "y": 680,
        "wires": [
            [
                "6aa079d768e1571c"
            ]
        ]
    },
    {
        "id": "d0143932939c8262",
        "type": "comment",
        "z": "b3d80c5dc947ec88",
        "name": "Panel Lights",
        "info": "all panel lights\nOFF\n19FED99F#FF7E00FFFFFF00FF\n\nON\n19FED99F#FF7EC8FFFFFF00FF\n\n\ntoggle bed panel lights\n19FED997#FF7D00FFFFFF00FF\n",
        "x": 1610,
        "y": 280,
        "wires": []
    },
    {
        "id": "d3a13b531babee66",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1070,
        "y": 140,
        "wires": [],
        "l": true
    },
    {
        "id": "7313d7c724d31538",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "DC_DIMMER_STATUS_3",
        "links": [
            "7af7fb2178a714cf"
        ],
        "x": 250,
        "y": 140,
        "wires": [
            [
                "f0083147745c8366",
                "48e3b18cb440da52",
                "4d7e38077918190f"
            ]
        ],
        "l": true
    },
    {
        "id": "f0083147745c8366",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unique dc_dimmer_3",
        "func": "// Unique Filter for DC Dimmer\n\n// Retrieve existing DC dimmer instances from flow context, or initialize as empty array\nlet uniqueDcDimmers = flow.get(\"uniqueDcDimmers\") || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (!uniqueDcDimmers.includes(instanceId)) {\n  uniqueDcDimmers.push(instanceId);\n  flow.set(\"uniqueDcDimmers\", uniqueDcDimmers);\n\n  // Pass the instance ID to create_dc_dimmer_3.js\n  return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 200,
        "wires": [
            [
                "25162d774c052102"
            ]
        ]
    },
    {
        "id": "48e3b18cb440da52",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Status DC dimmer 3",
        "func": "// HA Status Updater for DC Dimmer\n\n// Validate basic input structure\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\nconst statusValue = msg.payload.load_status;\n\n// Validate required fields\nif (typeof instance !== \"number\") {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\nif (typeof statusValue !== \"string\") {\n    node.error(\"Input missing 'load_status' (string).\", msg);\n    return null;\n}\n\n// DC Dimmer: Check if load_status contains \"Off\"\nconst haStatus = statusValue.includes(\"Off\") ? \"OFF\" : \"ON\";\n\n// Construct the MQTT topic\nconst stateTopic = `homeassistant/light/switch_${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\n\n// Lights and switches work with a simple string\nmsg.payload = haStatus;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 140,
        "wires": [
            [
                "0a397108bc1143ea"
            ]
        ]
    },
    {
        "id": "25162d774c052102",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create DC dimmer 3",
        "func": "// Creates Switch entity for DC DIMMER\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.error(\"Input payload must be an object.\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance;\n\n// Validate required fields\nif (typeof instance !== \"number\") {\n  node.error(\"Input missing 'instance' (number).\", msg);\n  return null;\n}\n\nif (instance < 1 || instance > 250) {\n  if (instance >= 251 && instance <= 255) {\n    return null;\n  }\n  node.warn(\n    `Instance ${instance} is outside the valid RV-C instance range (1-250) for a switch. Entity will not be created.`,\n  );\n  return null;\n}\n\n// Device configuration\nconst componentType = \"light\";\nconst prefix = \"switch\";\nconst displayPrefix = \"Switch\";\nconst icon = \"mdi:light-recessed\";\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\nconst displayName = `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: icon,\n  command_topic: commandTopic,\n  state_topic: stateTopic,\n  payload_on: \"ON\",\n  payload_off: \"OFF\",\n\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-switches\"],\n    name: \"LibreCoach: Switches\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\nmsg.entityId = entityId;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 200,
        "wires": [
            [
                "d3a13b531babee66",
                "52e43edcfad810dd"
            ]
        ]
    },
    {
        "id": "886a33cd8776ba5a",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 380,
        "wires": [
            [
                "6e2b753c50d28b2b"
            ]
        ]
    },
    {
        "id": "6e2b753c50d28b2b",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDcDimmers\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "e8b62c33eab8e3ac",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "32ec19602e928185",
        "name": "Reset dc_dimmerss",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 810,
        "y": 320,
        "wires": [
            [
                "6e2b753c50d28b2b"
            ]
        ],
        "l": true
    },
    {
        "id": "f9f3986645a75789",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Create lock",
        "func": "// Creates Lock entity\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.error(\"Input payload must be an object.\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance;\nconst deviceType = msg.payload.device_type;\n\n// Validate required fields\nif (typeof instance !== \"number\") {\n  node.error(\"Input missing 'instance' (number).\", msg);\n  return null;\n}\n\nif (typeof deviceType !== \"string\") {\n  node.error(\"Input missing 'device_type' (string).\", msg);\n  return null;\n}\n\n// Verify device type is lock\nif (deviceType !== \"lock\") {\n  node.error(`Expected device_type 'lock', got '${deviceType}'.`, msg);\n  return null;\n}\n\n// RV-C valid instance range: 0-250\n// Instance 0 = \"All Locks\" broadcast entity\n// Instances 1-250 = Individual locks\n// Special values: 251=Error, 252=Not Supported, 253=Out of Range, 254=Reserved, 255=Not Available\nif (instance < 0 || instance > 250) {\n  // Silently ignore special RV-C status values - these aren't real devices\n  if (instance >= 251 && instance <= 255) {\n    return null;\n  }\n  node.warn(\n    `Instance ${instance} is outside the valid RV-C instance range (0-250) for a lock. Entity will not be created.`,\n  );\n  return null;\n}\n\nconst prefix = \"lock\";\nconst displayPrefix = \"Lock\";\nconst componentType = \"lock\";\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\n// Special name for Instance 0 (broadcast to all locks)\nconst displayName =\n  instance === 0 ? \"All Locks\" : `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n  // Basic entity information\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: \"mdi:lock\",\n\n  // Topics for Home Assistant to use\n  command_topic: commandTopic,\n  state_topic: stateTopic,\n\n  // Define what \"LOCK\" and \"UNLOCK\" commands look like (simple strings)\n  payload_lock: \"LOCK\",\n  payload_unlock: \"UNLOCK\",\n\n  // State values that will be received from status updates\n  state_locked: \"LOCKED\",\n  state_unlocked: \"UNLOCKED\",\n\n  // Instance 0 (All Locks) uses optimistic mode since it's broadcast-only (no status feedback)\n  // Instances 1-250 use non-optimistic mode to show real status from RV-C bus\n  optimistic: instance === 0,\n\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-locks\"],\n    name: \"LibreCoach: Locks\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nmsg.stateTopic = stateTopic;\nmsg.commandTopic = commandTopic;\nmsg.entityId = entityId;\nmsg.deviceType = deviceType;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 660,
        "wires": [
            [
                "b94bb12a8c0a7027",
                "942c2aa2bb3167c9"
            ]
        ]
    },
    {
        "id": "c853244d3f2e753d",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Status lock",
        "func": "// HA Status Updater for Lock\n\n// Validate instance - must be a valid number (1-250)\n// Special values (0, 251-255) are decoded as strings and should be ignored\nif (typeof msg.payload.instance !== \"number\") {\n  // Silently ignore messages with invalid instance values\n  return null;\n}\n\nconst instance = msg.payload.instance;\n\n// Additional validation: only process instances 0-250\n// Instance 0 is accepted but won't publish state (optimistic entity)\nif (instance < 0 || instance > 250) {\n  return null;\n}\n\n// Skip state publishing for Instance 0 (broadcast \"All Locks\" entity)\n// Instance 0 uses optimistic mode and doesn't have individual status\nif (instance === 0) {\n  return null;\n}\n\n// Determine the lock state\nlet haStatus = \"UNKNOWN\";\n\n// Check boolean flags first (most reliable)\nif (msg.payload.is_locked === true) {\n  haStatus = \"LOCKED\";\n} else if (msg.payload.is_unlocked === true) {\n  haStatus = \"UNLOCKED\";\n} else if (typeof msg.payload.lock_status === \"string\") {\n  // Fall back to parsing lock_status string\n  const lockStatusLower = msg.payload.lock_status.toLowerCase();\n  if (\n    lockStatusLower.includes(\"locked\") &&\n    !lockStatusLower.includes(\"unlocked\")\n  ) {\n    haStatus = \"LOCKED\";\n  } else if (lockStatusLower.includes(\"unlocked\")) {\n    haStatus = \"UNLOCKED\";\n  }\n}\n\n// Create the state topic for this lock instance\nconst stateTopic = `homeassistant/lock/lock_${instance}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = haStatus; // The payload is the lock state string\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 600,
        "wires": [
            [
                "b94bb12a8c0a7027"
            ]
        ]
    },
    {
        "id": "1d2d33ef4e57dd39",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "LOCK_STATUS",
        "links": [
            "f00adfe38f0e26b5"
        ],
        "x": 220,
        "y": 600,
        "wires": [
            [
                "c853244d3f2e753d",
                "d5b86b351963235f"
            ]
        ],
        "l": true
    },
    {
        "id": "d5b86b351963235f",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Unique lock",
        "func": "// Unique Filter for Lock\n\n// Retrieve existing lock instances from flow context, or initialize as empty array\nlet uniqueLocks = flow.get(\"uniqueLocks\") || [];\n\n// Track by numeric instance ID for true uniqueness\n// Instance 0 = \"All Locks\" broadcast entity (per RV-C spec 6.40.1)\n// Instances 1-250 = Individual lock entities\nlet instanceId = msg.payload.instance;\nlet messagesToSend = [];\n\n// Ensure instance 0 is always initialized on first run\nif (!uniqueLocks.includes(0)) {\n    uniqueLocks.push(0);\n    flow.set(\"uniqueLocks\", uniqueLocks);\n\n    // Send instance 0 for initialization\n    messagesToSend.push({\n        payload: {\n            instance: 0,\n            device_type: \"lock\",\n        },\n    });\n}\n\n// Check if the current instance ID has been seen before\nif (!uniqueLocks.includes(instanceId)) {\n    uniqueLocks.push(instanceId);\n    flow.set(\"uniqueLocks\", uniqueLocks);\n\n    // Add the current instance to messages to send\n    messagesToSend.push({\n        payload: {\n            instance: instanceId,\n            device_type: \"lock\",\n        },\n    });\n}\n\n// Return messages (instance 0 if needed, current instance if new)\n// Returns null if no new instances detected\n// Node-RED will send each message in the array sequentially to the next node\nreturn messagesToSend.length > 0 ? messagesToSend : null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 660,
        "wires": [
            [
                "f9f3986645a75789"
            ]
        ]
    },
    {
        "id": "b94bb12a8c0a7027",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1090,
        "y": 600,
        "wires": [],
        "l": true
    },
    {
        "id": "d37e08438396819b",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "ec1d9a742ca6e420",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 820,
        "wires": [
            [
                "d240e935bd38ebd0"
            ]
        ]
    },
    {
        "id": "d240e935bd38ebd0",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ec1d9a742ca6e420",
        "name": "Reset function",
        "func": "flow.set(\"uniqueLocks\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "54c6beb1daaa00bb",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "ec1d9a742ca6e420",
        "name": "Reset locks",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 790,
        "y": 760,
        "wires": [
            [
                "d240e935bd38ebd0"
            ]
        ],
        "l": true
    },
    {
        "id": "779a4359a0980b2c",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "05ad1b190633010c",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2130,
        "y": 820,
        "wires": [
            [
                "81bed51dd2f37032"
            ]
        ]
    },
    {
        "id": "81bed51dd2f37032",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "05ad1b190633010c",
        "name": "Reset function",
        "func": "flow.set(\"uniqueShades\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2380,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "84e908d542084d74",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "05ad1b190633010c",
        "name": "Reset shades",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 2110,
        "y": 760,
        "wires": [
            [
                "81bed51dd2f37032"
            ]
        ],
        "l": true
    },
    {
        "id": "ad388870b71549ef",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Status shade",
        "func": "// HA Status Updater for Shade\n\nconst instance = msg.payload.instance;\nconst motorStatus = msg.payload.motor_status;\nconst forwardStatus = msg.payload.forward_status;\nconst reverseStatus = msg.payload.reverse_status;\n\n// Ignore invalid instances\nif (typeof instance !== \"number\" || instance < 1 || instance > 250) {\n    return null;\n}\n\nlet haState;\nlet position;\n\nif (motorStatus === 1 && forwardStatus === 1) {\n    haState = \"opening\";\n    position = 50; // Arbitrary position while moving\n} else if (motorStatus === 1 && reverseStatus === 1) {\n    haState = \"closing\";\n    position = 50; // Arbitrary position while moving\n} else {\n    // Motor stopped - report as open with 50% position\n    // This keeps both open and close buttons enabled in HA\n    haState = \"open\";\n    position = 50; // Always report 50% when stopped (keeps both buttons active)\n}\n\nmsg.topic = `homeassistant/cover/shade_${instance}/state`;\nmsg.payload = JSON.stringify({\n    state: haState,\n    position: position,\n});\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1790,
        "y": 600,
        "wires": [
            [
                "927340668e7942e4"
            ]
        ]
    },
    {
        "id": "f9a04003db7d8e4a",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "SHADE_STATUS",
        "links": [
            "4ab29d3dd1da32a5"
        ],
        "x": 1540,
        "y": 600,
        "wires": [
            [
                "ad388870b71549ef",
                "fa9fcf7b64a31948"
            ]
        ],
        "l": true
    },
    {
        "id": "fa9fcf7b64a31948",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Unique shade",
        "func": "const uniqueKey = \"uniqueShades\";\n\n// Retrieve existing instances from flow context, or initialize as empty array\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (instanceId != null && !uniqueList.includes(instanceId)) {\n    uniqueList.push(instanceId);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance ID to the next function\n    return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1800,
        "y": 660,
        "wires": [
            [
                "ac41981e9754eca5"
            ]
        ]
    },
    {
        "id": "927340668e7942e4",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 2410,
        "y": 600,
        "wires": [],
        "l": true
    },
    {
        "id": "ac41981e9754eca5",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Create shade",
        "func": "// Creates Cover entity\n\n// Validate input structure\nif (\n  !msg.payload ||\n  typeof msg.payload !== \"object\" ||\n  typeof msg.payload.instance !== \"number\"\n) {\n  node.error(\n    \"Input payload must be an object with a numeric 'instance' property.\",\n    msg,\n  );\n  return null;\n}\n\nconst instance = msg.payload.instance;\n\n// RV-C valid instance range: 1-250\n// Silently ignore special RV-C status/error values (251-255)\nif (instance < 1 || instance > 250) {\n  if (instance < 251) {\n    // Only warn for invalid user-range instances\n    node.warn(\n      `Instance ${instance} is outside the valid RV-C range (1-250). Cover will not be created.`,\n    );\n  }\n  return null;\n}\n\n// Device configuration\nconst componentType = \"cover\";\nconst prefix = \"shade\";\nconst displayPrefix = \"Shade\";\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\nconst displayName = `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: \"mdi:window-shutter\",\n  command_topic: commandTopic,\n  state_topic: stateTopic,\n  position_topic: stateTopic,\n  payload_open: \"OPEN\",\n  payload_close: \"CLOSE\",\n  payload_stop: \"STOP\",\n  // Cover entity states\n  state_opening: \"opening\",\n  state_closing: \"closing\",\n  state_open: \"open\",\n  state_closed: \"closed\",\n  // Position support (keeps both buttons enabled)\n  value_template: \"{{ value_json.state }}\",\n  position_template: \"{{ value_json.position | int }}\",\n  optimistic: false,\n\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-shades\"],\n    name: \"LibreCoach: Shades\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2080,
        "y": 660,
        "wires": [
            [
                "927340668e7942e4",
                "8eb8085bb7cfee43"
            ]
        ]
    },
    {
        "id": "d4ef1d361f084b58",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1090,
        "y": 1040,
        "wires": [],
        "l": true
    },
    {
        "id": "61f4573c56915577",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "TANK_STATUS",
        "links": [
            "45ae070eafc9a732"
        ],
        "x": 220,
        "y": 1040,
        "wires": [
            [
                "6dc4171b23e1cc2a",
                "240af7ca01aa2041"
            ]
        ],
        "l": true
    },
    {
        "id": "6dc4171b23e1cc2a",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Status tank",
        "func": "// HA Status Updater for Tank\n\n// Validate input and availability\nif (\n    msg.payload?.relative_level === \"Not Available\" ||\n    msg.relative_level === \"Not Available\"\n) {\n    return null; // Stop the flow if level data not available\n}\n\n// Extract values with fallback support (preserving original working logic)\nconst tankType = msg.payload?.tank_type ?? msg.tank_type;\nconst levelPercentage = msg.payload?.level_percentage ?? msg.level_percentage;\n\n// Validate tank type\nif (!tankType) {\n    node.error(\"Input missing 'tank_type'.\", msg);\n    return null; // Stop the flow\n}\n\n// Validate level percentage\nif (typeof levelPercentage !== \"number\") {\n    node.error(\"Input missing 'level_percentage' (number).\", msg);\n    return null; // Stop the flow\n}\n\n// Ensure level is within valid range\nconst level = Math.max(0, Math.min(100, Math.round(levelPercentage)));\n\n// Create the state topic for this tank instance\nconst stateTopic = `homeassistant/sensor/tank_${tankType}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = level; // The payload is the numeric level percentage\n\n// Add debug information for troubleshooting\nmsg.debug_info = {\n    original_tank_type: tankType,\n    calculated_level: level,\n    raw_level_percentage: levelPercentage,\n    raw_relative_level: msg.payload?.relative_level ?? msg.relative_level,\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 1040,
        "wires": [
            [
                "cd562cd08d6d5f00"
            ]
        ]
    },
    {
        "id": "f9f5381eb086c0e6",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Create tank",
        "func": "// Creates Sensor entity for TANKS\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.error(\"Input payload must be an object.\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance;\n\n// Validate required fields\nif (typeof instance !== \"number\") {\n    node.error(\"Input missing 'instance' (number).\", msg);\n    return null;\n}\n\n// Map instance ID to single-word tank type and display name\nconst tankTypeMap = {\n    0: { type: \"fresh\", name: \"Fresh Water\" },\n    1: { type: \"gray\", name: \"Gray Water\" },\n    2: { type: \"black\", name: \"Black Water\" },\n    3: { type: \"lpg\", name: \"LPG\" },\n    4: { type: \"fuel\", name: \"Fuel\" },\n    5: { type: \"hot\", name: \"Hot Water\" },\n    6: { type: \"hydraulic\", name: \"Hydraulic Fluid\" },\n    7: { type: \"livewell\", name: \"Live Well\" },\n    8: { type: \"ballast\", name: \"Ballast\" },\n    9: { type: \"oil\", name: \"Oil\" },\n    10: { type: \"coolant\", name: \"Coolant\" },\n    11: { type: \"def\", name: \"DEF\" },\n    12: { type: \"air\", name: \"Air\" },\n    13: { type: \"fresh2\", name: \"Fresh Water 2\" },\n    14: { type: \"gray2\", name: \"Gray Water 2\" },\n    15: { type: \"black2\", name: \"Black Water 2\" },\n    251: { type: \"error\", name: \"Error\" },\n    252: { type: \"notsupported\", name: \"Not Supported\" },\n    253: { type: \"outofrange\", name: \"Out of Range\" },\n    254: { type: \"reserved\", name: \"Reserved\" },\n    255: { type: \"notavailable\", name: \"Not Available\" },\n};\n\nconst tankInfo = tankTypeMap[instance] || {\n    type: \"other\",\n    name: `Unknown Tank ${instance}`,\n};\nconst tankType = tankInfo.type;\nconst displayName = tankInfo.name;\n\nconst entityId = `tank_${tankType}`;\nconst componentType = \"sensor\";\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\nconst payload = {\n    // Basic entity information\n    name: displayName,\n    unique_id: entityId,\n    default_entity_id: `sensor.${entityId}`,\n    icon: \"mdi:water-percent\",\n\n    // Topics for Home Assistant to use\n    state_topic: stateTopic,\n\n    // Sensor configuration\n    unit_of_measurement: \"%\",\n    value_template: \"{{ value | float }}\", // Ensure it's parsed as a number\n\n    // Link entities to a common device for better HA grouping\n    device: {\n        identifiers: [\"librecoach-water\"],\n        name: \"LibreCoach: Water\",\n        manufacturer: \"LibreCoach\",\n    },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nmsg.stateTopic = stateTopic;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 1120,
        "wires": [
            [
                "d4ef1d361f084b58",
                "da2041e2faba86a3"
            ]
        ]
    },
    {
        "id": "bfc3dc28b23b2396",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 1300,
        "wires": [
            [
                "d574ead42dd36caa"
            ]
        ]
    },
    {
        "id": "d574ead42dd36caa",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset function",
        "func": "flow.set(\"uniqueTanks\", []);\n\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1300,
        "wires": [
            []
        ]
    },
    {
        "id": "21799a7e71f6c5b4",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "b6d3cd6d2e6fbc66",
        "name": "Reset tanks",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 790,
        "y": 1240,
        "wires": [
            [
                "d574ead42dd36caa"
            ]
        ],
        "l": true
    },
    {
        "id": "240af7ca01aa2041",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Unique tank",
        "func": "// Unique Filter for Tank\n\n// Retrieve existing tank instances from flow context, or initialize as empty array\nlet uniqueTanks = flow.get(\"uniqueTanks\") || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (!uniqueTanks.includes(instanceId)) {\n  uniqueTanks.push(instanceId);\n  flow.set(\"uniqueTanks\", uniqueTanks);\n\n  // Pass the instance ID to create_tank.js\n  return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 1120,
        "wires": [
            [
                "f9f5381eb086c0e6"
            ]
        ]
    },
    {
        "id": "da2041e2faba86a3",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "Create tank",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 1120,
        "wires": []
    },
    {
        "id": "ea29386f9f8682bc",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 2410,
        "y": 1040,
        "wires": [],
        "l": true
    },
    {
        "id": "663120adc5ec254f",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS_1",
        "links": [
            "bff245b2ca47ef79"
        ],
        "x": 1570,
        "y": 1040,
        "wires": [
            [
                "2c1151c97bb185f2",
                "b6d90639c3fc122c"
            ]
        ],
        "l": true
    },
    {
        "id": "2c1151c97bb185f2",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Status battery",
        "func": "// HA Status Updater for Battery\n\n// Validate voltage availability - if it's \"Not Available\" string, skip\nif (\n    msg.payload?.dc_voltage_V === \"Not Available\" ||\n    msg.dc_voltage_V === \"Not Available\"\n) {\n    return null; // Stop the flow if voltage data not available\n}\n\n// Extract values with fallback support\nconst dcInstanceId = msg.payload?.instance ?? msg.instance;\nconst voltageValue = msg.payload?.dc_voltage_V ?? msg.dc_voltage_V;\n\n// Validate DC instance ID\nif (dcInstanceId === undefined || dcInstanceId === null) {\n    node.error(\"Input missing 'instance'.\", msg);\n    return null; // Stop the flow\n}\n\n// Map instance ID to entity suffix (must match create_battery.js)\nconst batteryMap = {\n    0: \"0\",\n    1: \"house\",\n    2: \"chassis\",\n    3: \"house2\",\n    4: \"generator\",\n};\n\n// For instances 5-250, use numeric suffix\nlet entitySuffix;\nif (dcInstanceId >= 5 && dcInstanceId <= 250) {\n    entitySuffix = dcInstanceId.toString();\n} else {\n    entitySuffix = batteryMap[dcInstanceId] || dcInstanceId.toString();\n}\n\n// Validate voltage value\nif (typeof voltageValue !== \"number\") {\n    node.error(\"Input missing 'dc_voltage_V' (number).\", msg);\n    return null; // Stop the flow\n}\n\n// Ensure voltage is within reasonable range and round to 2 decimal places\nconst voltage = Math.max(0, Math.min(50, Math.round(voltageValue * 100) / 100));\n\n// Create the state topic for this battery instance\nconst stateTopic = `homeassistant/sensor/battery_${entitySuffix}/state`;\n\nmsg.topic = stateTopic;\nmsg.payload = voltage; // The payload is the numeric voltage value\n\n\n// Add debug information for troubleshooting\nmsg.debug_info = {\n    instance: dcInstanceId,\n    entity_suffix: entitySuffix,\n    calculated_voltage: voltage,\n    raw_voltage_V: voltageValue,\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 1040,
        "wires": [
            [
                "ccc056e90ff9e046"
            ]
        ]
    },
    {
        "id": "b6d90639c3fc122c",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Unique battery",
        "func": "const uniqueKey = \"uniqueBatteries\";\n\n// Retrieve existing instances from flow context, or initialize as empty array\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Track by numeric instance ID for true uniqueness\nlet instanceId = msg.payload.instance;\n\n// Check if this instance ID has been seen before\nif (instanceId != null && !uniqueList.includes(instanceId)) {\n    uniqueList.push(instanceId);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance ID to the next function\n    return { payload: { instance: instanceId } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 1120,
        "wires": [
            [
                "86fa588a8393f6de"
            ]
        ]
    },
    {
        "id": "86fa588a8393f6de",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Create battery",
        "func": "// Creates Battery entity\n\n// Accept numeric instance ID from unique_batteries.js\nif (typeof msg.payload !== \"number\") {\n  node.error(\"Input payload must be a number (instance ID).\", msg);\n  return null;\n}\n\nconst instance = msg.payload;\n\n// Map instance ID to entity suffix and display name\nconst batteryMap = {\n  0: { suffix: \"0\", name: \"Invalid\" },\n  1: { suffix: \"house\", name: \"Main House Battery\" },\n  2: { suffix: \"chassis\", name: \"Chassis Battery\" },\n  3: { suffix: \"house2\", name: \"Secondary House Battery\" },\n  4: { suffix: \"generator\", name: \"Generator Battery\" },\n};\n\n// For instances 5-250, use generic \"battery_X\" naming\nlet entitySuffix;\nlet displayName;\nif (instance >= 5 && instance <= 250) {\n  entitySuffix = instance.toString();\n  displayName = `Battery ${instance}`;\n} else {\n  const batteryInfo = batteryMap[instance] || {\n    suffix: instance.toString(),\n    name: `Unknown Battery ${instance}`,\n  };\n  entitySuffix = batteryInfo.suffix;\n  displayName = batteryInfo.name;\n}\n\nconst entityId = `battery_${entitySuffix}`;\nconst componentType = \"sensor\";\n\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\nconst payload = {\n  // Basic entity information\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `sensor.${entityId}`,\n  icon: \"mdi:car-battery\",\n\n  // Topics for Home Assistant to use\n  state_topic: stateTopic,\n\n  // Sensor configuration\n  unit_of_measurement: \"V\",\n  device_class: \"voltage\",\n  value_template: \"{{ value | float | round(2) }}\",\n\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-energy\"],\n    name: \"LibreCoach: Energy\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nmsg.stateTopic = stateTopic;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2100,
        "y": 1120,
        "wires": [
            [
                "ea29386f9f8682bc",
                "0d54f0db9a010394"
            ]
        ]
    },
    {
        "id": "7c04541818436246",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2130,
        "y": 1300,
        "wires": [
            [
                "738718a321d185e7"
            ]
        ]
    },
    {
        "id": "738718a321d185e7",
        "type": "function",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset function",
        "func": "flow.set(\"uniqueBatteries\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2380,
        "y": 1300,
        "wires": [
            []
        ]
    },
    {
        "id": "b9f27aaa32da92c0",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "d68c2206e3379850",
        "name": "Reset batteries",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 2140,
        "y": 1240,
        "wires": [
            [
                "738718a321d185e7"
            ]
        ],
        "l": true
    },
    {
        "id": "64578fa414def60a",
        "type": "comment",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "DC_SOURCE_STATUS types",
        "info": "DC_SOURCE_STATUS_1: This is the most basic status message. It provides the fundamental electrical readings: \n\nDC Voltage and DC Current. A positive current value indicates the source is discharging (power flowing out), while a negative value indicates it is charging.\n\nDC_SOURCE_STATUS_2: This message adds thermal and capacity information. It reports the \n\nSource Temperature, the battery's State of Charge (SOC) as a percentage, and the estimated Time Remaining until the battery is either full or empty.\n\nDC_SOURCE_STATUS_3: This provides more nuanced details about the battery's long-term health and capacity. It includes the \n\nState of Health (SOH), Capacity Remaining in amp-hours, and Relative Capacity, which is the state of charge adjusted for the state of health.\n\n\nDC_SOURCE_STATUS_5: This message is for high-precision measurement. It reports the \n\nDC Voltage with 0.001 V precision, allowing for more accurate remote voltage sensing without needing dedicated wires.",
        "x": 1620,
        "y": 1200,
        "wires": []
    },
    {
        "id": "0d54f0db9a010394",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "Create battery",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 1120,
        "wires": []
    },
    {
        "id": "8eb8085bb7cfee43",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "da39e5020d511fa6",
        "name": "Create shade",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2380,
        "y": 660,
        "wires": []
    },
    {
        "id": "942c2aa2bb3167c9",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "97615854748deb3d",
        "name": "Create lock",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 660,
        "wires": []
    },
    {
        "id": "52e43edcfad810dd",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Create switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 200,
        "wires": []
    },
    {
        "id": "bc627a6a37117bc0",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1070,
        "y": 1540,
        "wires": [],
        "l": true
    },
    {
        "id": "efb5c968a0a43c7d",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "WATER_PUMP_STATUS",
        "links": [
            "295d4bc9058dab71"
        ],
        "x": 250,
        "y": 1540,
        "wires": [
            [
                "5a307ecdca9415b1",
                "c3c4a8bcea0243e9"
            ]
        ],
        "l": true
    },
    {
        "id": "5a307ecdca9415b1",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Unique water pump",
        "func": "const uniqueKey = \"uniqueWaterPumps\";\n\n// Retrieve existing instances from flow context\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Get instance name from message payload\nconst instanceName = msg.payload.instance;\n\n// Check if this instance name has been seen before\nif (instanceName && !uniqueList.includes(instanceName)) {\n    uniqueList.push(instanceName);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance name to the creation function\n    return { payload: { instance: instanceName } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1600,
        "wires": [
            [
                "141bdcfc9aec9232"
            ]
        ]
    },
    {
        "id": "c3c4a8bcea0243e9",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Status water pump",
        "func": "// HA Status Updater for Water Pump\n\nif (\n  !msg.payload ||\n  typeof msg.payload.instance !== \"string\" ||\n  typeof msg.payload.status !== \"string\"\n) {\n  node.error(\"Input missing 'instance' (string) or 'status' (string).\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance;\nconst haStatus = msg.payload.status.toUpperCase(); // Ensure payload is \"ON\" or \"OFF\"\n\n// Construct the MQTT state topic\nconst stateTopic = `homeassistant/switch/${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1540,
        "wires": [
            [
                "7be8c253befcb861"
            ]
        ]
    },
    {
        "id": "141bdcfc9aec9232",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Create water pump",
        "func": "// Creates Switch entity for Water Pump\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload.instance !== \"string\") {\n  node.error(\"Input must be an object with a string 'instance' property.\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance; // e.g., \"water_pump\"\n\n// Device configuration\nconst displayName = \"Water Pump\"; // Simplified display name\nconst icon = \"mdi:water-pump\";\nconst componentType = \"switch\";\n\n// Generate entity identifiers directly from the instance string\nconst entityId = instance;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload for Home Assistant\nconst payload = {\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: icon,\n  command_topic: commandTopic,\n  state_topic: stateTopic,\n  payload_on: \"ON\",\n  payload_off: \"OFF\",\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-water\"],\n    name: \"LibreCoach: Water\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 1600,
        "wires": [
            [
                "bc627a6a37117bc0",
                "81de1ec667d84484"
            ]
        ]
    },
    {
        "id": "3e1cb0098e246ca4",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "77cecc17525bec45",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 1780,
        "wires": [
            [
                "876c4f2ff7fb1ae4"
            ]
        ]
    },
    {
        "id": "876c4f2ff7fb1ae4",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "77cecc17525bec45",
        "name": "Reset function",
        "func": "flow.set(\"uniqueWaterPumps\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1780,
        "wires": [
            []
        ]
    },
    {
        "id": "99381e18a0d5f318",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "77cecc17525bec45",
        "name": "Reset water pump",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 810,
        "y": 1720,
        "wires": [
            [
                "876c4f2ff7fb1ae4"
            ]
        ],
        "l": true
    },
    {
        "id": "cff02a511add6887",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 2390,
        "y": 1540,
        "wires": [],
        "l": true
    },
    {
        "id": "93a2783b5bb8d93d",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "AUTOFILL_STATUS",
        "links": [
            "b87fcd5e60905824"
        ],
        "x": 1550,
        "y": 1540,
        "wires": [
            [
                "2f36862dec231b98",
                "5004281b11ec3bd7"
            ]
        ],
        "l": true
    },
    {
        "id": "2f36862dec231b98",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Unique autofill",
        "func": "const uniqueKey = \"uniqueAutofill\";\n\n// Retrieve existing instances from flow context\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Get instance name from message payload\nconst instanceName = msg.payload.instance;\n\n// Check if this instance name has been seen before\nif (instanceName && !uniqueList.includes(instanceName)) {\n    uniqueList.push(instanceName);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance name to the creation function\n    return { payload: { instance: instanceName } };\n}\n\n// Return nothing if duplicate instance\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 1600,
        "wires": [
            [
                "89855c1c4c586196"
            ]
        ]
    },
    {
        "id": "5004281b11ec3bd7",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Status autofill",
        "func": "// HA Status Updater for Autofill\n\nif (\n  !msg.payload ||\n  typeof msg.payload.instance !== \"string\" ||\n  typeof msg.payload.status !== \"string\"\n) {\n  node.error(\"Input missing 'instance' (string) or 'status' (string).\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance;\nconst haStatus = msg.payload.status.toUpperCase(); // Ensure payload is \"ON\" or \"OFF\"\n\n// Construct the MQTT state topic to match the entity creator\nconst stateTopic = `homeassistant/switch/${instance}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 1540,
        "wires": [
            [
                "ffa4fd1f650f7371"
            ]
        ]
    },
    {
        "id": "89855c1c4c586196",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Create autofill",
        "func": "// Creates Autofill entity\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload.instance !== \"string\") {\n  node.error(\"Input must be an object with a string 'instance' property.\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance; // e.g., \"autofill\"\n\n// Device configuration\nconst displayName = \"Autofill\";\nconst icon = \"mdi:water-plus-outline\";\nconst componentType = \"switch\";\n\n// Generate entity identifiers directly from the instance string\nconst entityId = instance;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: icon,\n  command_topic: commandTopic,\n  state_topic: stateTopic,\n  payload_on: \"ON\",\n  payload_off: \"OFF\",\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-water\"],\n    name: \"LibreCoach: Water\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2080,
        "y": 1600,
        "wires": [
            [
                "cff02a511add6887",
                "dd0bc2a54fe2a072"
            ]
        ]
    },
    {
        "id": "4119a569e77d3350",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "2a121d2dbd94eecd",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2130,
        "y": 1780,
        "wires": [
            [
                "f6151272dcfe1559"
            ]
        ]
    },
    {
        "id": "f6151272dcfe1559",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "2a121d2dbd94eecd",
        "name": "Reset function",
        "func": "flow.set(\"uniqueAutofill\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2380,
        "y": 1780,
        "wires": [
            []
        ]
    },
    {
        "id": "d192b275aac0824e",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "2a121d2dbd94eecd",
        "name": "Reset autofill",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 2110,
        "y": 1720,
        "wires": [
            [
                "f6151272dcfe1559"
            ]
        ],
        "l": true
    },
    {
        "id": "dd0bc2a54fe2a072",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "Create autofill",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2360,
        "y": 1600,
        "wires": []
    },
    {
        "id": "81de1ec667d84484",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "Create water pump",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 1600,
        "wires": []
    },
    {
        "id": "2d6bf3e8aa77a8c6",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Unlocked",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 300,
        "wires": []
    },
    {
        "id": "4d7e38077918190f",
        "type": "switch",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "",
        "property": "payload.lock_status",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Unlocked",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Locked",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 230,
        "y": 340,
        "wires": [
            [
                "2d6bf3e8aa77a8c6"
            ],
            [
                "bc185e54ce871b11"
            ],
            [
                "a9779b1f38edf18d"
            ]
        ]
    },
    {
        "id": "bc185e54ce871b11",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "Locked",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 340,
        "wires": []
    },
    {
        "id": "a9779b1f38edf18d",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "debug 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 380,
        "wires": []
    },
    {
        "id": "f0ba2779795efdae",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 2390,
        "y": 80,
        "wires": [],
        "l": true
    },
    {
        "id": "bd2d1b59183b99bb",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "FLOOR_HEAT_STATUS",
        "links": [
            "db73295f937c90a1"
        ],
        "x": 1570,
        "y": 80,
        "wires": [
            [
                "aa518caf7366cec9",
                "f183a66e28426985"
            ]
        ],
        "l": true
    },
    {
        "id": "aa518caf7366cec9",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "Unique floor heat",
        "func": "// Unique Filter for Floor Heat\n\n// --- Configuration ---\nconst instanceKey = \"uniqueFloorHeat\"; // Session-only\nconst levelsKey = \"uniqueFloorHeatLevels\"; // Persistent\n\n// Get data from payload ---\nconst instanceId = msg.payload.instance;\nconst raw_setpoint = msg.payload.raw_setpoint;\nconst schedule_mode = msg.payload.schedule_mode; // \"Enabled\" or \"Disabled\"\n\n// Validate input ---\nif (typeof instanceId !== \"number\") {\n  return null; // No instance, can't proceed\n}\n\n// We only want to discover a level if:\n// The setpoint is > 1 (to filter \"Off\" and test values)\n// The schedule_mode is \"Enabled\"\nconst isValidLevel =\n  typeof raw_setpoint === \"number\" &&\n  raw_setpoint > 1 &&\n  schedule_mode === \"Enabled\";\n\n// Get context lists ---\nlet instanceList = flow.get(instanceKey) || [];\nlet levelList = global.get(levelsKey, \"file\") || [];\n\nlet isNewInstance = false;\nlet isNewLevel = false;\n\n// Process Instance ---\nif (!instanceList.includes(instanceId)) {\n  isNewInstance = true;\n  instanceList.push(instanceId);\n  flow.set(instanceKey, instanceList); // Save to session context\n}\n\n// Process Level ---\nif (isValidLevel && !levelList.includes(raw_setpoint)) {\n  isNewLevel = true;\n  levelList.push(raw_setpoint);\n  levelList.sort((a, b) => a - b);\n  global.set(levelsKey, levelList, \"file\"); // Save to persistent context\n  node.log(`Discovered new floor heat level: ${raw_setpoint}`);\n}\n\n// Output Logic ---\nif (!isNewInstance && !isNewLevel) {\n  return null; // Nothing new, stop here\n}\n\nif (isNewLevel) {\n  //node.warn(`New level found. Sending config updates for all known instances: ${instanceList.join(', ')}`);\n\n  let outputs = [];\n  for (const inst of instanceList) {\n    outputs.push({ payload: { instance: inst } });\n  }\n  return outputs;\n}\n\nif (isNewInstance) {\n  return { payload: { instance: instanceId } };\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 140,
        "wires": [
            [
                "b3e18602b6affaf5"
            ]
        ]
    },
    {
        "id": "f183a66e28426985",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "Status floor heat",
        "func": "// HA Status Updater for Floor Heat\n\nconst payload = msg.payload;\nconst instance = payload.instance;\nconst raw_setpoint = payload.raw_setpoint;\n\n// --- Level Map ---\nconst levelMap = global.get(\"floorHeatLevelMap\", \"file\") || {};\n\n// Determine the preset mode early\nconst presetMode = levelMap[raw_setpoint]?.preset || \"store\";\nconst isStorePreset = presetMode === \"store\";\n\n// --- Climate Status ---\nconst climatePayload = {};\nclimatePayload.measured_temperature = payload.measured_temperature;\nclimatePayload.preset_mode = presetMode;\n\n// Mode (Strictly controlled by operating status and schedule status)\nlet climateMode;\nif (payload.operating_status === \"Off\") {\n  climateMode = \"off\";\n} else {\n  // If the system is ON, mode is \"auto\" only if the schedule is enabled, otherwise \"heat\"\n  climateMode = payload.schedule_mode === \"Enabled\" ? \"auto\" : \"heat\";\n}\nclimatePayload.mode = climateMode;\n\n// Action (idle when off, store, or heating)\nlet action;\nif (payload.operating_status === \"Off\") {\n  action = \"off\";\n} else if (isStorePreset) {\n  action = \"idle\";\n} else {\n  action = payload.heating_active ? \"heating\" : \"idle\";\n}\nclimatePayload.action = action;\n\n// --- Update Context ---\n\n// Save schedule state\nconst scheduleContextKey = `floorHeat_${instance}_ScheduleOn`;\nglobal.set(scheduleContextKey, payload.schedule_mode === \"Enabled\", \"file\");\n\n// Save the currently active preset name for command encoder use\nconst currentPresetKey = `floorHeat_${instance}_CurrentPreset`;\nglobal.set(currentPresetKey, presetMode, \"file\");\n\n// --- Create MQTT message ---\nconst climateEntityId = `floor_heat_${instance}`;\nconst climateStateTopic = `homeassistant/climate/${climateEntityId}/state`;\n\nmsg.topic = climateStateTopic;\nmsg.payload = {\n  measured_temperature: payload.measured_temperature,\n  preset_mode: presetMode,\n  mode: climateMode,\n  action: action,\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 80,
        "wires": [
            [
                "7562815aa04a7d55"
            ]
        ]
    },
    {
        "id": "b3e18602b6affaf5",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "Create floor heat",
        "func": "// Creates Climate entity for FLOOR HEAT\n\n// Validate input structure\nconst instance = msg.payload.instance;\nif (typeof instance !== \"number\") {\n  node.error(\"Input missing 'instance' (number).\", msg);\n  return null;\n}\n\n// --- Get Discovered Levels ---\nconst levelsKey = \"uniqueFloorHeatLevels\";\nconst levels = global.get(levelsKey, \"file\") || [];\n\n// --- Build Preset List and Map ---\nlet levelMap = {};\nlet presetList = [];\nlet levelCounter = 1;\n\n// The 'unique' node sorts the list, so the lowest value is always first.\n// Get the lowest level (\"Store\").\nconst lowestLevelRaw = levels.length > 0 ? levels[0] : null;\n\n// Helper to decode RVC raw value to Fahrenheit (assuming it's available or implemented elsewhere)\nconst decodeTempFromRaw = (rawValue) => {\n  if (rawValue === 0 || rawValue > 65530) return 0;\n  const tempK = rawValue * 0.03125;\n  const tempC = tempK - 273.15;\n  return parseFloat(((tempC * 9) / 5 + 32).toFixed(1));\n};\n\nfor (const rawVal of levels) {\n  let name;\n  let tempF = decodeTempFromRaw(rawVal);\n\n  // Check if the current value is the lowest one we found\n  if (rawVal === lowestLevelRaw) {\n    name = \"store\"; // Dynamically assigned to the lowest value\n  } else {\n    name = `level_${levelCounter++}`;\n  }\n\n  // Store both directions of the map for easier lookups\n  const levelInfo = { preset: name, rawValue: rawVal, temp: tempF };\n\n  presetList.push(name);\n  levelMap[name] = levelInfo; // Map preset name to all info\n  levelMap[rawVal] = levelInfo; // Map raw value to all info (for status script)\n}\nglobal.set(\"floorHeatLevelMap\", levelMap, \"file\");\n\n// Device configuration\nconst componentType = \"climate\";\nconst prefix = \"floor_heat\";\nconst displayPrefix = \"Floor Heat\";\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\nconst displayName = `${displayPrefix} ${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\n// MQTT Discovery payload\nconst payload = {\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: \"mdi:heating-coil\",\n\n  current_temperature_topic: stateTopic,\n  current_temperature_template: \"{{ value_json.measured_temperature }}\",\n\n  mode_state_topic: stateTopic,\n  mode_state_template: \"{{ value_json.mode }}\",\n\n  preset_mode_state_topic: stateTopic,\n  preset_mode_value_template: \"{{ value_json.preset_mode }}\",\n\n  mode_command_topic: `homeassistant/${componentType}/${entityId}/set_mode`,\n  modes: [\"off\", \"heat\", \"auto\"], // \"auto\" is for schedule ON\n\n  preset_mode_command_topic: `homeassistant/${componentType}/${entityId}/set_preset_mode`,\n  preset_modes: presetList,\n\n  temperature_unit: \"F\",\n\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-climate\"],\n    name: \"LibreCoach: Climate\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nconst outMsg = {\n  topic: discoveryTopic,\n  payload: payload,\n};\n\n// Return only the climate discovery message\nreturn [[outMsg]];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 140,
        "wires": [
            [
                "f0ba2779795efdae",
                "6e53b4f33db9f29c"
            ]
        ]
    },
    {
        "id": "a9069efd6410088f",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "1f7fde87c1ab1f51",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2130,
        "y": 320,
        "wires": [
            [
                "7a0956cdace18b52"
            ]
        ]
    },
    {
        "id": "7a0956cdace18b52",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "1f7fde87c1ab1f51",
        "name": "Reset function",
        "func": "flow.set(\"uniqueFloorHeat\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2380,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "893d80d1125057e8",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "1f7fde87c1ab1f51",
        "name": "Reset floor heat",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 2120,
        "y": 260,
        "wires": [
            [
                "7a0956cdace18b52"
            ]
        ],
        "l": true
    },
    {
        "id": "6e53b4f33db9f29c",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "Create floor heat",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2370,
        "y": 140,
        "wires": []
    },
    {
        "id": "56aa8b5c045b391d",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "ee5f54f521f5ecda",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1610,
        "y": 320,
        "wires": [
            [
                "870bf91817db9d08"
            ]
        ]
    },
    {
        "id": "870bf91817db9d08",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "ee5f54f521f5ecda",
        "name": "Reset function",
        "func": "// --- Reset persistent and in-memory context cleanly ---\n\n// Helper function to clear both stores\nfunction clearContext(key) {\n    // Remove persistent value\n    global.set(key, undefined, \"file\");\n    // Remove in-memory value\n    global.set(key, undefined);\n}\n\n// --- Clear specific global variables ---\nclearContext(\"uniqueFloorHeatLevels\");\nclearContext(\"floorHeatLevelMap\");\n\n// --- Clear specific flow variables ---\nflow.set(\"uniqueFloorHeat\", undefined, \"file\");\nflow.set(\"uniqueFloorHeat\", undefined);\nflow.set(\"floorHeatLevelMap\", undefined, \"file\");\nflow.set(\"floorHeatLevelMap\", undefined);\n\nnode.warn(\"Context cleared\");\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1800,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "1c1403c14b577fb4",
        "type": "link out",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 1070,
        "y": 1980,
        "wires": [],
        "l": true
    },
    {
        "id": "2ee0ed60af1beb40",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "AQUAHOT_STATUS",
        "links": [
            "b6c72de91f6e7ec7"
        ],
        "x": 230,
        "y": 1980,
        "wires": [
            [
                "6841e5cff3b5e0e1",
                "43cd836c21f66b26",
                "8e14c79fdeec919c"
            ]
        ],
        "l": true
    },
    {
        "id": "6841e5cff3b5e0e1",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "Unique Aqua-Hot",
        "func": "// Unique Filter for AquaHot\n\nconst uniqueKey = \"uniqueAquaHot\";\n\n// Retrieve existing instances from flow context\nlet uniqueList = flow.get(uniqueKey) || [];\n\n// Get instance name from message payload\nconst instanceName = msg.payload.instance;\n\n// Check if this instance name has been seen before\nif (instanceName && !uniqueList.includes(instanceName)) {\n    uniqueList.push(instanceName);\n    flow.set(uniqueKey, uniqueList);\n\n    // Pass the instance name to the creation function\n    return { payload: { instance: instanceName } };\n}\n\n// Return nothing if duplicate instance\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 2040,
        "wires": [
            [
                "2a97f79a308ff4fd"
            ]
        ]
    },
    {
        "id": "43cd836c21f66b26",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "Status Aqua-Hot",
        "func": "// HA Status Updater for AquaHot\n\n// Validate basic input structure\nif (\n    !msg.payload ||\n    typeof msg.payload.instance !== \"string\" ||\n    typeof msg.payload.status !== \"string\"\n) {\n    node.error(\"Input missing 'instance' (string) or 'status' (string).\", msg);\n    return null;\n}\n\nconst instance = msg.payload.instance; // e.g., \"burner\", \"ac_1\", \"ac_2\", \"engine\"\nconst haStatus = msg.payload.status.toUpperCase(); // Ensure payload is \"ON\" or \"OFF\"\n\n// Validate instance is one of the expected values\nconst validInstances = [\"burner\", \"ac_1\", \"ac_2\", \"engine\"];\nif (!validInstances.includes(instance)) {\n    node.error(\n        `Invalid instance: ${instance}. Expected: burner, ac_1, ac_2, or engine.`,\n        msg,\n    );\n    return null;\n}\n\n// Device configuration\nconst componentType = \"light\";\nconst prefix = \"aquahot\";\n\n// Generate entity ID\nconst entityId = `${prefix}_${instance}`;\n\n// Construct the MQTT state topic\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\n\n// Prepare the final message\nmsg.topic = stateTopic;\nmsg.payload = haStatus;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1980,
        "wires": [
            [
                "baa7afeefe7f84eb"
            ]
        ]
    },
    {
        "id": "2a97f79a308ff4fd",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "Create Aqua-Hot",
        "func": "// Creates AquaHot entity\n\n// Validate input structure\nif (!msg.payload || typeof msg.payload.instance !== \"string\") {\n  node.error(\"Input must be an object with a string 'instance' property.\", msg);\n  return null;\n}\n\nconst instance = msg.payload.instance; // Expecting \"burner\", \"ac_1\", \"ac_2\", or \"engine\"\n\n// Validate instance is one of the expected values\nconst validInstances = [\"burner\", \"ac_1\", \"ac_2\", \"engine\"];\nif (!validInstances.includes(instance)) {\n  node.error(\n    `Invalid instance: ${instance}. Expected: burner, ac_1, ac_2, or engine.`,\n    msg,\n  );\n  return null;\n}\n\n// Device configuration\nconst componentType = \"light\";\nconst prefix = \"aquahot\";\n\n// Configure display name and icon based on instance\nlet displayName, icon;\nswitch (instance) {\n  case \"burner\":\n    displayName = \"Diesel Burner\";\n    icon = \"mdi:fire\";\n    break;\n  case \"ac_1\":\n    displayName = \"AC Element 1\";\n    icon = \"mdi:lightning-bolt\";\n    break;\n  case \"ac_2\":\n    displayName = \"AC Element 2\";\n    icon = \"mdi:lightning-bolt\";\n    break;\n  case \"engine\":\n    displayName = \"Engine Pre-heat\";\n    icon = \"mdi:engine\";\n    break;\n}\n\n// Generate entity identifiers\nconst entityId = `${prefix}_${instance}`;\n\n// MQTT topics\nconst discoveryTopic = `homeassistant/${componentType}/${entityId}/config`;\nconst stateTopic = `homeassistant/${componentType}/${entityId}/state`;\nconst commandTopic = `homeassistant/${componentType}/${entityId}/set`;\n\n// MQTT Discovery payload\nconst payload = {\n  name: displayName,\n  unique_id: entityId,\n  default_entity_id: `${componentType}.${entityId}`,\n  icon: icon,\n  command_topic: commandTopic,\n  state_topic: stateTopic,\n  payload_on: \"ON\",\n  payload_off: \"OFF\",\n  // Link entities to a common device for better HA grouping\n  device: {\n    identifiers: [\"librecoach-aquahot\"],\n    name: \"LibreCoach: Aqua-Hot\",\n    manufacturer: \"LibreCoach\",\n  },\n};\n\n// Prepare the final message for the MQTT Out node\nmsg.topic = discoveryTopic;\nmsg.payload = payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 2040,
        "wires": [
            [
                "1c1403c14b577fb4",
                "08d4c674d7359aee"
            ]
        ]
    },
    {
        "id": "b4d0c623dc0cd7ed",
        "type": "inject",
        "z": "3470febb2cd6e952",
        "g": "54e6abd033b704f2",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 810,
        "y": 2220,
        "wires": [
            [
                "a11c02011307fe95"
            ]
        ]
    },
    {
        "id": "a11c02011307fe95",
        "type": "function",
        "z": "3470febb2cd6e952",
        "g": "54e6abd033b704f2",
        "name": "Reset function",
        "func": "flow.set(\"uniqueAquaHot\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 2220,
        "wires": [
            []
        ]
    },
    {
        "id": "aa12f93df2087d62",
        "type": "link in",
        "z": "3470febb2cd6e952",
        "g": "54e6abd033b704f2",
        "name": "Reset Aqua-Hot",
        "links": [
            "1e244bad0304bb74"
        ],
        "x": 800,
        "y": 2160,
        "wires": [
            [
                "a11c02011307fe95"
            ]
        ],
        "l": true
    },
    {
        "id": "08d4c674d7359aee",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "Create Aqua-Hot",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 2040,
        "wires": []
    },
    {
        "id": "8e14c79fdeec919c",
        "type": "switch",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "",
        "property": "payload.instance",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "burner",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ac_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ac_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "engine",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 5,
        "x": 220,
        "y": 2180,
        "wires": [
            [
                "97e39646a29a8c55"
            ],
            [
                "f8f8ab87f8e56976"
            ],
            [
                "200991401297fc91"
            ],
            [
                "bde0564e43c0c68f"
            ],
            [
                "13bcd21ae463ef4b"
            ]
        ]
    },
    {
        "id": "97e39646a29a8c55",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 370,
        "y": 2160,
        "wires": [
            [
                "555850888ece5c2e"
            ]
        ]
    },
    {
        "id": "555850888ece5c2e",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 500,
        "y": 2160,
        "wires": []
    },
    {
        "id": "f8f8ab87f8e56976",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 370,
        "y": 2200,
        "wires": [
            [
                "1a54fd912ec1457b"
            ]
        ]
    },
    {
        "id": "1a54fd912ec1457b",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "debug 6",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 2200,
        "wires": []
    },
    {
        "id": "200991401297fc91",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 370,
        "y": 2240,
        "wires": [
            [
                "e85f1a65658e35b8"
            ]
        ]
    },
    {
        "id": "e85f1a65658e35b8",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "debug 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 2240,
        "wires": []
    },
    {
        "id": "bde0564e43c0c68f",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 370,
        "y": 2280,
        "wires": [
            [
                "fd53207a07863f6c"
            ]
        ]
    },
    {
        "id": "fd53207a07863f6c",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "debug 8",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 490,
        "y": 2280,
        "wires": []
    },
    {
        "id": "13bcd21ae463ef4b",
        "type": "debug",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "debug 4",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 2320,
        "wires": []
    },
    {
        "id": "7be8c253befcb861",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "84183171172657f8",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 730,
        "y": 1540,
        "wires": [
            [
                "bc627a6a37117bc0"
            ]
        ]
    },
    {
        "id": "ffa4fd1f650f7371",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "ad77b71440e42dc4",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 2050,
        "y": 1540,
        "wires": [
            [
                "cff02a511add6887"
            ]
        ]
    },
    {
        "id": "cd562cd08d6d5f00",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "067069104a82b459",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 750,
        "y": 1040,
        "wires": [
            [
                "d4ef1d361f084b58"
            ]
        ]
    },
    {
        "id": "ccc056e90ff9e046",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "d": true,
        "g": "5d1ecae7ac09586c",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 2070,
        "y": 1040,
        "wires": [
            [
                "ea29386f9f8682bc"
            ]
        ]
    },
    {
        "id": "0a397108bc1143ea",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "e2dc4d711cc9dc94",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 730,
        "y": 140,
        "wires": [
            [
                "d3a13b531babee66"
            ]
        ]
    },
    {
        "id": "7562815aa04a7d55",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "daeff1de077d7dbb",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 2070,
        "y": 80,
        "wires": [
            [
                "f0ba2779795efdae"
            ]
        ]
    },
    {
        "id": "baa7afeefe7f84eb",
        "type": "rbe",
        "z": "3470febb2cd6e952",
        "g": "9c7621e8a8850053",
        "name": "",
        "func": "rbe",
        "gap": "",
        "start": "",
        "inout": "out",
        "septopics": true,
        "property": "payload",
        "topi": "topic",
        "x": 730,
        "y": 1980,
        "wires": [
            [
                "1c1403c14b577fb4"
            ]
        ]
    },
    {
        "id": "9f88f215f3f07227",
        "type": "switch",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DIGITAL_INPUT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WATER_PUMP_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AUTOFILL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WINDOW_SHADE_CONTROL_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "LOCK_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "TANK_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_SOURCE_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FLOOR_HEAT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AQUAHOT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AQUAHOT_THERMOSTAT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_STATUS_2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "THERMOSTAT_AMBIENT_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FURNACE_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "GENERATOR_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "GENERATOR_DEMAND_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "CHARGER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHARGER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "INVERTER_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "INVERTER_DC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AC_LOAD_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ATS_STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "ATS_AC_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "SOLAR_EQUALIZATION_CONFIGURATION_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DC_DIMMER_STATUS_2",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DC_SOURCE_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "CIRCULATION_PUMP_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AIR_CONDITIONER_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WATERHEATER_STATUS_2",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 34,
        "x": 420,
        "y": 780,
        "wires": [
            [],
            [
                "9e8e5609c54fec82"
            ],
            [
                "96c3c21a4dd0b9bd"
            ],
            [
                "4a6d57460d64c76f"
            ],
            [
                "3b2f348b9326267c"
            ],
            [
                "eb3524b2b7bf51e5"
            ],
            [
                "2e5425d73a166c9b"
            ],
            [
                "010c5119a7e833b2"
            ],
            [
                "cd9d55c23ebcee86"
            ],
            [
                "5e7062bde869c7a5"
            ],
            [
                "871009c15ad9a99b"
            ],
            [
                "ccec30ad0f32bbdf"
            ],
            [
                "ae9f041c9cd36bb9"
            ],
            [
                "1bb521d55aeb5eba"
            ],
            [
                "d76a4a48e1beaed6"
            ],
            [
                "6b27f0f99ea11a72"
            ],
            [
                "f82e60f4adb5e60b"
            ],
            [
                "e5d61c5724c6ed1b"
            ],
            [
                "f171dcbe8b5d2e05"
            ],
            [
                "b2bda5ef5e68c98d"
            ],
            [
                "cb64b7a9a87f03cc"
            ],
            [
                "9621acf15d833362"
            ],
            [
                "b91d72f6d383c0d6"
            ],
            [
                "c38d48059f463772"
            ],
            [
                "a0357de00b26b002"
            ],
            [
                "bacdea9854675b01"
            ],
            [
                "0ecfccb41b17f21b"
            ],
            [
                "1b079a5b225e1552"
            ],
            [
                "f945d56c437bfb38"
            ],
            [
                "40bc1ec5180b6589"
            ],
            [
                "2d9036a34ecd189a"
            ],
            [
                "5ac8d282ced2b5a1"
            ],
            [
                "5bb6491915c598ce"
            ],
            [
                "b797e5a52b6db5b4"
            ]
        ]
    },
    {
        "id": "96c3c21a4dd0b9bd",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AUTOFILL_STATUS",
        "func": "// Status Updater for Autofill\n\n// Decodes the incoming autofill message status to a final \"on\" or \"off\"\nfunction decodeAutofillMessage(dgn, data) {\n  let finalStatus = \"off\";\n\n  // Check the first byte for the operating status\n  if (data.length > 0) {\n    const operatingStatusBits = data[0] & 0x03; // Mask for bits 0-1\n    if (operatingStatusBits === 1) {\n      // 01b = AutoFill on\n      finalStatus = \"on\";\n    }\n  }\n\n  const result = {\n    dgn: dgn,\n    dgn_name: \"AUTOFILL_STATUS\",\n    instance: \"autofill\", // Hard-code to string instance name\n    status: finalStatus,\n  };\n\n  return result;\n}\n\n// === Main Logic ===\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected an object\");\n  return null;\n}\nconst { dgn, data_payload } = msg.payload;\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  dataBytes.push(parseInt(data_payload.substring(i, i + 2), 16));\n}\nconst decodedData = decodeAutofillMessage(dgn, dataBytes);\nmsg.payload = { ...msg.payload, ...decodedData };\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 100,
        "wires": [
            [
                "b87fcd5e60905824"
            ]
        ]
    },
    {
        "id": "19307edfe4e5bd84",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 1120,
        "wires": []
    },
    {
        "id": "b2bda5ef5e68c98d",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_AC_STATUS",
        "func": "// Status Updater for Charger AC\n// Decodes CHARGER_AC_STATUS messages\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_AC_STATUS Specific Decoders ===\n\nfunction decodeChargerACInstance(value) {\n    // Charger AC instance interpretation\n    // For chargers, this typically indicates the AC input line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    // Special handling for 0xFF (all bits set) - typically means \"Not Available\"\n    if (value === 255) {\n        return {\n            faults: \"No Faults\",\n            open_ground: false,\n            open_neutral: false,\n            reverse_polarity: false,\n            ground_current_fault: false,\n            any_fault: false\n        };\n    }\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n\n// === Main Decode Function ===\n\nfunction decodeChargerACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_AC_STATUS\"\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_available = result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === 'number' &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.charging_capable = result.ac_available && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_AC_STATUS message\nconst decodedData = decodeChargerACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1120,
        "wires": [
            [
                "19307edfe4e5bd84"
            ]
        ]
    },
    {
        "id": "91cac903d306591a",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 1240,
        "wires": []
    },
    {
        "id": "9621acf15d833362",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_AC_STATUS",
        "func": "// Status Updater for Inverter AC\n// Decodes INVERTER_AC_STATUS\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n  const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n  return (value & mask) >> startBit;\n}\n\n// === INVERTER_AC_STATUS Specific Decoders ===\n\nfunction decodeInverterACInstance(value) {\n  // Inverter AC instance interpretation\n  // For inverters, this typically indicates the AC output line\n  if (value <= 200) {\n    return value; // Direct instance number\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n  // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n  if (value <= 65530) {\n    return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n  } else if (value === 65533) {\n    return \"Out of Range\";\n  } else if (value === 65534) {\n    return \"Reserved\";\n  } else if (value === 65535) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n  // AC RMS current (see Table 5.3 - standard RV-C scaling)\n  // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n  if (value === 32000) {\n    return 0; // Special zero encoding\n  } else if (value <= 65530) {\n    return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n  } else if (value === 65533) {\n    return \"Out of Range\";\n  } else if (value === 65534) {\n    return \"Reserved\";\n  } else if (value === 65535) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n  // AC frequency with 1/128 Hz precision, 0-500 Hz range\n  if (value <= 64000) {\n    return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n  } else if (value === 65533) {\n    return \"Out of Range\";\n  } else if (value === 65534) {\n    return \"Reserved\";\n  } else if (value === 65535) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n  // Decode fault bits from byte 7\n  const faults = [];\n\n  const openGround = decodeBits(value, 0, 1);\n  const openNeutral = decodeBits(value, 2, 3);\n  const reversePolarity = decodeBits(value, 4, 5);\n  const groundCurrent = decodeBits(value, 6, 7);\n\n  if (openGround === 1) faults.push(\"Open Ground\");\n  if (openNeutral === 1) faults.push(\"Open Neutral\");\n  if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n  if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n  return {\n    faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n    open_ground: openGround === 1,\n    open_neutral: openNeutral === 1,\n    reverse_polarity: reversePolarity === 1,\n    ground_current_fault: groundCurrent === 1,\n    any_fault: faults.length > 0,\n  };\n}\n\nfunction decodeUint16(data, startByte) {\n  // Decode 16-bit value (little-endian)\n  if (!data || startByte + 1 >= data.length) {\n    return 65535; // Not available\n  }\n  return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterACMessage(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"INVERTER_AC_STATUS\",\n  };\n\n  // Decode based on AC_STATUS_1 format (8 bytes)\n  if (data.length >= 8) {\n    // Byte 0: Instance\n    result.instance = decodeInverterACInstance(data[0]);\n\n    // Bytes 1-2: RMS Voltage (uint16, little-endian)\n    const voltageRaw = decodeUint16(data, 1);\n    result.rms_voltage = decodeACVoltage(voltageRaw);\n\n    // Bytes 3-4: RMS Current (uint16, little-endian)\n    const currentRaw = decodeUint16(data, 3);\n    result.rms_current = decodeACCurrent(currentRaw);\n\n    // Bytes 5-6: Frequency (uint16, little-endian)\n    const frequencyRaw = decodeUint16(data, 5);\n    result.frequency = decodeFrequency(frequencyRaw);\n\n    // Byte 7: Fault bits\n    if (data.length > 7) {\n      const faultInfo = decodeFaultBits(data[7]);\n      result.fault_status = faultInfo.faults;\n      result.open_ground = faultInfo.open_ground;\n      result.open_neutral = faultInfo.open_neutral;\n      result.reverse_polarity = faultInfo.reverse_polarity;\n      result.ground_current_fault = faultInfo.ground_current_fault;\n      result.any_fault = faultInfo.any_fault;\n    }\n\n    // Raw values for debugging\n    result.raw_voltage = voltageRaw;\n    result.raw_current = currentRaw;\n    result.raw_frequency = frequencyRaw;\n    if (data.length > 7) {\n      result.raw_fault_byte = data[7];\n    }\n  }\n\n  // Add convenience fields\n  result.ac_output_active =\n    result.rms_voltage !== \"Not Available\" &&\n    typeof result.rms_voltage === \"number\" &&\n    result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n  result.inverter_loaded =\n    result.rms_current !== \"Not Available\" &&\n    typeof result.rms_current === \"number\" &&\n    result.rms_current > 0.1; // Some current flow\n\n  result.inverter_available = !result.any_fault;\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_AC_STATUS message\nconst decodedData = decodeInverterACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1240,
        "wires": [
            [
                "91cac903d306591a"
            ]
        ]
    },
    {
        "id": "9e8e5609c54fec82",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WATER_PUMP_STATUS",
        "func": "// Status Updater for Water Pump\n// Decodes WATER_PUMP_STATUS messages (1FFB3)\n\n\n\nconst data_payload = msg.payload.data_payload;\n\n// We only need the first byte for the status\nif (data_payload.length < 2) {\n  node.warn(\"Data payload is too short to decode.\");\n  return null;\n}\n\n// Get the first byte and parse it\nconst firstByte = parseInt(data_payload.substring(0, 2), 16);\n\n// Extract the first two bits (00-11) which represent the operating status\nconst statusBits = firstByte & 0x03; // Mask to get only the first two bits\n\n// A value of 1 means \"enabled\"\nconst finalStatus = statusBits === 1 ? \"ON\" : \"OFF\";\n\n// Prepare the payload for the downstream status updater node\nmsg.payload = {\n  ...msg.payload, // Keep the original message data\n  instance: \"water_pump\",\n  status: finalStatus,\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 40,
        "wires": [
            [
                "295d4bc9058dab71"
            ]
        ]
    },
    {
        "id": "b9d5913b9730b3e0",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_AMBIENT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1370,
        "y": 760,
        "wires": []
    },
    {
        "id": "1bb521d55aeb5eba",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_AMBIENT_STATUS",
        "func": "// Status Updater for Thermostat Ambient\n// Decodes THERMOSTAT_AMBIENT_STATUS messages\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_AMBIENT_STATUS Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value <= 250) {\n        return \"Out of Range\"; // Values 201-250\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeHumidity(value) {\n    // Humidity as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDewPoint(value, isCelsius = false) {\n    // Dew point temperature with same encoding as ambient temperature\n    return decodeTemperature(value, isCelsius);\n}\n\nfunction decodeAirQuality(value) {\n    // Air quality index\n    const qualityLevels = {\n        0: \"Good\",\n        1: \"Moderate\",\n        2: \"Unhealthy for Sensitive\",\n        3: \"Unhealthy\",\n        4: \"Very Unhealthy\",\n        5: \"Hazardous\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return qualityLevels[value] || `Unknown Quality ${value}`;\n}\n\nfunction decodeSensorStatus(value) {\n    // Handle special values first\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 251) {\n        return \"Error\";\n    }\n\n    // Sensor status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Temperature Valid\");\n    if (value & 0x02) statusBits.push(\"Humidity Valid\");\n    if (value & 0x04) statusBits.push(\"Dew Point Valid\");\n    if (value & 0x08) statusBits.push(\"Air Quality Valid\");\n    if (value & 0x10) statusBits.push(\"Sensor Calibrated\");\n    if (value & 0x20) statusBits.push(\"Sensor Fault\");\n    if (value & 0x40) statusBits.push(\"Low Battery\");\n    if (value & 0x80) statusBits.push(\"Communication Error\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_AMBIENT_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'ambient temperature' || param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name.includes('humidity')) {\n            return decodeHumidity(value);\n        }\n        if (param.name === 'dew point' || param.name.includes('dew')) {\n            return decodeDewPoint(value);\n        }\n        if (param.name === 'air quality' || param.name.includes('quality')) {\n            return decodeAirQuality(value);\n        }\n        if (param.name === 'sensor status' || param.name.includes('status')) {\n            return decodeSensorStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatAmbientMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_AMBIENT_STATUS\"\n    };\n\n    // Decode based on THERMOSTAT_AMBIENT_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[1]);\n\n        // Byte 2: Humidity\n        result.humidity = decodeHumidity(data[2]);\n\n        // Byte 3: Dew Point\n        result.dew_point = decodeDewPoint(data[3]);\n\n        // Byte 4: Air Quality Index\n        result.air_quality = decodeAirQuality(data[4]);\n\n        // Byte 5: Sensor Status\n        result.sensor_status = decodeSensorStatus(data[5]);\n\n        // Bytes 6-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_ambient_temperature = data[1];\n        result.raw_humidity = data[2];\n        result.raw_dew_point = data[3];\n        result.raw_air_quality = data[4];\n        result.raw_sensor_status = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    if (result.ambient_temperature !== undefined && typeof result.ambient_temperature === 'number') {\n        result.temperature_fahrenheit = parseFloat(((result.ambient_temperature * 9 / 5) + 32).toFixed(1));\n    }\n\n    result.sensor_available = result.instance !== \"Not Available\" &&\n        result.ambient_temperature !== \"Not Available\";\n\n    result.humidity_available = typeof result.humidity === 'number';\n    result.air_quality_available = result.air_quality !== \"Not Available\" &&\n        result.air_quality !== \"Not Supported\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_AMBIENT_STATUS message\nconst decodedData = decodeThermostatAmbientMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 760,
        "wires": [
            [
                "b9d5913b9730b3e0"
            ]
        ]
    },
    {
        "id": "cd9d55c23ebcee86",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FLOOR_HEAT_STATUS",
        "func": "// Status Updater for Floor Heat\n// Decodes FLOOR_HEAT_STATUS messages (1FEFC)\n\nfunction decodeFloorHeatInstance(value) {\n  // Per Table 5.3 (Standard_Physical_Units.pdf, pg 2)\n  if (value === 0) {\n    return \"all\"; //\n  } else if (value <= 250) {\n    return value; // Direct instance number\n  } else if (value === 254) {\n    return \"Out of range / not configured\"; //\n  } else if (value === 255) {\n    return \"Data not available\"; //\n  }\n  // Values 251-253 are not defined in this standard\n  return \"Reserved/Invalid\";\n}\n\n// Decodes Operating Mode from Byte 1, Bits 0-1\nfunction decodeOperatingMode(value) {\n  const modes = {\n    0: \"Automatic\", // 00b\n    1: \"Manual\", // 01b\n  };\n  return modes[value] || \"Reserved\";\n}\n\n// Decodes Operating Status from Byte 1, Bits 2-3\nfunction decodeOperatingStatus(value) {\n  const states = {\n    0: \"Off\", // 00b\n    1: \"On\", // 01b\n  };\n  return states[value] || \"Reserved\";\n}\n\n// Decodes Heat Element Status from Byte 1, Bits 4-5\nfunction decodeHeatElementStatus(value) {\n  const states = {\n    0: \"Off\", // 00b\n    1: \"On\", // 01b\n  };\n  return states[value] || \"Reserved\";\n}\n\n// Decodes Schedule Mode from Byte 1, Bits 6-7\nfunction decodeScheduleMode(value) {\n  const modes = {\n    0: \"Disabled\", // 00b\n    1: \"Enabled\", // 01b\n  };\n  return modes[value] || \"Reserved\";\n}\n\n//Decodes a standard RV-C temperature value (uint16).\n// Uses 0.03125°C resolution (per RVC spec) with -273.15°C offset (Kelvin).\nfunction decodeTemperature(value, isCelsius = false) {\n  if (value === 0) {\n    return \"Not Available\";\n  } else if (value <= 65530) {\n    const tempK = value * 0.03125; // Kelvin\n    const tempC = tempK - 273.15; // Convert to Celsius\n\n    if (isCelsius) {\n      return parseFloat(tempC.toFixed(1));\n    } else {\n      // Convert to Fahrenheit: F = C * 9/5 + 32\n      return parseFloat(((tempC * 9) / 5 + 32).toFixed(1));\n    }\n  } else if (value === 65533) {\n    return \"Out of Range\";\n  } else if (value === 65534) {\n    return \"Reserved\";\n  } else if (value === 65535) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\n// Decodes the dead band value from Byte 6.\nfunction decodeDeadband(value) {\n  // Spec: Precision = 0.1°C, Value range = 0.0 to 25.0°C\n  if (value <= 250) {\n    return parseFloat((value * 0.1).toFixed(1)); // 0.1°C\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeFloorHeatMessage(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"FLOOR_HEAT_STATUS\",\n  };\n\n  // Spec defines 7 bytes (0-6)\n  if (data.length < 7) {\n    result.decoding_error = \"Payload too short. Expected 7 bytes for 1FEFCh.\";\n    return result; // Return error object to allow debugging\n  }\n\n  // Byte 0: Instance\n  result.instance = decodeFloorHeatInstance(data[0]);\n  result.raw_instance = data[0];\n\n  // Check if the instance is a valid number.\n  // If it's a string (\"all\", \"Data not available\", etc.), return null to filter.\n  if (typeof result.instance !== \"number\") {\n    //node.warn(`Message filtered: Instance is not a valid number (${result.instance}).`);\n    return null;\n  }\n\n  // Byte 1: Bit-packed fields\n  const byte1 = data[1];\n  result.operating_mode = decodeOperatingMode(byte1 & 0x03); // Bits 0-1\n  result.operating_status = decodeOperatingStatus((byte1 >> 2) & 0x03); // Bits 2-3\n  result.heat_element_status = decodeHeatElementStatus((byte1 >> 4) & 0x03); // Bits 4-5\n  result.schedule_mode = decodeScheduleMode((byte1 >> 6) & 0x03); // Bits 6-7\n  result.raw_byte1 = byte1;\n\n  // Bytes 2-3: Measured Temperature (uint16, little-endian)\n  const tempRaw = data[2] | (data[3] << 8);\n  result.measured_temperature = decodeTemperature(tempRaw);\n  result.raw_temperature = tempRaw;\n\n  // Bytes 4-5: Set Point (uint16, little-endian)\n  const setpointRaw = data[4] | (data[5] << 8);\n  // Use the same decodeTemperature function for the set point\n  result.set_point = decodeTemperature(setpointRaw);\n  result.raw_setpoint = setpointRaw;\n\n  // Byte 6: Dead band (uint8)\n  result.dead_band_c = decodeDeadband(data[6]);\n  result.raw_dead_band = data[6];\n\n  // Byte 7: Not defined in the spec table\n  if (data.length > 7) {\n    result.raw_byte7 = data[7];\n  }\n\n  // Add convenience fields\n  result.floor_heat_on = result.operating_status === \"On\";\n  result.heating_active = result.heat_element_status === \"On\";\n  result.floor_heat_available =\n    result.instance !== \"Not Available\" &&\n    result.instance !== \"Error\" &&\n    result.instance !== \"Not Supported\";\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the FLOOR_HEAT_STATUS message\nconst decodedData = decodeFloorHeatMessage(dgn, dataBytes);\n\n// If decodeFloorHeatMessage returned null (e.g., invalid instance),\n// stop the flow here by returning null.\nif (decodedData === null) {\n  return null;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 460,
        "wires": [
            [
                "db73295f937c90a1"
            ]
        ]
    },
    {
        "id": "e06ff8584295e0bd",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 700,
        "wires": []
    },
    {
        "id": "ae9f041c9cd36bb9",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_2",
        "func": "// Status Updater for Thermostat Ext\n// Decodes THERMOSTAT_STATUS_2 messages (1FEE0)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_2 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrentScheduleInstance(value) {\n    // Current schedule instance mapping\n    if (value === 0) {\n        return \"Sleep\";\n    } else if (value === 1) {\n        return \"Wake\";\n    } else if (value === 2) {\n        return \"Away\";\n    } else if (value === 3) {\n        return \"Return\";\n    } else if (value >= 4 && value <= 249) {\n        return `Additional Instance ${value}`;\n    } else if (value === 250) {\n        return \"Storage\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeScheduleInstances(value) {\n    // Number of schedule instances capacity\n    if (value <= 200) {\n        return value; // Direct count\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeReducedNoiseMode(value) {\n    // Reduced noise mode from bit field\n    if (value === 0) {\n        return \"Disabled\";\n    } else if (value === 1) {\n        return \"Enabled\";\n    }\n    return \"Unknown\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific THERMOSTAT_STATUS_2 parameter types\n        if (param.name === 'instance') {\n            return decodeThermostatInstance(value);\n        }\n        if (param.name === 'current schedule instance') {\n            return decodeCurrentScheduleInstance(value);\n        }\n        if (param.name === 'number of schedule instances') {\n            return decodeScheduleInstances(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit' || param.type === 'bit2' || (param.type.startsWith('uint') && param.bit)) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.name === 'reduced noise mode') {\n                return decodeReducedNoiseMode(bitValue);\n            }\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus2Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_2\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_2 format (typically 4-8 bytes)\n    if (data.length > 0) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Current Schedule Instance\n        if (data.length > 1) {\n            result.current_schedule_instance = decodeCurrentScheduleInstance(data[1]);\n        }\n\n        // Byte 2: Number of Schedule Instances\n        if (data.length > 2) {\n            result.number_of_schedule_instances = decodeScheduleInstances(data[2]);\n        }\n\n        // Byte 3: Reduced Noise Mode (bits 0-1)\n        if (data.length > 3) {\n            if (data[3] === 255) {\n                result.reduced_noise_mode = \"Not Available\";\n            } else if (data[3] === 254) {\n                result.reduced_noise_mode = \"Reserved\";\n            } else if (data[3] === 253) {\n                result.reduced_noise_mode = \"Out of Range\";\n            } else {\n                const noiseBits = decodeBits(data[3], 0, 1);\n                result.reduced_noise_mode = decodeReducedNoiseMode(noiseBits);\n            }\n        }\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        if (data.length > 1) result.raw_current_schedule = data[1];\n        if (data.length > 2) result.raw_schedule_count = data[2];\n        if (data.length > 3) result.raw_features_byte = data[3];\n        if (data.length > 4) result.raw_byte_4 = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.scheduling_supported = result.number_of_schedule_instances !== \"Not Available\" &&\n        typeof result.number_of_schedule_instances === 'number' &&\n        result.number_of_schedule_instances > 0;\n\n    result.current_mode = result.current_schedule_instance;\n\n    // Determine if in a standard schedule mode\n    if (typeof result.current_schedule_instance === 'string') {\n        const schedule = result.current_schedule_instance.toLowerCase();\n        result.in_sleep_mode = schedule === \"sleep\";\n        result.in_wake_mode = schedule === \"wake\";\n        result.in_away_mode = schedule === \"away\";\n        result.in_return_mode = schedule === \"return\";\n        result.in_standard_schedule = [\"sleep\", \"wake\", \"away\", \"return\"].includes(schedule);\n    }\n\n    result.quiet_mode_active = result.reduced_noise_mode === \"Enabled\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_2 message\nconst decodedData = decodeThermostatStatus2Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 700,
        "wires": [
            [
                "e06ff8584295e0bd"
            ]
        ]
    },
    {
        "id": "6a02f9f3c2b95dcc",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 880,
        "wires": []
    },
    {
        "id": "6b27f0f99ea11a72",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_STATUS",
        "func": "// Status Updater for Generator\n// Decodes GENERATOR_STATUS messages (1FFC6)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_STATUS Specific Decoders ===\n\nfunction decodeGeneratorInstance(value) {\n    // Generator instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Generator operating state mapping (extended)\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Cool Down\",\n        5: \"Prime/Pre-Heat\",\n        6: \"Exercise\",\n        7: \"Test\",\n        8: \"Fault\",\n        9: \"Maintenance Required\",\n        10: \"Remote Start\",\n        11: \"Warm Up\",\n        12: \"Load Test\",\n        13: \"Safety Shutdown\",\n        14: \"Over Temperature\",\n        15: \"Low Oil Pressure\",\n        16: \"Over Speed\",\n        17: \"Under Speed\",\n        18: \"Over Voltage\",\n        19: \"Under Voltage\",\n        20: \"Over Current\",\n        21: \"Under Current\",\n        22: \"Auto Start\",\n        23: \"Manual Start\",\n        24: \"Scheduled Start\",\n        25: \"Emergency Start\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\",\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeGeneratorCommand(value) {\n    // Generator command mapping\n    const commands = {\n        0: \"Stop\",\n        1: \"Start\",\n        2: \"Exercise\",\n        3: \"Test\",\n        4: \"Prime\",\n        5: \"Pre-Heat\",\n        6: \"Reset Fault\",\n        7: \"Clear Maintenance\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\",\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n    // Fuel type mapping\n    const fuelTypes = {\n        0: \"Unknown\",\n        1: \"Gasoline\",\n        2: \"Diesel\",\n        3: \"Propane\",\n        4: \"Natural Gas\",\n        5: \"Dual Fuel\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\",\n    };\n\n    return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeEngineRPM(value) {\n    // Engine RPM (4 RPM resolution)\n    if (value <= 16000) {\n        return value * 4; // 4 RPM per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeRunTime(value) {\n    // Run time in hours (0.1 hour resolution)\n    if (value <= 655300) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1 hour per step\n    } else if (value === 4294967293) {\n        return \"Out of Range\";\n    } else if (value === 4294967294) {\n        return \"Reserved\";\n    } else if (value === 4294967295) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFuelLevel(value) {\n    // Fuel level as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOilPressure(value) {\n    // Oil pressure in kPa (0.5 kPa resolution)\n    if (value <= 500) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5 kPa per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 1.2).toFixed(1)); // 1.2V per step, 0-300V range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current for single-byte generator status (simplified)\n    if (value <= 250) {\n        return parseFloat((value * 0.4).toFixed(1)); // 0.4A per step, 0-100A range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultStatus(value) {\n    // Fault status bit field\n    const faults = [];\n\n    if (value & 0x01) faults.push(\"Low Oil Pressure\");\n    if (value & 0x02) faults.push(\"High Temperature\");\n    if (value & 0x04) faults.push(\"Low Fuel\");\n    if (value & 0x08) faults.push(\"Overcurrent\");\n    if (value & 0x10) faults.push(\"Overvoltage\");\n    if (value & 0x20) faults.push(\"Undervoltage\");\n    if (value & 0x40) faults.push(\"Service Required\");\n    if (value & 0x80) faults.push(\"System Fault\");\n\n    return faults.length > 0 ? faults.join(\", \") : \"No Faults\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === \"string\" && param.byte.includes(\"-\")) {\n        const [startByte, endByte] = param.byte.split(\"-\").map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === \"uint8\") {\n        // Handle specific GENERATOR_STATUS parameter types\n        if (param.name === \"instance\") {\n            return decodeGeneratorInstance(value);\n        }\n        if (param.name === \"operating state\" || param.name === \"state\") {\n            return decodeOperatingState(value);\n        }\n        if (param.name === \"command\") {\n            return decodeGeneratorCommand(value);\n        }\n        if (param.name === \"fuel type\") {\n            return decodeFuelType(value);\n        }\n        if (param.name.includes(\"temperature\")) {\n            return decodeTemperature(value);\n        }\n        if (param.name === \"fuel level\") {\n            return decodeFuelLevel(value);\n        }\n        if (param.name === \"oil pressure\") {\n            return decodeOilPressure(value);\n        }\n        if (param.name === \"fault status\" || param.name === \"faults\") {\n            return decodeFaultStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n    } else if (param.type === \"uint16\") {\n        if (param.name === \"engine rpm\" || param.name === \"rpm\") {\n            return decodeEngineRPM(value);\n        }\n\n        // Default uint16 handling\n        return value;\n    } else if (param.type === \"uint32\") {\n        if (param.name === \"run time\" || param.name === \"runtime\") {\n            return decodeRunTime(value);\n        }\n\n        // Default uint32 handling\n        return value;\n    } else if (\n        param.type === \"bit2\" ||\n        (param.type.startsWith(\"uint\") && param.bit)\n    ) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_STATUS\",\n    };\n\n    // Decode based on GENERATOR_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Fuel Type\n        result.fuel_type = decodeFuelType(data[2]);\n\n        // Bytes 3-4: Engine RPM (16-bit, little-endian)\n        const engineRPM = data[3] | (data[4] << 8);\n        result.engine_rpm = decodeEngineRPM(engineRPM);\n\n        // Byte 5: AC Voltage (single byte for generators)\n        result.ac_voltage = decodeACVoltage(data[5]);\n\n        // Byte 6: AC Current (single byte approximation)\n        result.ac_current = decodeACCurrent(data[6]);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_fuel_type = data[2];\n        result.raw_engine_rpm_bytes = [data[3], data[4]];\n        result.raw_ac_voltage = data[5];\n        result.raw_ac_current = data[6];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.generator_running = state === \"running\";\n        result.generator_available = ![\n            \"fault\",\n            \"maintenance required\",\n            \"error\",\n        ].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_exercising = state === \"exercise\";\n        result.needs_maintenance = state === \"maintenance required\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (\n        typeof result.ac_voltage === \"number\" &&\n        typeof result.ac_current === \"number\"\n    ) {\n        result.ac_power = parseFloat(\n            (result.ac_voltage * result.ac_current).toFixed(2),\n        );\n    }\n\n    // Engine status\n    result.engine_running =\n        typeof result.engine_rpm === \"number\" && result.engine_rpm > 0;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.warn(\"Invalid payload: expected object\");\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n    node.warn(\"Invalid data_payload: must be even-length hex string\");\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_STATUS message\nconst decodedData = decodeGeneratorMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 880,
        "wires": [
            [
                "6a02f9f3c2b95dcc"
            ]
        ]
    },
    {
        "id": "f82e60f4adb5e60b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_AC_STATUS",
        "func": "// Status Updater for Generator AC\n// Decodes GENERATOR_AC_STATUS messages\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_AC_STATUS Specific Decoders ===\n\nfunction decodeGeneratorACInstance(value) {\n    // Generator AC instance interpretation\n    // For generators, this typically indicates the AC output line\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0,\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_AC_STATUS\",\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeGeneratorACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields\n    result.ac_output_active =\n        result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === \"number\" &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.generator_loaded =\n        result.rms_current !== \"Not Available\" &&\n        typeof result.rms_current === \"number\" &&\n        result.rms_current > 0.1; // Some current flow\n\n    result.generator_ac_available = result.ac_output_active && !result.any_fault;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.warn(\"Invalid payload: expected object\");\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n    node.warn(\"Invalid data_payload: must be even-length hex string\");\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_AC_STATUS message\nconst decodedData = decodeGeneratorACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 940,
        "wires": [
            [
                "6b903512de37f1ad"
            ]
        ]
    },
    {
        "id": "6b903512de37f1ad",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 940,
        "wires": []
    },
    {
        "id": "bacdea9854675b01",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_AC_STATUS",
        "func": "// Status Updater for ATS AC\n// Decodes ATS_AC_STATUS messages\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_AC_STATUS Specific Decoders ===\n\nfunction decodeATSACInstance(value) {\n    // ATS AC instance interpretation\n    // For ATS, this typically indicates the AC input/output line being monitored\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC RMS voltage (see Table 5.3 - standard RV-C scaling)\n    if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(1)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC RMS current (see Table 5.3 - standard RV-C scaling)\n    // Special case: 0x7D00 (32000) often represents zero in RV-C AC measurements\n    if (value === 32000) {\n        return 0; // Special zero encoding\n    } else if (value <= 65530) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency with 1/128 Hz precision, 0-500 Hz range\n    if (value <= 64000) {\n        return parseFloat((value / 128).toFixed(2)); // 1/128 Hz per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFaultBits(value) {\n    // Decode fault bits from byte 7 - ATS-specific fault interpretation\n    const faults = [];\n\n    const openGround = decodeBits(value, 0, 1);\n    const openNeutral = decodeBits(value, 2, 3);\n    const reversePolarity = decodeBits(value, 4, 5);\n    const groundCurrent = decodeBits(value, 6, 7);\n\n    if (openGround === 1) faults.push(\"Open Ground\");\n    if (openNeutral === 1) faults.push(\"Open Neutral\");\n    if (reversePolarity === 1) faults.push(\"Reverse Polarity\");\n    if (groundCurrent === 1) faults.push(\"Ground Current Fault\");\n\n    return {\n        faults: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n        open_ground: openGround === 1,\n        open_neutral: openNeutral === 1,\n        reverse_polarity: reversePolarity === 1,\n        ground_current_fault: groundCurrent === 1,\n        any_fault: faults.length > 0,\n    };\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeATSACMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_AC_STATUS\",\n    };\n\n    // Decode based on AC_STATUS_1 format (8 bytes)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeATSACInstance(data[0]);\n\n        // Bytes 1-2: RMS Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 1);\n        result.rms_voltage = decodeACVoltage(voltageRaw);\n\n        // Bytes 3-4: RMS Current (uint16, little-endian)\n        const currentRaw = decodeUint16(data, 3);\n        result.rms_current = decodeACCurrent(currentRaw);\n\n        // Bytes 5-6: Frequency (uint16, little-endian)\n        const frequencyRaw = decodeUint16(data, 5);\n        result.frequency = decodeFrequency(frequencyRaw);\n\n        // Byte 7: Fault bits\n        if (data.length > 7) {\n            const faultInfo = decodeFaultBits(data[7]);\n            result.fault_status = faultInfo.faults;\n            result.open_ground = faultInfo.open_ground;\n            result.open_neutral = faultInfo.open_neutral;\n            result.reverse_polarity = faultInfo.reverse_polarity;\n            result.ground_current_fault = faultInfo.ground_current_fault;\n            result.any_fault = faultInfo.any_fault;\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n        result.raw_frequency = frequencyRaw;\n        if (data.length > 7) {\n            result.raw_fault_byte = data[7];\n        }\n    }\n\n    // Add convenience fields for ATS operations\n    result.ac_source_available =\n        result.rms_voltage !== \"Not Available\" &&\n        typeof result.rms_voltage === \"number\" &&\n        result.rms_voltage > 50; // Reasonable AC voltage threshold\n\n    result.ats_load_present =\n        result.rms_current !== \"Not Available\" &&\n        typeof result.rms_current === \"number\" &&\n        result.rms_current > 0.1; // Some current flow\n\n    result.ac_source_qualified =\n        result.ac_source_available &&\n        !result.any_fault &&\n        typeof result.frequency === \"number\" &&\n        result.frequency >= 58 &&\n        result.frequency <= 62; // Reasonable frequency range\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.warn(\"Invalid payload: expected object\");\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n    node.warn(\"Invalid data_payload: must be even-length hex string\");\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_AC_STATUS message\nconst decodedData = decodeATSACMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1480,
        "wires": [
            [
                "f80a9416a8e18e46"
            ]
        ]
    },
    {
        "id": "f80a9416a8e18e46",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_AC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1310,
        "y": 1480,
        "wires": []
    },
    {
        "id": "f171dcbe8b5d2e05",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CHARGER_STATUS",
        "func": "// Status Updater for Charger\n// Decodes CHARGER_STATUS messages (1FFCA)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === CHARGER_STATUS Specific Decoders ===\n\nfunction decodeChargerInstance(value) {\n    // Charger instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Charger operating state mapping\n    const states = {\n        0: \"Off\",\n        1: \"Bulk\",\n        2: \"Absorption\",\n        3: \"Overcharge\",\n        4: \"Equalize\",\n        5: \"Float\",\n        6: \"No Charge\",\n        7: \"Constant Voltage\",\n        8: \"Constant Current\",\n        9: \"Fault\",\n        10: \"Unavailable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeChargerCommand(value) {\n    // Charger command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Bulk\",\n        3: \"Absorption\",\n        4: \"Overcharge\",\n        5: \"Equalize\",\n        6: \"Float\",\n        7: \"Auto\",\n        8: \"Reset Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeChargerType(value) {\n    // Charger type mapping\n    const chargerTypes = {\n        0: \"Unknown\",\n        1: \"AC-DC Converter\",\n        2: \"Solar Controller\",\n        3: \"Wind Generator\",\n        4: \"Alternator\",\n        5: \"DC-DC Converter\",\n        6: \"Fuel Cell\",\n        7: \"Shore Power\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return chargerTypes[value] || `Unknown Type ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeEfficiency(value) {\n    // Efficiency as percentage\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Charging Active\");\n    if (value & 0x02) statusBits.push(\"AC Input Available\");\n    if (value & 0x04) statusBits.push(\"Battery Connected\");\n    if (value & 0x08) statusBits.push(\"Equalize Mode\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Reverse Polarity\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overvoltage Input\",\n        2: \"Undervoltage Input\",\n        3: \"Overtemperature\",\n        4: \"Fan Failure\",\n        5: \"Communication Error\",\n        6: \"Battery Fault\",\n        7: \"Ground Fault\",\n        8: \"Current Limit\",\n        9: \"Internal Fault\",\n        10: \"Reverse Polarity\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific CHARGER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeChargerInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeChargerCommand(value);\n        }\n        if (param.name === 'charger type' || param.name === 'type') {\n            return decodeChargerType(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'efficiency') {\n            return decodeEfficiency(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeChargerMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"CHARGER_STATUS\"\n    };\n\n    // Decode based on CHARGER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeChargerInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: Charger Type\n        result.charger_type = decodeChargerType(data[2]);\n\n        // Bytes 3-4: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[3] | (data[4] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Bytes 5-6: DC Current (16-bit, little-endian)\n        const dcCurrent = data[5] | (data[6] << 8);\n        result.dc_current = decodeDCCurrent(dcCurrent);\n\n        // Byte 7: Temperature\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_charger_type = data[2];\n        result.raw_dc_voltage_bytes = [data[3], data[4]];\n        result.raw_dc_current_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.charger_active = ![\"off\", \"no charge\", \"fault\", \"unavailable\", \"error\"].includes(state);\n        result.charger_charging = [\"bulk\", \"absorption\", \"float\", \"equalize\"].includes(state);\n        result.charger_available = ![\"fault\", \"unavailable\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.dc_voltage === 'number' && typeof result.dc_current === 'number') {\n        result.dc_power = parseFloat((result.dc_voltage * result.dc_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the CHARGER_STATUS message\nconst decodedData = decodeChargerMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1060,
        "wires": [
            [
                "78904d457471d1b2"
            ]
        ]
    },
    {
        "id": "78904d457471d1b2",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CHARGER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1060,
        "wires": []
    },
    {
        "id": "b91d72f6d383c0d6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_DC_STATUS",
        "func": "// Status Updater for Inverter DC\n// Decodes INVERTER_DC_STATUS messages\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_DC_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance interpretation\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCInstance(value) {\n    // DC Instance mapping\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\nfunction decodeDCVoltage(value) {\n    // DC Voltage in volts (0.05V resolution)\n    if (value <= 64000) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC Current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    // Handle signed 32-bit value\n    let signedValue = value;\n    if (value > 2147483647) {\n        signedValue = value - 4294967296; // Convert from unsigned to signed\n    }\n\n    if (Math.abs(signedValue) <= MAX_VALID) {\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeInverterState(value) {\n    // Inverter operational state\n    const states = {\n        0: \"Off\",\n        1: \"Starting\",\n        2: \"Running\",\n        3: \"Stopping\",\n        4: \"Sleep Mode\",\n        5: \"Search Mode\",\n        6: \"Standby\",\n        7: \"Fault\",\n        8: \"Battery Low\",\n        9: \"Overload\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\nfunction decodeUint32(data, startByte) {\n    // Decode 32-bit value (little-endian)\n    if (!data || startByte + 3 >= data.length) {\n        return 4294967295; // Not available\n    }\n    return data[startByte] |\n        (data[startByte + 1] << 8) |\n        (data[startByte + 2] << 16) |\n        (data[startByte + 3] << 24);\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterDCMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_DC_STATUS\"\n    };\n\n    // Decode INVERTER_DC_STATUS message (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Inverter Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: DC Instance (battery bank)\n        result.dc_source_instance = decodeDCInstance(data[1]);\n\n        // Bytes 2-3: DC Voltage (uint16, little-endian)\n        const voltageRaw = decodeUint16(data, 2);\n        result.dc_voltage = decodeDCVoltage(voltageRaw);\n\n        // Bytes 4-7: DC Current (uint32, little-endian, signed)\n        const currentRaw = decodeUint32(data, 4);\n        result.dc_current = decodeDCCurrent(currentRaw);\n\n        // Additional bytes if available for extended status\n        if (data.length > 8) {\n            // Byte 8: Inverter State (if available)\n            result.inverter_state = decodeInverterState(data[8]);\n        }\n\n        if (data.length > 9) {\n            // Byte 9: Temperature (if available)\n            result.temperature = decodeTemperature(data[9]);\n        }\n\n        // Raw values for debugging\n        result.raw_voltage = voltageRaw;\n        result.raw_current = currentRaw;\n    }\n\n    // Add convenience fields\n    result.dc_input_available = result.dc_voltage !== \"Not Available\" &&\n        typeof result.dc_voltage === 'number' &&\n        result.dc_voltage > 10; // Reasonable DC voltage threshold\n\n    result.inverter_drawing_power = result.dc_current !== \"Not Available\" &&\n        typeof result.dc_current === 'number' &&\n        Math.abs(result.dc_current) > 0.5; // Some current flow\n\n    result.inverter_supplying_power = result.dc_current !== \"Not Available\" &&\n        typeof result.dc_current === 'number' &&\n        result.dc_current < -0.5; // Negative current = supplying power\n\n    if (result.inverter_state !== undefined) {\n        const state = result.inverter_state.toString().toLowerCase();\n        result.inverter_operational = [\"running\", \"search mode\", \"standby\"].includes(state);\n        result.inverter_faulted = [\"fault\", \"battery low\", \"overload\"].includes(state);\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_DC_STATUS message\nconst decodedData = decodeInverterDCMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1300,
        "wires": [
            [
                "04bc7637ee7139d8"
            ]
        ]
    },
    {
        "id": "04bc7637ee7139d8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_DC_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1330,
        "y": 1300,
        "wires": []
    },
    {
        "id": "2e5425d73a166c9b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode TANK_STATUS",
        "func": "// Status Updater for Tank\n// Decodes TANK_STATUS messages (1FFB7)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === TANK_STATUS Specific Decoders ===\n\nfunction decodeTankInstance(value) {\n    // Tank instance mapping\n    const tankTypes = {\n        0: \"Fresh Water\",\n        1: \"Gray Water\",\n        2: \"Black Water\",\n        3: \"LPG\",\n        4: \"Fuel\",\n        5: \"Hot Water\",\n        6: \"Hydraulic Fluid\",\n        7: \"Live Well\",\n        8: \"Ballast\",\n        9: \"Oil\",\n        10: \"Coolant\",\n        11: \"Diesel Exhaust Fluid\",\n        12: \"Compressed Air\",\n        13: \"Fresh Water 2\",\n        14: \"Gray Water 2\",\n        15: \"Black Water 2\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return tankTypes[value] || `Unknown Tank ${value}`;\n}\n\nfunction decodeTankLevel(value) {\n    // Tank level as raw sensor reading (not percentage)\n    // Percentage calculated as: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw sensor reading\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankResolution(value) {\n    // Tank resolution as raw sensor resolution value\n    // Used in calculation: (relative_level / resolution) * 100\n    if (value <= 250) {\n        return value; // Raw resolution value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value) {\n    // Temperature in Celsius, offset -40°C\n    if (value <= 210) {\n        return value - 40; // -40°C to +170°C range\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTankStatus(value) {\n    // Tank status bit field decoding\n    const statusBits = {\n        0: \"Tank OK\",\n        1: \"Tank Low\",\n        2: \"Tank Full\",\n        3: \"Tank Overfilled\",\n        4: \"Sensor Fault\",\n        5: \"Tank Disconnected\",\n        6: \"Reserved\",\n        7: \"Reserved\"\n    };\n\n    const activeStatuses = [];\n    for (let bit = 0; bit < 8; bit++) {\n        if (value & (1 << bit)) {\n            activeStatuses.push(statusBits[bit]);\n        }\n    }\n\n    return activeStatuses.length > 0 ? activeStatuses.join(\", \") : \"Tank OK\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    const value = data[byte];\n\n    if (param.type === 'uint8') {\n        // Handle specific TANK_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeTankInstance(value);\n        }\n        if (param.name === 'relative level' || param.name === 'level') {\n            return decodeTankLevel(value);\n        }\n        if (param.name === 'resolution') {\n            return decodeTankResolution(value);\n        }\n        if (param.name === 'temperature') {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'status' || param.name === 'tank status') {\n            return decodeTankStatus(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeTankStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"TANK_STATUS\"\n    };\n\n    // Decode based on TANK_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Tank Instance\n        result.instance = data[0];\n        result.instance_name = decodeTankInstance(data[0]);\n\n        // Byte 1: Relative Level (0-200)\n        result.relative_level = decodeTankLevel(data[1]);\n\n        // Byte 2: Resolution (tank capacity steps)\n        result.resolution = decodeTankResolution(data[2]);\n\n        // Byte 3: Temperature\n        result.temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Tank Status (bit field)\n        result.status = decodeTankStatus(data[4]);\n\n        // Bytes 5-7: Reserved/Future use\n        // Currently set to 0xFF in most implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_relative_level = data[1];\n        result.raw_resolution = data[2];\n        result.raw_temperature = data[3];\n        result.raw_status = data[4];\n        if (data.length > 5) result.raw_byte_5 = data[5];\n        if (data.length > 6) result.raw_byte_6 = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields for easier consumption\n    // Calculate tank percentage using RV-C formula: (relative_level / resolution) * 100\n    if (result.relative_level !== undefined && result.resolution !== undefined &&\n        typeof result.relative_level === 'number' && typeof result.resolution === 'number' &&\n        result.resolution > 0) {\n        result.level_percentage = Math.round((result.relative_level / result.resolution) * 100);\n    } else if (result.relative_level !== undefined && typeof result.relative_level === 'number') {\n        // Fallback if resolution is not available (direct percentage)\n        result.level_percentage = Math.round(result.relative_level * 0.5); // 0.5% per step\n    }\n\n    if (result.instance !== undefined) {\n        // Map numeric instance to single-word tank type\n        const tankTypeMap = {\n            0: \"fresh\",\n            1: \"gray\",\n            2: \"black\",\n            3: \"lpg\",\n            4: \"fuel\",\n            5: \"hot\",\n            6: \"hydraulic\",\n            7: \"livewell\",\n            8: \"ballast\",\n            9: \"oil\",\n            10: \"coolant\",\n            11: \"def\",\n            12: \"air\",\n            13: \"fresh2\",\n            14: \"gray2\",\n            15: \"black2\",\n            251: \"error\",\n            252: \"notsupported\",\n            253: \"outofrange\",\n            254: \"reserved\",\n            255: \"notavailable\"\n        };\n\n        result.tank_type = tankTypeMap[result.instance] || \"other\";\n    }\n\n    // Tank level status\n    if (typeof result.level_percentage === 'number') {\n        result.tank_empty = result.level_percentage <= 5;\n        result.tank_low = result.level_percentage <= 25;\n        result.tank_full = result.level_percentage >= 95;\n        result.tank_level_available = true;\n    } else {\n        result.tank_level_available = false;\n    }\n\n    // Validate instance - Tank spec defines instances 0-19 for tank types\n    // RV-C special values 251-255 indicate error/unavailable status\n    const validInstances = [0, 1, 2, 3, 16, 17, 18, 19];\n    const isValidRange = result.instance <= 19 || (result.instance >= 16 && result.instance <= 19);\n\n    if (result.instance > 250 || (!isValidRange && result.instance > 19)) {\n        node.warn(`Invalid tank instance: ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    // Temperature status\n    result.temperature_available = typeof result.temperature === 'number';\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the TANK_STATUS message\nconst decodedData = decodeTankStatusMessage(dgn, dataBytes);\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 340,
        "wires": [
            [
                "45ae070eafc9a732"
            ]
        ]
    },
    {
        "id": "e5d61c5724c6ed1b",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode GENERATOR_DEMAND_STATUS",
        "func": "// Status Updater for Generator Demand\n// Decodes GENERATOR_DEMAND_STATUS messages (1FF9B)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === GENERATOR_DEMAND_STATUS Specific Decoders ===\n\nfunction decodeDemandStatus(value) {\n    // Decode demand status bits (2-bit fields)\n    const states = {\n        0: \"No Demand\",\n        1: \"Demand Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\",\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeOverrideStatus(value) {\n    // Decode override/activity status bits (2-bit fields)\n    const states = {\n        0: \"Normal Operation\",\n        1: \"Override/Activity Active\",\n        2: \"Reserved\",\n        3: \"Not Supported\",\n    };\n    return states[value] || \"Unknown\";\n}\n\nfunction decodeTime(hour, minute) {\n    // Convert hour and minute to readable time format\n    if (hour === 255 || minute === 255) {\n        return \"Not Available\";\n    }\n    if (hour > 23 || minute > 59) {\n        return \"Invalid Time\";\n    }\n\n    // Format as 24-hour time\n    const hourStr = hour.toString().padStart(2, \"0\");\n    const minStr = minute.toString().padStart(2, \"0\");\n    return `${hourStr}:${minStr}`;\n}\n\nfunction decodeMinimumCycleTime(value) {\n    // Minimum cycle time in minutes\n    if (value === 0) {\n        return \"No Minimum\";\n    } else if (value <= 250) {\n        return `${value} minutes`;\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeGeneratorDemandMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"GENERATOR_DEMAND_STATUS\",\n    };\n\n    if (data.length >= 7) {\n        // Byte 0: Demand status bits\n        const byte0 = data[0];\n        result.generator_demand = decodeDemandStatus(decodeBits(byte0, 0, 1));\n        result.internal_demand = decodeDemandStatus(decodeBits(byte0, 2, 3));\n        result.network_demand = decodeDemandStatus(decodeBits(byte0, 4, 5));\n        result.external_activity_detected = decodeOverrideStatus(\n            decodeBits(byte0, 6, 7),\n        );\n\n        // Byte 1: Override and control status bits\n        const byte1 = data[1];\n        result.manual_override_detected = decodeOverrideStatus(\n            decodeBits(byte1, 0, 1),\n        );\n        result.quiet_time = decodeOverrideStatus(decodeBits(byte1, 2, 3));\n        result.quiet_time_override = decodeOverrideStatus(decodeBits(byte1, 4, 5));\n        result.generator_lock = decodeOverrideStatus(decodeBits(byte1, 6, 7));\n\n        // Bytes 2-3: Quiet time begin (DEPRECATED but still decoded)\n        result.quiet_time_begin = decodeTime(data[2], data[3]);\n\n        // Bytes 4-5: Quiet time end (DEPRECATED but still decoded)\n        if (data.length >= 6) {\n            result.quiet_time_end = decodeTime(data[4], data[5]);\n        }\n\n        // Byte 6: Minimum cycle time\n        if (data.length >= 7) {\n            result.minimum_cycle_time = decodeMinimumCycleTime(data[6]);\n        }\n\n        // Raw values for debugging\n        result.raw_demand_byte = byte0;\n        result.raw_control_byte = byte1;\n    }\n\n    // Add convenience fields for easier automation logic\n    result.generator_should_run =\n        result.generator_demand === \"Demand Active\" ||\n        result.internal_demand === \"Demand Active\" ||\n        result.network_demand === \"Demand Active\";\n\n    result.automatic_start_allowed =\n        result.external_activity_detected !== \"Override/Activity Active\" &&\n        result.generator_lock !== \"Override/Activity Active\";\n\n    result.quiet_time_active =\n        result.quiet_time === \"Override/Activity Active\" &&\n        result.quiet_time_override !== \"Override/Activity Active\";\n\n    result.manual_control_active =\n        result.manual_override_detected === \"Override/Activity Active\";\n\n    // Overall status assessment\n    result.demand_summary = result.generator_should_run\n        ? \"Generator Requested\"\n        : \"No Generator Demand\";\n\n    if (result.generator_lock === \"Override/Activity Active\") {\n        result.demand_summary = \"Generator Locked\";\n    } else if (result.external_activity_detected === \"Override/Activity Active\") {\n        result.demand_summary = \"External Activity Blocking\";\n    } else if (result.quiet_time_active) {\n        result.demand_summary = \"Quiet Time Active\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.warn(\"Invalid payload: expected object\");\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n    node.warn(\"Invalid data_payload: must be even-length hex string\");\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the GENERATOR_DEMAND_STATUS message\nconst decodedData = decodeGeneratorDemandMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 1000,
        "wires": [
            [
                "51e87f869d6aa2c5"
            ]
        ]
    },
    {
        "id": "51e87f869d6aa2c5",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "GENERATOR_DEMAND_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 1000,
        "wires": []
    },
    {
        "id": "cb64b7a9a87f03cc",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode INVERTER_STATUS",
        "func": "// Status Updater for Inverter\n// Decodes INVERTER_STATUS messages (1FFD4)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === INVERTER_STATUS Specific Decoders ===\n\nfunction decodeInverterInstance(value) {\n    // Inverter instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n    // Inverter operating state mapping\n    const states = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Inverting\",\n        3: \"Charging\",\n        4: \"Passthrough\",\n        5: \"Standby\",\n        6: \"Fault\",\n        7: \"Equalize\",\n        8: \"Bulk Charge\",\n        9: \"Absorption\",\n        10: \"Float\",\n        11: \"Search Mode\",\n        12: \"Sleep Mode\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeInverterCommand(value) {\n    // Inverter command mapping\n    const commands = {\n        0: \"Off\",\n        1: \"On\",\n        2: \"Invert Only\",\n        3: \"Charge Only\",\n        4: \"Auto\",\n        5: \"Search Mode\",\n        6: \"Reset Fault\",\n        7: \"Equalize\",\n        8: \"Shore Power Priority\",\n        9: \"Battery Priority\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeACVoltage(value) {\n    // AC voltage in volts (1V resolution)\n    if (value <= 300) {\n        return value; // Direct voltage value\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeACCurrent(value) {\n    // AC current in amperes (0.1A resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1A per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCVoltage(value) {\n    // DC voltage in volts (0.05V resolution)\n    if (value <= 6400) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05V per step\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65535) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n    // DC current in amperes (0.05A resolution, signed)\n    const MAX_VALID = 2147483600;\n\n    if (value <= MAX_VALID) {\n        // Handle signed values for charging (positive) vs discharging (negative)\n        const signedValue = value > 2147483647 ? value - 4294967296 : value;\n        return parseFloat((signedValue * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 2147483645) {\n        return \"Out of Range\";\n    } else if (value === 2147483646) {\n        return \"Reserved\";\n    } else if (value === 2147483647) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeFrequency(value) {\n    // AC frequency in Hz (0.1Hz resolution)\n    if (value <= 700) {\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1Hz per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset\n    if (value <= 210) {\n        const temp = value - 40; // -40°C to +170°C range\n        if (isCelsius) {\n            return temp;\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"AC Output On\");\n    if (value & 0x02) statusBits.push(\"Charging Active\");\n    if (value & 0x04) statusBits.push(\"AC Input Available\");\n    if (value & 0x08) statusBits.push(\"Overload\");\n    if (value & 0x10) statusBits.push(\"Overtemperature\");\n    if (value & 0x20) statusBits.push(\"Low Battery\");\n    if (value & 0x40) statusBits.push(\"Service Required\");\n    if (value & 0x80) statusBits.push(\"System Fault\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Normal\";\n}\n\nfunction decodeFaultCode(value) {\n    // Fault code mapping\n    const faultCodes = {\n        0: \"No Fault\",\n        1: \"Overload\",\n        2: \"Overvoltage Input\",\n        3: \"Undervoltage Input\",\n        4: \"Overvoltage Output\",\n        5: \"Undervoltage Output\",\n        6: \"Overtemperature\",\n        7: \"Fan Failure\",\n        8: \"Ground Fault\",\n        9: \"DC Ripple\",\n        10: \"AC Frequency Error\",\n        11: \"Internal Fault\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n    if (!data || param.byte >= data.length) {\n        return \"Invalid Data\";\n    }\n\n    const byte = param.byte;\n    let value;\n\n    // Handle multi-byte parameters\n    if (typeof param.byte === 'string' && param.byte.includes('-')) {\n        const [startByte, endByte] = param.byte.split('-').map(Number);\n        value = 0;\n        for (let i = startByte; i <= endByte; i++) {\n            value = (value << 8) | data[i];\n        }\n    } else {\n        value = data[byte];\n    }\n\n    if (param.type === 'uint8') {\n        // Handle specific INVERTER_STATUS parameter types\n        if (param.name === 'instance') {\n            return decodeInverterInstance(value);\n        }\n        if (param.name === 'operating state' || param.name === 'state') {\n            return decodeOperatingState(value);\n        }\n        if (param.name === 'command') {\n            return decodeInverterCommand(value);\n        }\n        if (param.name === 'ac voltage' || param.name.includes('ac') && param.name.includes('voltage')) {\n            return decodeACVoltage(value);\n        }\n        if (param.name === 'frequency') {\n            return decodeFrequency(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n        if (param.name === 'system status' || param.name === 'status') {\n            return decodeSystemStatus(value);\n        }\n        if (param.name === 'fault code') {\n            return decodeFaultCode(value);\n        }\n\n        // Default uint8 handling\n        return value;\n\n    } else if (param.type === 'uint16') {\n        if (param.name === 'ac current' || param.name.includes('ac') && param.name.includes('current')) {\n            return decodeACCurrent(value);\n        }\n        if (param.name === 'dc voltage' || param.name.includes('dc') && param.name.includes('voltage')) {\n            return decodeDCVoltage(value);\n        }\n        if (param.name.includes('temperature')) {\n            return decodeTemperature(value);\n        }\n\n        // Default uint16 handling\n        return value;\n\n    } else if (param.type === 'uint32') {\n        if (param.name === 'dc current' || param.name.includes('dc') && param.name.includes('current')) {\n            return decodeDCCurrent(value);\n        }\n\n        // Default uint32 handling\n        return value;\n\n    } else if (param.type === 'bit2' || param.type.startsWith('uint') && param.bit) {\n        // Handle bit field parameters\n        const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n        if (bitMatch) {\n            const [, startBit, endBit] = bitMatch.map(Number);\n            const bitValue = decodeBits(value, startBit, endBit);\n\n            if (param.values) {\n                return param.values[bitValue.toString()] || bitValue;\n            }\n            return bitValue;\n        }\n    }\n\n    return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeInverterMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"INVERTER_STATUS\"\n    };\n\n    // Decode based on INVERTER_STATUS format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance\n        result.instance = decodeInverterInstance(data[0]);\n\n        // Byte 1: Operating State\n        result.operating_state = decodeOperatingState(data[1]);\n\n        // Byte 2: AC Voltage\n        result.ac_voltage = decodeACVoltage(data[2]);\n\n        // Bytes 3-4: AC Current (16-bit, little-endian)\n        const acCurrent = data[3] | (data[4] << 8);\n        result.ac_current = decodeACCurrent(acCurrent);\n\n        // Bytes 5-6: DC Voltage (16-bit, little-endian)\n        const dcVoltage = data[5] | (data[6] << 8);\n        result.dc_voltage = decodeDCVoltage(dcVoltage);\n\n        // Byte 7: Temperature or Frequency\n        result.temperature = decodeTemperature(data[7]);\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_state = data[1];\n        result.raw_ac_voltage = data[2];\n        result.raw_ac_current_bytes = [data[3], data[4]];\n        result.raw_dc_voltage_bytes = [data[5], data[6]];\n        result.raw_temperature = data[7];\n    }\n\n    // Add convenience fields\n    if (result.operating_state !== undefined) {\n        const state = result.operating_state.toString().toLowerCase();\n        result.inverter_active = state === \"inverting\";\n        result.charger_active = state === \"charging\";\n        result.inverter_available = ![\"fault\", \"error\"].includes(state);\n        result.is_in_fault = state.includes(\"fault\") || state.includes(\"error\");\n        result.is_passthrough = state === \"passthrough\";\n        result.is_in_standby = state === \"standby\" || state === \"search mode\" || state === \"sleep mode\";\n    }\n\n    // Power calculation if voltage and current are available\n    if (typeof result.ac_voltage === 'number' && typeof result.ac_current === 'number') {\n        result.ac_power = parseFloat((result.ac_voltage * result.ac_current).toFixed(2));\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the INVERTER_STATUS message\nconst decodedData = decodeInverterMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1180,
        "wires": [
            [
                "9f3a9fd8a4506e74"
            ]
        ]
    },
    {
        "id": "9f3a9fd8a4506e74",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "INVERTER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1180,
        "wires": []
    },
    {
        "id": "010c5119a7e833b2",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_SOURCE_STATUS_1",
        "func": "// Status Updater for DC Source\n// Decodes DC_SOURCE_STATUS_1/2/3 messages (1FFFD/C/B)\n\n// Decodes a bitfield from within a byte\nfunction decodeBits(byte, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (byte & mask) >> startBit;\n}\n\n// Decodes the DC Instance (Byte 0)\nfunction decodeDCInstance(value) {\n    const dcInstances = {\n        0: \"Invalid\",\n        1: \"Main House Battery Bank\",\n        2: \"Chassis Start Battery\",\n        3: \"Secondary House Battery Bank\",\n        4: \"Generator Starter Battery\",\n    };\n    // Per the spec, 5-250 are valid \"Other\" instances\n    if (value >= 5 && value <= 250) {\n        return `Other DC Instance ${value}`;\n    }\n    return dcInstances[value] || `Unknown DC Instance ${value}`;\n}\n\n// Decodes the Device Priority (Byte 1)\nfunction decodeDevicePriority(value) {\n    const priorities = {\n        20: \"Voltmeter\",\n        40: \"Voltmeter/Ammeter\",\n        60: \"Inverter\",\n        80: \"Charger\",\n        100: \"Inverter/Charger\",\n        120: \"Battery SOC/BMS Device\",\n    };\n    return priorities[value] || `Unknown Priority ${value}`;\n}\n\n// Decodes DC Voltage (uint16)\nfunction decodeDCVoltage(value) {\n    if (value <= 64000) return parseFloat((value * 0.05).toFixed(2));\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes DC Current (32-bit signed)\nfunction decodeDCCurrent32bit(value) {\n    if (value === 4294967295) return \"Not Available\";\n\n    // Convert 32-bit unsigned to signed\n    if (value > 2147483647) {\n        value = value - 4294967296;\n    }\n\n    // The spec does not define the range for current.\n    return parseFloat((value * 0.05).toFixed(2));\n}\n\n// Decodes Temperature (uint16)\nfunction decodeTemperature(value) {\n    // The spec does not define the scaling for this field, assuming offset of -40 C.\n    if (value <= 64000) return value * 0.03125 - 273; // Example scaling\n    if (value === 65535) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// Decodes State of Charge / Health / Relative Capacity (uint8)\nfunction decodePercentage(value) {\n    // 0.5% per step.\n    if (value <= 200) return parseFloat((value * 0.5).toFixed(1));\n    if (value === 255) return \"Not Available\";\n    return \"Invalid\";\n}\n\n// === DGN-Specific Decoders ===\n\nfunction decodeDCSourceStatus1(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_1\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_1\" };\n\n    result.instance = data[0];\n    result.instance_name = decodeDCInstance(data[0]);\n\n    // Validate instance - DC Source valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(\n            `Invalid DC source instance (STATUS_1): ${result.instance} (${result.instance_name}) - message ignored`,\n        );\n        return null;\n    }\n\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const voltage = (data[3] << 8) | data[2];\n    result.dc_voltage_V = decodeDCVoltage(voltage);\n\n    const current = (data[7] << 24) | (data[6] << 16) | (data[5] << 8) | data[4];\n    result.dc_current_A = decodeDCCurrent32bit(current);\n\n    return result;\n}\n\nfunction decodeDCSourceStatus2(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_2\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_2\" };\n\n    result.instance = data[0];\n    result.instance_name = decodeDCInstance(data[0]);\n\n    // Validate instance - DC Source valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(\n            `Invalid DC source instance (STATUS_2): ${result.instance} (${result.instance_name}) - message ignored`,\n        );\n        return null;\n    }\n\n    result.device_priority = decodeDevicePriority(data[1]);\n\n    const temp = (data[3] << 8) | data[2];\n    result.source_temp_C = decodeTemperature(temp);\n\n    result.state_of_charge_percent = decodePercentage(data[4]);\n\n    const time = (data[6] << 8) | data[5];\n    result.time_remaining_min = time <= 64000 ? time : \"Not Available\";\n\n    const interp = decodeBits(data[7], 0, 1);\n    const interpMap = {\n        0: \"Time to Empty\",\n        1: \"Time to Full\",\n        3: \"Not Available\",\n    };\n    result.time_remaining_interpretation = interpMap[interp] || \"Reserved\";\n\n    return result;\n}\n\nfunction decodeDCSourceStatus3(data) {\n    if (data.length < 8) return { error: \"Invalid data length for STATUS_3\" };\n\n    const result = { dgn_name: \"DC_SOURCE_STATUS_3\" };\n\n    result.instance = data[0];\n    result.instance_name = decodeDCInstance(data[0]);\n\n    // Validate instance - DC Source valid instances are 1-250\n    if (result.instance < 1 || result.instance > 250) {\n        node.warn(\n            `Invalid DC source instance (STATUS_3): ${result.instance} (${result.instance_name}) - message ignored`,\n        );\n        return null;\n    }\n\n    result.device_priority = decodeDevicePriority(data[1]);\n    result.state_of_health_percent = decodePercentage(data[2]);\n\n    const cap = (data[4] << 8) | data[3];\n    result.capacity_remaining_Ah = cap <= 64000 ? cap : \"Not Available\";\n\n    result.relative_capacity_percent = decodePercentage(data[5]);\n\n    const ripple = (data[7] << 8) | data[6];\n    result.ac_rms_ripple_mV = ripple <= 65530 ? ripple : \"Not Available\";\n\n    return result;\n}\n\n// === Main Router Function ===\n\nfunction decodeDCSourceMessage(dgn, data) {\n    switch (dgn) {\n        case \"1FFFD\":\n            return decodeDCSourceStatus1(data);\n        case \"1FFFC\":\n            return decodeDCSourceStatus2(data);\n        case \"1FFFB\":\n            return decodeDCSourceStatus3(data);\n        default:\n            return {\n                dgn: dgn,\n                error: `Unsupported DGN for DC_SOURCE_STATUS decoding.`,\n            };\n    }\n}\n\n// === Main Node-RED Logic ===\n\nconst incomingPayload = msg.payload;\nif (!incomingPayload || !incomingPayload.dgn || !incomingPayload.data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Convert hex payload to byte array\nconst dataBytes = [];\nfor (let i = 0; i < incomingPayload.data_payload.length; i += 2) {\n    dataBytes.push(\n        parseInt(incomingPayload.data_payload.substring(i, i + 2), 16),\n    );\n}\n\n// Decode the message by routing to the correct function based on DGN\nconst decodedData = decodeDCSourceMessage(incomingPayload.dgn, dataBytes);\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Merge the original payload and the newly decoded data\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up by removing the raw hex payload\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 400,
        "wires": [
            [
                "bff245b2ca47ef79"
            ]
        ]
    },
    {
        "id": "c38d48059f463772",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AC_LOAD_STATUS",
        "func": "// Status Updater for AC Load\n// Decodes AC_LOAD_STATUS messages (1FFBF)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === AC_LOAD_STATUS Specific Decoders ===\n\nfunction decodeLoadInstance(value) {\n    // Load instance interpretation\n    if (value === 0) {\n        return \"Invalid\";\n    } else if (value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeGroupBitmap(value) {\n    // Group membership bitmap (7 groups max)\n    if (value === 0) {\n        return \"All Groups\";\n    } else if (value === 255) {\n        return \"No Data\";\n    }\n\n    const groups = [];\n    for (let i = 1; i <= 7; i++) {\n        const groupBit = 1 << (i - 1); // Group 1 = bit 0, Group 2 = bit 1, etc.\n        if (!(value & groupBit)) {\n            // Inverted logic - 0 means member\n            groups.push(i);\n        }\n    }\n\n    return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingLevel(value) {\n    // Operating status/level (0-100% for dimmable, or special values)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 252) {\n        return \"Load Delay Active\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\",\n    };\n    return modes[value] || \"Unknown\";\n}\n\nfunction decodeVariableCapability(value) {\n    // Variable level capability (2-bit field)\n    const capabilities = {\n        0: \"Not Variable (Not Dimmable)\",\n        1: \"Variable (Dimmable)\",\n        2: \"Reserved\",\n        3: \"Not Supported\",\n    };\n    return capabilities[value] || \"Unknown\";\n}\n\nfunction decodePriority(value) {\n    // Load priority (4-bit field)\n    if (value <= 13) {\n        return `Priority ${value} (${value === 0 ? \"Highest\" : value === 13 ? \"Lowest\" : \"Medium\"})`;\n    } else if (value === 14) {\n        return \"Error\";\n    } else if (value === 15) {\n        return \"No Data\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeDelay(value) {\n    // Delay before load activation\n    if (value <= 240) {\n        return `${value} seconds`;\n    } else if (value >= 241 && value <= 250) {\n        return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeCurrent(value) {\n    // Current in amperes per Table 5.3 (0.05A resolution for small values)\n    if (value <= 250) {\n        return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeACLoadMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"AC_LOAD_STATUS\",\n    };\n\n    // Determine if this is AC_LOAD_STATUS or AC_LOAD_STATUS_2\n    const dgnHex = dgn.toUpperCase();\n\n    if (dgnHex === \"1FFBF\") {\n        // AC_LOAD_STATUS (standard status)\n        result.status_type = \"AC_LOAD_STATUS\";\n\n        if (data.length >= 8) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Group membership bitmap\n            result.group_membership = decodeGroupBitmap(data[1]);\n\n            // Byte 2: Operating status (level)\n            result.operating_level = decodeOperatingLevel(data[2]);\n\n            // Byte 3: Mode, capability, and priority bits\n            const byte3 = data[3];\n            result.operating_mode = decodeOperatingMode(decodeBits(byte3, 0, 1));\n            result.variable_capability = decodeVariableCapability(\n                decodeBits(byte3, 2, 3),\n            );\n            result.load_priority = decodePriority(decodeBits(byte3, 4, 7));\n\n            // Byte 4: Delay\n            result.activation_delay = decodeDelay(data[4]);\n\n            // Byte 5: Demanded current\n            result.demanded_current = decodeCurrent(data[5]);\n\n            // Bytes 6-7: Present current (uint16, little-endian)\n            const presentCurrentRaw = decodeUint16(data, 6);\n            result.present_current = decodeCurrent(Math.min(presentCurrentRaw, 255)); // Scale down if needed\n\n            // Raw values for debugging\n            result.raw_present_current = presentCurrentRaw;\n            result.raw_control_byte = byte3;\n        }\n    } else if (dgnHex === \"1FEDD\") {\n        // AC_LOAD_STATUS_2 (extended status)\n        result.status_type = \"AC_LOAD_STATUS_2\";\n\n        if (data.length >= 4) {\n            // Byte 0: Instance\n            result.instance = decodeLoadInstance(data[0]);\n\n            // Byte 1: Status bits\n            const byte1 = data[1];\n            const lockStatus = decodeBits(byte1, 0, 1);\n            const overcurrentStatus = decodeBits(byte1, 2, 3);\n            const overrideStatus = decodeBits(byte1, 4, 5);\n            const enableStatus = decodeBits(byte1, 6, 7);\n\n            const statusStates = [\n                \"Normal\",\n                \"Active/Fault\",\n                \"Reserved\",\n                \"Not Supported\",\n            ];\n            result.lock_status =\n                lockStatus === 0 ? \"Unlocked\" : statusStates[lockStatus] || \"Unknown\";\n            result.overcurrent_status = statusStates[overcurrentStatus] || \"Unknown\";\n            result.override_status = statusStates[overrideStatus] || \"Unknown\";\n            result.enable_status =\n                enableStatus === 0\n                    ? \"Enabled\"\n                    : statusStates[enableStatus] || \"Unknown\";\n\n            // Byte 2: Last command\n            result.last_command = data[2]; // Command code - would need command lookup table for name\n\n            // Byte 3: Interlock status\n            if (data.length > 3) {\n                const interlockStatus = decodeBits(data[3], 0, 1);\n                result.interlock_status =\n                    interlockStatus === 0\n                        ? \"Not Active\"\n                        : interlockStatus === 1\n                            ? \"Active\"\n                            : \"Not Supported\";\n            }\n\n            // Raw values for debugging\n            result.raw_status_byte = byte1;\n        }\n    }\n\n    // Add convenience fields\n    if (result.operating_level !== undefined) {\n        result.load_active =\n            typeof result.operating_level === \"number\" && result.operating_level > 0;\n    }\n\n    if (result.variable_capability !== undefined) {\n        result.is_dimmable = result.variable_capability.includes(\"Dimmable\");\n    }\n\n    if (result.operating_mode !== undefined) {\n        result.can_auto_control = result.operating_mode === \"Automatic\";\n    }\n\n    // Load health assessment\n    result.load_healthy = true;\n    if (result.overcurrent_status === \"Active/Fault\") result.load_healthy = false;\n    if (result.enable_status === \"Active/Fault\") result.load_healthy = false;\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.warn(\"Invalid payload: expected object\");\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n    node.warn(\"Invalid data_payload: must be even-length hex string\");\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the AC_LOAD_STATUS message\nconst decodedData = decodeACLoadMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1360,
        "wires": [
            [
                "77e3defd386ce8a8"
            ]
        ]
    },
    {
        "id": "77e3defd386ce8a8",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AC_LOAD_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1360,
        "wires": []
    },
    {
        "id": "a0357de00b26b002",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode ATS_STATUS",
        "func": "// Status Updater for ATS\n// Decodes ATS_STATUS messages (1FF9C)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === ATS_STATUS Specific Decoders ===\n\nfunction decodeATSInstance(value) {\n    // ATS instance interpretation\n    if (value >= 1 && value <= 6) {\n        return value; // Valid instances\n    } else if (value === 0 || value >= 7) {\n        return \"Invalid Instance\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSourceInUse(value) {\n    // Source currently in use\n    if (value === 0) {\n        return \"Primary\";\n    } else if (value >= 1 && value <= 6) {\n        return `Source ${value}`;\n    } else if (value === 253) {\n        return \"No Source Active\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid Source\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode (2-bit field)\n    const modes = {\n        0: \"Automatic\",\n        1: \"Manual\",\n        2: \"Reserved\",\n        3: \"Not Supported\",\n    };\n    return modes[value] || \"Unknown\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeATSMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"ATS_STATUS\",\n    };\n\n    if (data.length >= 3) {\n        // Byte 0: ATS Instance\n        result.instance = decodeATSInstance(data[0]);\n\n        // Byte 1: Source in use\n        result.source_in_use = decodeSourceInUse(data[1]);\n\n        // Byte 2: Operating mode (bits 0-1)\n        const byte2 = data[2];\n        result.operating_mode = decodeOperatingMode(decodeBits(byte2, 0, 1));\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_source = data[1];\n        result.raw_mode_byte = byte2;\n    }\n\n    // Add convenience fields\n    result.has_active_source =\n        result.source_in_use !== \"No Source Active\" &&\n        result.source_in_use !== \"Not Available\" &&\n        !result.source_in_use.includes(\"Invalid\");\n\n    result.is_automatic_mode = result.operating_mode === \"Automatic\";\n    result.is_manual_mode = result.operating_mode === \"Manual\";\n\n    result.using_primary_source = result.source_in_use === \"Primary\";\n\n    // Overall status assessment\n    if (result.has_active_source) {\n        result.transfer_switch_status = `Active on ${result.source_in_use}`;\n    } else {\n        result.transfer_switch_status = \"No Active Source\";\n    }\n\n    if (result.operating_mode === \"Manual\") {\n        result.transfer_switch_status += \" (Manual Mode)\";\n    } else if (result.operating_mode === \"Automatic\") {\n        result.transfer_switch_status += \" (Automatic Mode)\";\n    }\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.warn(\"Invalid payload: expected object\");\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn(\"Missing required fields: dgn and/or data_payload\");\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n    node.warn(\"Invalid data_payload: must be even-length hex string\");\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the ATS_STATUS message\nconst decodedData = decodeATSMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 1420,
        "wires": [
            [
                "fa30f6cf9bede7e9"
            ]
        ]
    },
    {
        "id": "fa30f6cf9bede7e9",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "ATS_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1420,
        "wires": []
    },
    {
        "id": "4a6d57460d64c76f",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode DC_DIMMER_STATUS_3",
        "func": "// Status Updater for DC Dimmer\n// Decodes DC_DIMMER_STATUS_1/2/3 messages (1FFBB, 1FFBA, 1FEDA)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n  const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n  return (value & mask) >> startBit;\n}\n\n// === DC_DIMMER_STATUS Specific Decoders ===\n\nfunction decodeDimmerInstance(value) {\n  // Dimmer instance interpretation\n  if (value === 0) {\n    return \"Invalid\";\n  } else if (value <= 250) {\n    return value; // Direct instance number\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeBrightnessLevel(value) {\n  // Brightness level (0-200% per Table 5.3)\n  if (value <= 200) {\n    return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n  } else if (value === 251) {\n    return \"Value Changing (Ramp)\";\n  } else if (value === 252) {\n    return \"Output Flashing\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeDCCurrent(value) {\n  // DC Current per Table 5.3 (0.05A resolution for small currents)\n  if (value <= 250) {\n    return parseFloat((value * 0.05).toFixed(2)); // 0.05A per step\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeChannelFault(value) {\n  // Channel fault status (2-bit field)\n  const faultStates = {\n    0: \"No Fault\",\n    1: \"Undercurrent (Open Circuit)\",\n    2: \"Overcurrent\",\n    3: \"Reserved\",\n  };\n  return faultStates[value] || \"Unknown\";\n}\n\nfunction decodeFaultByte(value) {\n  // Decode fault bits from byte 5 (STATUS_2)\n  const masterFault = decodeBits(value, 0, 1);\n  const redFault = decodeBits(value, 2, 3);\n  const greenFault = decodeBits(value, 4, 5);\n  const blueFault = decodeBits(value, 6, 7);\n\n  const faults = [];\n  if (masterFault > 0)\n    faults.push(`Master: ${decodeChannelFault(masterFault)}`);\n  if (redFault > 0) faults.push(`Red: ${decodeChannelFault(redFault)}`);\n  if (greenFault > 0) faults.push(`Green: ${decodeChannelFault(greenFault)}`);\n  if (blueFault > 0) faults.push(`Blue: ${decodeChannelFault(blueFault)}`);\n\n  return {\n    fault_summary: faults.length > 0 ? faults.join(\", \") : \"No Faults\",\n    master_fault: decodeChannelFault(masterFault),\n    red_fault: decodeChannelFault(redFault),\n    green_fault: decodeChannelFault(greenFault),\n    blue_fault: decodeChannelFault(blueFault),\n    any_fault: faults.length > 0,\n  };\n}\n\nfunction decodeGroupBitmap(value) {\n  // Group membership bitmap (7 groups max)\n  if (value === 0) {\n    return \"All Groups\";\n  } else if (value === 255) {\n    return \"No Data\";\n  }\n\n  const groups = [];\n  for (let i = 1; i <= 7; i++) {\n    const groupBit = 1 << i;\n    if (!(value & groupBit)) {\n      // Inverted logic - 0 means member\n      groups.push(i);\n    }\n  }\n\n  return groups.length > 0 ? `Groups: ${groups.join(\", \")}` : \"No Groups\";\n}\n\nfunction decodeOperatingStatus(value) {\n  // Operating status for STATUS_3\n  if (value <= 200) {\n    return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step\n  } else if (value === 251) {\n    return \"Value Changing (Ramp)\";\n  } else if (value === 252) {\n    return \"Output Flashing\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeStatus3Byte3(value) {\n  // Decode status bits from byte 3 (STATUS_3)\n  const lockStatus = decodeBits(value, 0, 1);\n  const overcurrentStatus = decodeBits(value, 2, 3);\n  const overrideStatus = decodeBits(value, 4, 5);\n  const enableStatus = decodeBits(value, 6, 7);\n\n  const lockStates = [\"Unlocked\", \"Locked\", \"Reserved\", \"Not Supported\"];\n  const statusStates = [\n    \"Normal/Inactive\",\n    \"Active/Abnormal\",\n    \"Reserved\",\n    \"Not Supported\",\n  ];\n  const enableStates = [\"Enabled\", \"Disabled\", \"Reserved\", \"Not Supported\"];\n\n  return {\n    lock_status: lockStates[lockStatus] || \"Unknown\",\n    overcurrent_status: statusStates[overcurrentStatus] || \"Unknown\",\n    override_status: statusStates[overrideStatus] || \"Unknown\",\n    enable_status: enableStates[enableStatus] || \"Unknown\",\n  };\n}\n\nfunction decodeLastCommand(value) {\n  // Last executed command (STATUS_3)\n  const commands = {\n    0: \"Set Brightness\",\n    1: \"ON\",\n    2: \"ON Delay\",\n    3: \"OFF\",\n    4: \"Stop\",\n    5: \"Toggle\",\n    6: \"Memory OFF\",\n    7: \"Save Scene\",\n    11: \"Ramp Brightness\",\n    12: \"Ramp Toggle\",\n    13: \"Ramp Up\",\n    14: \"Ramp Down\",\n    15: \"Ramp Up/Down\",\n    16: \"Ramp Up/Down Toggle\",\n    21: \"Lock\",\n    22: \"Unlock\",\n    31: \"Flash\",\n    32: \"Flash Momentary\",\n    33: \"Flash Pattern\",\n    34: \"Scene Recall\",\n    35: \"Scene Store\",\n    36: \"Group Command\",\n    37: \"Reset\",\n    38: \"Factory Reset\",\n    39: \"Calibrate\",\n    40: \"Test Mode\",\n    251: \"Error\",\n    252: \"Not Supported\",\n    253: \"Out of Range\",\n    254: \"Reserved\",\n    255: \"Not Available\",\n  };\n\n  return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeDelayDuration(value) {\n  // Delay/Duration field (STATUS_3)\n  if (value === 0) {\n    return \"Expired\";\n  } else if (value <= 240) {\n    return `${value} seconds`;\n  } else if (value >= 241 && value <= 250) {\n    return `${value - 236} minutes`; // 241-250 = 5-14 minutes\n  } else if (value === 252) {\n    return \"Flashing\";\n  } else if (value === 253) {\n    return \">240 seconds\";\n  } else if (value === 255) {\n    return \"No delay active\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeStatus3Byte6(value) {\n  // Decode status bits from byte 6 (STATUS_3)\n  const interlockStatus = decodeBits(value, 0, 1);\n  const loadStatus = decodeBits(value, 2, 3);\n  const undercurrentStatus = decodeBits(value, 6, 7);\n\n  const interlockStates = [\"Not Active\", \"Active\", \"Reserved\", \"Not Supported\"];\n  const loadStates = [\n    \"Off (status=0)\",\n    \"On (status>0 or flashing)\",\n    \"Reserved\",\n    \"Reserved\",\n  ];\n  const undercurrentStates = [\n    \"Normal\",\n    \"Active\",\n    \"Timeout Error\",\n    \"Not Supported\",\n  ];\n\n  return {\n    interlock_status: interlockStates[interlockStatus] || \"Unknown\",\n    load_status: loadStates[loadStatus] || \"Unknown\",\n    undercurrent_status: undercurrentStates[undercurrentStatus] || \"Unknown\",\n  };\n}\n\nfunction decodeUint16(data, startByte) {\n  // Decode 16-bit value (little-endian)\n  if (!data || startByte + 1 >= data.length) {\n    return 65535; // Not available\n  }\n  return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeDCDimmerMessage(dgn, data) {\n  // Map DGN hex codes to specific names for unified routing\n  let dgn_name = \"DC_DIMMER_STATUS\"; // fallback\n  const dgnHex = dgn.toUpperCase();\n  if (dgnHex === \"1FFBB\") {\n    dgn_name = \"DC_DIMMER_STATUS_1\";\n  } else if (dgnHex === \"1FFBA\") {\n    dgn_name = \"DC_DIMMER_STATUS_2\";\n  } else if (dgnHex === \"1FEDA\") {\n    dgn_name = \"DC_DIMMER_STATUS_3\";\n  }\n\n  const result = {\n    dgn: dgn,\n    dgn_name: dgn_name,\n  };\n\n  // Determine which STATUS message based on DGN and decode accordingly\n\n  if (dgnHex === \"1FFBB\") {\n    // DC_DIMMER_STATUS_1 - Brightness levels and timing\n    result.status_type = \"STATUS_1\";\n\n    if (data.length >= 7) {\n      result.instance = data[0];\n      result.instance_name = decodeDimmerInstance(data[0]);\n      result.master_brightness = decodeBrightnessLevel(data[1]);\n      result.red_brightness = decodeBrightnessLevel(data[2]);\n      result.green_brightness = decodeBrightnessLevel(data[3]);\n      result.blue_brightness = decodeBrightnessLevel(data[4]);\n\n      // Byte 5: On/Off Duration (4 bits each)\n      result.on_duration = decodeBits(data[5], 0, 3); // 0-14 seconds\n      result.off_duration = decodeBits(data[5], 4, 7); // 0-14 seconds\n\n      if (data.length > 6) {\n        result.white_brightness = decodeBrightnessLevel(data[6]);\n      }\n    }\n  } else if (dgnHex === \"1FFBA\") {\n    // DC_DIMMER_STATUS_2 - Current measurements and faults\n    result.status_type = \"STATUS_2\";\n\n    if (data.length >= 8) {\n      result.instance = data[0];\n      result.instance_name = decodeDimmerInstance(data[0]);\n      result.red_current = decodeDCCurrent(data[2]);\n      result.green_current = decodeDCCurrent(data[3]);\n      result.blue_current = decodeDCCurrent(data[4]);\n\n      // Byte 5: Fault bits\n      const faultInfo = decodeFaultByte(data[5]);\n      Object.assign(result, faultInfo);\n\n      if (data.length > 6) {\n        result.white_current = decodeDCCurrent(data[6]);\n      }\n\n      if (data.length > 7) {\n        // Byte 7: White fault (bits 0-1)\n        const whiteFault = decodeBits(data[7], 0, 1);\n        result.white_fault = decodeChannelFault(whiteFault);\n      }\n    }\n  } else if (dgnHex === \"1FEDA\") {\n    // DC_DIMMER_STATUS_3 - Comprehensive operational status\n    result.status_type = \"STATUS_3\";\n\n    if (data.length >= 8) {\n      result.instance = data[0];\n      result.instance_name = decodeDimmerInstance(data[0]);\n      result.group_membership = decodeGroupBitmap(data[1]);\n      result.operating_status = decodeOperatingStatus(data[2]);\n\n      // Byte 3: Status bits\n      const status3Info = decodeStatus3Byte3(data[3]);\n      Object.assign(result, status3Info);\n\n      result.delay_duration = decodeDelayDuration(data[4]);\n      result.last_command = decodeLastCommand(data[5]);\n\n      // Byte 6: More status bits\n      const status6Info = decodeStatus3Byte6(data[6]);\n      Object.assign(result, status6Info);\n\n      result.master_memory_value = decodeBrightnessLevel(data[7]);\n    }\n  }\n\n  // Validate instance - DC Dimmer valid instances are 1-250\n  if (result.instance < 1 || result.instance > 250) {\n    node.warn(\n      `Invalid DC dimmer instance: ${result.instance} (${result.instance_name}) - message ignored`,\n    );\n    return null;\n  }\n\n  // Add convenience fields\n  if (result.master_brightness !== undefined) {\n    result.dimmer_on =\n      typeof result.master_brightness === \"number\" &&\n      result.master_brightness > 0;\n  }\n\n  if (result.operating_status !== undefined) {\n    result.dimmer_active =\n      typeof result.operating_status === \"number\" &&\n      result.operating_status > 0;\n  }\n\n  if (result.any_fault !== undefined) {\n    result.dimmer_healthy = !result.any_fault;\n  }\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the DC_DIMMER_STATUS message\nconst decodedData = decodeDCDimmerMessage(dgn, dataBytes);\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n  return null;\n}\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 160,
        "wires": [
            [
                "7af7fb2178a714cf"
            ]
        ]
    },
    {
        "id": "d76a4a48e1beaed6",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode FURNACE_STATUS",
        "func": "// Status Updater for Furnace\n// Decodes FURNACE_STATUS messages (1FFDE)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n  const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n  return (value & mask) >> startBit;\n}\n\n// === FURNACE_STATUS Specific Decoders ===\n\nfunction decodeFurnaceInstance(value) {\n  // Furnace instance mapping\n  if (value <= 200) {\n    return value; // Direct instance number\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeOperatingState(value) {\n  // Furnace operating state mapping\n  const states = {\n    0: \"Off\",\n    1: \"Starting\",\n    2: \"Pre-Purge\",\n    3: \"Ignition\",\n    4: \"Flame Established\",\n    5: \"Running\",\n    6: \"Post-Purge\",\n    7: \"Shutdown\",\n    8: \"Lockout\",\n    9: \"Fault\",\n    10: \"Safety Check\",\n    11: \"Cool Down\",\n    251: \"Error\",\n    252: \"Not Supported\",\n    253: \"Out of Range\",\n    254: \"Reserved\",\n    255: \"Not Available\",\n  };\n\n  return states[value] || `Unknown State ${value}`;\n}\n\nfunction decodeFurnaceCommand(value) {\n  // Furnace command mapping\n  const commands = {\n    0: \"Stop\",\n    1: \"Start\",\n    2: \"Reset Fault\",\n    3: \"Test\",\n    4: \"Service Mode\",\n    251: \"Error\",\n    252: \"Not Supported\",\n    253: \"Out of Range\",\n    254: \"Reserved\",\n    255: \"Not Available\",\n  };\n\n  return commands[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeFuelType(value) {\n  // Fuel type mapping\n  const fuelTypes = {\n    0: \"Unknown\",\n    1: \"Propane\",\n    2: \"Diesel\",\n    3: \"Gasoline\",\n    4: \"Natural Gas\",\n    5: \"Electric\",\n    251: \"Error\",\n    252: \"Not Supported\",\n    253: \"Out of Range\",\n    254: \"Reserved\",\n    255: \"Not Available\",\n  };\n\n  return fuelTypes[value] || `Unknown Fuel ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n  // Temperature decoding with offset\n  if (value <= 210) {\n    const temp = value - 40; // -40°C to +170°C range\n    if (isCelsius) {\n      return temp;\n    } else {\n      // Convert to Fahrenheit: F = C * 9/5 + 32\n      return parseFloat(((temp * 9) / 5 + 32).toFixed(1));\n    }\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeFanSpeed(value) {\n  // Fan speed as percentage\n  if (value <= 200) {\n    return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeAirFlow(value) {\n  // Air flow in CFM (Cubic Feet per Minute)\n  if (value <= 65000) {\n    return value; // Direct CFM value\n  } else if (value === 65533) {\n    return \"Out of Range\";\n  } else if (value === 65534) {\n    return \"Reserved\";\n  } else if (value === 65535) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeFaultCode(value) {\n  // Fault code mapping\n  const faultCodes = {\n    0: \"No Fault\",\n    1: \"Ignition Failure\",\n    2: \"Flame Loss\",\n    3: \"High Temperature\",\n    4: \"Low Gas Pressure\",\n    5: \"High Gas Pressure\",\n    6: \"Fan Failure\",\n    7: \"Igniter Failure\",\n    8: \"Flame Sensor Failure\",\n    9: \"Control Board Fault\",\n    10: \"Safety Lockout\",\n    11: \"Overheat\",\n    12: \"Airflow Problem\",\n    251: \"Error\",\n    252: \"Not Supported\",\n    253: \"Out of Range\",\n    254: \"Reserved\",\n    255: \"Not Available\",\n  };\n\n  return faultCodes[value] || `Unknown Fault ${value}`;\n}\n\nfunction decodeSystemStatus(value) {\n  // System status bit field\n  const statusBits = [];\n\n  if (value & 0x01) statusBits.push(\"Flame Present\");\n  if (value & 0x02) statusBits.push(\"Igniter On\");\n  if (value & 0x04) statusBits.push(\"Gas Valve Open\");\n  if (value & 0x08) statusBits.push(\"Fan Running\");\n  if (value & 0x10) statusBits.push(\"Safety Circuit OK\");\n  if (value & 0x20) statusBits.push(\"High Limit OK\");\n  if (value & 0x40) statusBits.push(\"Service Required\");\n  if (value & 0x80) statusBits.push(\"System Fault\");\n\n  return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\n// === Parameter Decoder ===\n\nfunction decodeParameter(param, data) {\n  if (!data || param.byte >= data.length) {\n    return \"Invalid Data\";\n  }\n\n  const byte = param.byte;\n  let value;\n\n  // Handle multi-byte parameters\n  if (typeof param.byte === \"string\" && param.byte.includes(\"-\")) {\n    const [startByte, endByte] = param.byte.split(\"-\").map(Number);\n    value = 0;\n    for (let i = startByte; i <= endByte; i++) {\n      value = (value << 8) | data[i];\n    }\n  } else {\n    value = data[byte];\n  }\n\n  if (param.type === \"uint8\") {\n    // Handle specific FURNACE_STATUS parameter types\n    if (param.name === \"instance\") {\n      return decodeFurnaceInstance(value);\n    }\n    if (param.name === \"operating state\" || param.name === \"state\") {\n      return decodeOperatingState(value);\n    }\n    if (param.name === \"command\") {\n      return decodeFurnaceCommand(value);\n    }\n    if (param.name === \"fuel type\") {\n      return decodeFuelType(value);\n    }\n    if (param.name.includes(\"temperature\")) {\n      return decodeTemperature(value);\n    }\n    if (param.name === \"fan speed\") {\n      return decodeFanSpeed(value);\n    }\n    if (param.name === \"fault code\") {\n      return decodeFaultCode(value);\n    }\n    if (param.name === \"system status\" || param.name === \"status\") {\n      return decodeSystemStatus(value);\n    }\n\n    // Default uint8 handling\n    return value;\n  } else if (param.type === \"uint16\") {\n    if (param.name === \"air flow\" || param.name.includes(\"flow\")) {\n      return decodeAirFlow(value);\n    }\n    if (param.name.includes(\"temperature\")) {\n      return decodeTemperature(value);\n    }\n\n    // Default uint16 handling\n    return value;\n  } else if (\n    param.type === \"bit2\" ||\n    (param.type.startsWith(\"uint\") && param.bit)\n  ) {\n    // Handle bit field parameters\n    const bitMatch = param.bit.match(/(\\d+)-(\\d+)/);\n    if (bitMatch) {\n      const [, startBit, endBit] = bitMatch.map(Number);\n      const bitValue = decodeBits(value, startBit, endBit);\n\n      if (param.values) {\n        return param.values[bitValue.toString()] || bitValue;\n      }\n      return bitValue;\n    }\n  }\n\n  return value;\n}\n\n// === Main Decode Function ===\n\nfunction decodeFurnaceMessage(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"FURNACE_STATUS\",\n  };\n\n  // Decode based on FURNACE_STATUS format (8 bytes typical)\n  if (data.length >= 8) {\n    // Byte 0: Instance\n    result.instance = decodeFurnaceInstance(data[0]);\n\n    // Byte 1: Operating State\n    result.operating_state = decodeOperatingState(data[1]);\n\n    // Byte 2: Fuel Type\n    result.fuel_type = decodeFuelType(data[2]);\n\n    // Byte 3: Exhaust Temperature\n    result.exhaust_temperature = decodeTemperature(data[3]);\n\n    // Byte 4: Intake Temperature\n    result.intake_temperature = decodeTemperature(data[4]);\n\n    // Byte 5: Fan Speed\n    result.fan_speed = decodeFanSpeed(data[5]);\n\n    // Bytes 6-7: Air Flow (16-bit, little-endian)\n    const airFlow = data[6] | (data[7] << 8);\n    result.air_flow = decodeAirFlow(airFlow);\n\n    // Raw values for debugging\n    result.raw_instance = data[0];\n    result.raw_operating_state = data[1];\n    result.raw_fuel_type = data[2];\n    result.raw_exhaust_temperature = data[3];\n    result.raw_intake_temperature = data[4];\n    result.raw_fan_speed = data[5];\n    result.raw_air_flow_bytes = [data[6], data[7]];\n  }\n\n  // Add convenience fields\n  if (result.operating_state !== undefined) {\n    const state = result.operating_state.toString().toLowerCase();\n    result.furnace_running = state === \"running\";\n    result.furnace_heating = [\"flame established\", \"running\"].includes(state);\n    result.furnace_available = ![\"fault\", \"lockout\", \"error\"].includes(state);\n    result.is_in_fault =\n      state.includes(\"fault\") ||\n      state.includes(\"lockout\") ||\n      state.includes(\"error\");\n    result.is_starting = [\"starting\", \"pre-purge\", \"ignition\"].includes(state);\n    result.is_shutting_down = [\"post-purge\", \"shutdown\", \"cool down\"].includes(\n      state,\n    );\n  }\n\n  // Temperature status\n  result.exhaust_temp_available =\n    typeof result.exhaust_temperature === \"number\";\n  result.intake_temp_available = typeof result.intake_temperature === \"number\";\n\n  // Fan status\n  result.fan_running =\n    typeof result.fan_speed === \"number\" && result.fan_speed > 0;\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the FURNACE_STATUS message\nconst decodedData = decodeFurnaceMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 820,
        "wires": [
            [
                "9d90b7163a12d5ed"
            ]
        ]
    },
    {
        "id": "9d90b7163a12d5ed",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "FURNACE_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 820,
        "wires": []
    },
    {
        "id": "fbc5efde2c447eda",
        "type": "link in",
        "z": "3e5f038a4f5a8b9a",
        "name": "STATUS in",
        "links": [
            "02bdfc59de71b5a5"
        ],
        "x": 240,
        "y": 780,
        "wires": [
            [
                "9f88f215f3f07227"
            ]
        ],
        "l": true
    },
    {
        "id": "ffd5bc5ca5695602",
        "type": "inject",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 880,
        "y": 2000,
        "wires": [
            [
                "09640adb1fd08fbb"
            ]
        ]
    },
    {
        "id": "09640adb1fd08fbb",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Reset function",
        "func": "flow.set(\"uniqueDecodedStatus\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 2000,
        "wires": [
            []
        ]
    },
    {
        "id": "b797e5a52b6db5b4",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "Unique STATUS",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDecodedStatus = flow.get(\"uniqueDecodedStatus\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgnName);\n\n// Check if it's a new unique message\nif (!uniqueDecodedStatus.includes(newMsgStr)) {\n    uniqueDecodedStatus.push(newMsgStr);\n    flow.set(\"uniqueDecodedStatus\", uniqueDecodedStatus);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 2060,
        "wires": [
            [
                "48e6dda2b2d9575e"
            ]
        ]
    },
    {
        "id": "48e6dda2b2d9575e",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "g": "eb51c1f2d0d389d1",
        "name": "New Unique Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1110,
        "y": 2060,
        "wires": []
    },
    {
        "id": "d0e2cc417cf65b90",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "THERMOSTAT_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 640,
        "wires": []
    },
    {
        "id": "ccec30ad0f32bbdf",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode THERMOSTAT_STATUS_1",
        "func": "// Status Updater for Thermostat\n// Decodes THERMOSTAT_STATUS_1 messages (1FEE1)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === THERMOSTAT_STATUS_1 Specific Decoders ===\n\nfunction decodeThermostatInstance(value) {\n    // Thermostat instance mapping\n    if (value <= 200) {\n        return value; // Direct instance number (Zone)\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeOperatingMode(value) {\n    // Operating mode mapping (extended)\n    const modes = {\n        0: \"Off\",\n        1: \"Auto\",\n        2: \"Heat\",\n        3: \"Cool\",\n        4: \"Furnace\",\n        5: \"Fan Only\",\n        6: \"Dry\",\n        7: \"Emergency Heat\",\n        8: \"Heat Pump\",\n        9: \"Defrost\",\n        10: \"Aux Heat\",\n        11: \"Eco Mode\",\n        12: \"Sleep Mode\",\n        13: \"Away Mode\",\n        14: \"Manual Override\",\n        15: \"Vacation Mode\",\n        16: \"Schedule Mode\",\n        17: \"Temperature Hold\",\n        18: \"Energy Save\",\n        19: \"Quick Heat\",\n        20: \"Quick Cool\",\n        21: \"System Test\",\n        22: \"Calibration\",\n        23: \"Service Mode\",\n        24: \"Installation Mode\",\n        25: \"Demo Mode\",\n        26: \"Lock Mode\",\n        27: \"Filter Mode\",\n        28: \"Humidity Control\",\n        29: \"Dehumidify\",\n        30: \"Humidify\",\n        31: \"Air Quality Mode\",\n        32: \"Zone Control\",\n        33: \"Multi-Stage Heat\",\n        34: \"Multi-Stage Cool\",\n        35: \"Heat Recovery\",\n        36: \"Ventilation Mode\",\n        37: \"Fresh Air Mode\",\n        38: \"Recirculate Mode\",\n        39: \"Purge Mode\",\n        40: \"Startup Mode\",\n        41: \"Shutdown Mode\",\n        42: \"Fault Recovery\",\n        43: \"Performance Test\",\n        44: \"Efficiency Mode\",\n        45: \"Comfort Mode\",\n        46: \"Advanced Auto\",\n        47: \"Smart Mode\",\n        48: \"Remote Control\",\n        49: \"Mobile App Control\",\n        50: \"Voice Control\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return modes[value] || `Unknown Mode ${value}`;\n}\n\nfunction decodeFanMode(value) {\n    // Fan mode mapping\n    const fanModes = {\n        0: \"Auto\",\n        1: \"On\",\n        2: \"Low\",\n        3: \"Medium\",\n        4: \"High\",\n        5: \"Variable\",\n        251: \"Error\",\n        252: \"Not Supported\",\n        253: \"Out of Range\",\n        254: \"Reserved\",\n        255: \"Not Available\"\n    };\n\n    return fanModes[value] || `Unknown Fan Mode ${value}`;\n}\n\nfunction decodeTemperature(value, isCelsius = false) {\n    // Temperature decoding with offset (-40°C to +170°C range)\n    if (value <= 210) {\n        const temp = value - 40; // Offset by 40 degrees\n        if (isCelsius) {\n            return parseFloat(temp.toFixed(1));\n        } else {\n            // Convert to Fahrenheit: F = C * 9/5 + 32\n            return parseFloat(((temp * 9 / 5) + 32).toFixed(1));\n        }\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeSystemStatus(value) {\n    // System status bit field\n    if (value === 255) {\n        return \"Not Available\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    }\n\n    const statusBits = [];\n\n    if (value & 0x01) statusBits.push(\"Heating Active\");\n    if (value & 0x02) statusBits.push(\"Cooling Active\");\n    if (value & 0x04) statusBits.push(\"Fan Running\");\n    if (value & 0x08) statusBits.push(\"Aux Heat Active\");\n    if (value & 0x10) statusBits.push(\"Defrost Active\");\n    if (value & 0x20) statusBits.push(\"System Fault\");\n    if (value & 0x40) statusBits.push(\"Filter Change Required\");\n    if (value & 0x80) statusBits.push(\"Service Required\");\n\n    return statusBits.length > 0 ? statusBits.join(\", \") : \"Standby\";\n}\n\nfunction decodeFanSpeed(value) {\n    // Fan speed as percentage (0-100%)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeThermostatStatus1Message(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"THERMOSTAT_STATUS_1\"\n    };\n\n    // Decode based on THERMOSTAT_STATUS_1 format (8 bytes typical)\n    if (data.length >= 8) {\n        // Byte 0: Instance (Zone)\n        result.instance = decodeThermostatInstance(data[0]);\n\n        // Byte 1: Operating Mode\n        result.operating_mode = decodeOperatingMode(data[1]);\n\n        // Byte 2: Fan Mode\n        result.fan_mode = decodeFanMode(data[2]);\n\n        // Byte 3: Set Point Temperature\n        result.set_point_temperature = decodeTemperature(data[3]);\n\n        // Byte 4: Ambient Temperature\n        result.ambient_temperature = decodeTemperature(data[4]);\n\n        // Byte 5: System Status\n        result.system_status = decodeSystemStatus(data[5]);\n\n        // Byte 6: Fan Speed\n        result.fan_speed = decodeFanSpeed(data[6]);\n\n        // Byte 7: Reserved/Future use\n        // Typically 0xFF in current implementations\n\n        // Raw values for debugging\n        result.raw_instance = data[0];\n        result.raw_operating_mode = data[1];\n        result.raw_fan_mode = data[2];\n        result.raw_set_point_temperature = data[3];\n        result.raw_ambient_temperature = data[4];\n        result.raw_system_status = data[5];\n        result.raw_fan_speed = data[6];\n        if (data.length > 7) result.raw_byte_7 = data[7];\n    }\n\n    // Add convenience fields\n    result.thermostat_available = result.instance !== \"Not Available\" &&\n        result.operating_mode !== \"Not Available\";\n\n    result.temperature_available = typeof result.ambient_temperature === 'number' &&\n        typeof result.set_point_temperature === 'number';\n\n    // Calculate temperature difference if both temps available\n    if (result.temperature_available) {\n        result.temperature_difference = parseFloat((result.ambient_temperature - result.set_point_temperature).toFixed(1));\n        result.needs_heating = result.temperature_difference < -1; // More than 1°F below setpoint\n        result.needs_cooling = result.temperature_difference > 1;  // More than 1°F above setpoint\n    }\n\n    // System operating status\n    if (typeof result.system_status === 'string' && result.system_status !== \"Not Available\") {\n        result.heating_active = result.system_status.includes(\"Heating Active\");\n        result.cooling_active = result.system_status.includes(\"Cooling Active\");\n        result.fan_running = result.system_status.includes(\"Fan Running\");\n        result.aux_heat_active = result.system_status.includes(\"Aux Heat Active\");\n        result.defrost_active = result.system_status.includes(\"Defrost Active\");\n        result.system_fault = result.system_status.includes(\"System Fault\");\n        result.filter_change_required = result.system_status.includes(\"Filter Change Required\");\n        result.service_required = result.system_status.includes(\"Service Required\");\n        result.system_active = result.heating_active || result.cooling_active || result.defrost_active;\n    } else {\n        result.heating_active = false;\n        result.cooling_active = false;\n        result.fan_running = false;\n        result.aux_heat_active = false;\n        result.defrost_active = false;\n        result.system_fault = false;\n        result.filter_change_required = false;\n        result.service_required = false;\n        result.system_active = false;\n    }\n\n    // Operating mode status\n    result.is_off = result.operating_mode === \"Off\";\n    result.is_auto_mode = result.operating_mode === \"Auto\";\n    result.is_heating_mode = result.operating_mode === \"Heat\" || result.operating_mode === \"Furnace\" ||\n        result.operating_mode === \"Heat Pump\" || result.operating_mode === \"Emergency Heat\";\n    result.is_cooling_mode = result.operating_mode === \"Cool\";\n\n    // Fan status\n    result.fan_auto_mode = result.fan_mode === \"Auto\";\n    result.fan_on_mode = result.fan_mode === \"On\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the THERMOSTAT_STATUS_1 message\nconst decodedData = decodeThermostatStatus1Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 640,
        "wires": [
            [
                "d0e2cc417cf65b90"
            ]
        ]
    },
    {
        "id": "45ae070eafc9a732",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "TANK_STATUS",
        "mode": "link",
        "links": [
            "61f4573c56915577"
        ],
        "x": 1300,
        "y": 340,
        "wires": [],
        "l": true
    },
    {
        "id": "bff245b2ca47ef79",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_SOURCE_STATUS_1",
        "mode": "link",
        "links": [
            "663120adc5ec254f"
        ],
        "x": 1340,
        "y": 400,
        "wires": [],
        "l": true
    },
    {
        "id": "7af7fb2178a714cf",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_3",
        "mode": "link",
        "links": [
            "7313d7c724d31538"
        ],
        "x": 1330,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "0ecfccb41b17f21b",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "SOLAR_EQUALIZATION_CONFIGURATION_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 1540,
        "wires": []
    },
    {
        "id": "1b079a5b225e1552",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1600,
        "wires": []
    },
    {
        "id": "f945d56c437bfb38",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_DIMMER_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1660,
        "wires": []
    },
    {
        "id": "3b2f348b9326267c",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WINDOW_SHADE_CONTROL_STATUS",
        "func": "// Status Updater for Window Shade\n// Decodes WINDOW_SHADE_CONTROL_STATUS messages (1FEDE)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n  const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n  return (value & mask) >> startBit;\n}\n\n// === WINDOW_SHADE_CONTROL_STATUS Specific Decoders ===\n\nfunction decodeInstance(value) {\n  // Window shade instance mapping\n  if (value >= 1 && value <= 250) {\n    return value; // Direct instance number\n  } else if (value === 0) {\n    return \"All Instances\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeGroupDetails(value) {\n  // Group membership bitmap decoding\n  if (value === 0xff) {\n    return { type: \"special\", description: \"No data\" };\n  }\n  if (value === 0x00) {\n    return { type: \"special\", description: \"Member of all groups\" };\n  }\n\n  const groups = [];\n  for (let bit = 0; bit < 7; bit++) {\n    if (!(value & (1 << bit))) {\n      groups.push(bit + 1);\n    }\n  }\n\n  if (groups.length > 0) {\n    return {\n      type: \"standard\",\n      groups: groups,\n      description: `Groups: ${groups.join(\", \")}`,\n    };\n  } else {\n    return {\n      type: \"standard\",\n      groups: [],\n      description: \"No group membership\",\n    };\n  }\n}\n\nfunction decodeOperatingStatus(value) {\n  // Operating status (motor duty) as percentage per Table 5.3\n  if (value <= 200) {\n    return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n  } else if (value === 251) {\n    return \"Value Changing\";\n  } else if (value === 252) {\n    return \"Output Flashing\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeLockStatus(value) {\n  // Lock status (bits 0-1)\n  const lockMap = {\n    0: \"Load is unlocked\",\n    1: \"Load is locked\",\n    3: \"Lock command not supported\",\n  };\n  return lockMap[value] || `Unknown Lock Status ${value}`;\n}\n\nfunction decodeMotorStatus(value) {\n  // Motor status (bits 2-3)\n  const motorMap = {\n    0: \"Neither 'Forward' nor 'Reverse' output is on\",\n    1: \"Either 'Forward' or 'Reverse' output is on (Motor active)\",\n  };\n  return motorMap[value] || `Unknown Motor Status ${value}`;\n}\n\nfunction decodeForwardStatus(value) {\n  // Forward status (bits 4-5)\n  const forwardMap = {\n    0: \"'Forward' output not on\",\n    1: \"'Forward' output is on (Shade raising/opening)\",\n  };\n  return forwardMap[value] || `Unknown Forward Status ${value}`;\n}\n\nfunction decodeReverseStatus(value) {\n  // Reverse status (bits 6-7)\n  const reverseMap = {\n    0: \"'Reverse' output not on\",\n    1: \"'Reverse' output is on (Shade lowering/closing)\",\n  };\n  return reverseMap[value] || `Unknown Reverse Status ${value}`;\n}\n\nfunction decodeDuration(value) {\n  // Duration decoding\n  if (value === 0) {\n    return \"Delay/duration expired\";\n  } else if (value >= 1 && value <= 239) {\n    return `${value} seconds remaining`;\n  } else if (value === 240) {\n    return \"240 or more seconds remaining\";\n  } else if (value === 255) {\n    return \"No delay/duration active\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeLastCommand(value) {\n  // Last command executed mapping per Table 6.39.3c\n  const commandMap = {\n    4: \"Stop\",\n    129: \"Forward (Open Shade)\", // 0x81\n    65: \"Reverse (Close Shade)\", // 0x41\n    133: \"Toggle Forward\", // 0x85\n    69: \"Toggle Reverse\", // 0x45\n    16: \"Tilt\", // 0x10\n    33: \"Lock\", // 0x21\n    34: \"Unlock\", // 0x22\n  };\n  return commandMap[value] || `Unknown Command ${value}`;\n}\n\nfunction decodeOvercurrentStatus(value) {\n  // Overcurrent status (bits 0-1)\n  const overcurrentMap = {\n    0: \"Load output not in overcurrent\",\n    1: \"Load output has drawn overcurrent\",\n    3: \"Overcurrent status unavailable or not supported\",\n  };\n  return overcurrentMap[value] || `Unknown Overcurrent Status ${value}`;\n}\n\nfunction decodeOverrideStatus(value) {\n  // Override status (bits 2-3)\n  const overrideMap = {\n    0: \"External override is inactive\",\n    1: \"External override is active\",\n    3: \"Override status is unavailable or not supported\",\n  };\n  return overrideMap[value] || `Unknown Override Status ${value}`;\n}\n\nfunction decodeDisableStatus(value, disableNumber) {\n  // Disable status for Disable1 (bits 4-5) or Disable2 (bits 6-7)\n  const disableMap = {\n    0: `Disable ${disableNumber} is not active`,\n    1: `Disable ${disableNumber} is active`,\n    3: `Disable ${disableNumber} is not supported`,\n  };\n  return disableMap[value] || `Unknown Disable${disableNumber} Status ${value}`;\n}\n\n// === Main Decode Function ===\n\nfunction decodeWindowShadeControlStatusMessage(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"WINDOW_SHADE_CONTROL_STATUS\",\n  };\n\n  if (data.length < 7) {\n    return {\n      error:\n        \"Invalid data length for WINDOW_SHADE_CONTROL_STATUS - expected at least 7 bytes\",\n    };\n  }\n\n  // Byte 0: Instance\n  result.instance = data[0];\n  result.instance_name = decodeInstance(data[0]);\n\n  // Byte 1: Group\n  const groupDetails = decodeGroupDetails(data[1]);\n  result.group_description = groupDetails.description;\n  if (groupDetails.groups) {\n    result.groups = groupDetails.groups;\n  }\n\n  // Byte 2: Operating Status (Motor Duty)\n  result.operating_status = decodeOperatingStatus(data[2]);\n\n  // Byte 3: Lock Status, Motor Status, Forward Status, Reverse Status\n  const byte3 = data[3];\n  const lockStatusRaw = decodeBits(byte3, 0, 1);\n  const motorStatusRaw = decodeBits(byte3, 2, 3);\n  const forwardStatusRaw = decodeBits(byte3, 4, 5);\n  const reverseStatusRaw = decodeBits(byte3, 6, 7);\n\n  result.lock_status = decodeLockStatus(lockStatusRaw);\n  result.motor_status = decodeMotorStatus(motorStatusRaw);\n  result.forward_status = decodeForwardStatus(forwardStatusRaw);\n  result.reverse_status = decodeReverseStatus(reverseStatusRaw);\n\n  // Byte 4: Duration\n  result.duration = decodeDuration(data[4]);\n\n  // Byte 5: Last Command\n  result.last_command = decodeLastCommand(data[5]);\n\n  // Byte 6: Overcurrent Status, Override Status, Disable1 Status, Disable2 Status\n  const byte6 = data[6];\n  const overcurrentStatusRaw = decodeBits(byte6, 0, 1);\n  const overrideStatusRaw = decodeBits(byte6, 2, 3);\n  const disable1StatusRaw = decodeBits(byte6, 4, 5);\n  const disable2StatusRaw = decodeBits(byte6, 6, 7);\n\n  result.overcurrent_status = decodeOvercurrentStatus(overcurrentStatusRaw);\n  result.override_status = decodeOverrideStatus(overrideStatusRaw);\n  result.disable1_status = decodeDisableStatus(disable1StatusRaw, 1);\n  result.disable2_status = decodeDisableStatus(disable2StatusRaw, 2);\n\n  // Raw values for debugging\n  result.raw_instance = data[0];\n  result.raw_group = data[1];\n  result.raw_operating_status = data[2];\n  result.raw_byte3 = byte3;\n  result.raw_lock_status = lockStatusRaw;\n  result.raw_motor_status = motorStatusRaw;\n  result.raw_forward_status = forwardStatusRaw;\n  result.raw_reverse_status = reverseStatusRaw;\n  result.raw_duration = data[4];\n  result.raw_last_command = data[5];\n  result.raw_byte6 = byte6;\n  result.raw_overcurrent_status = overcurrentStatusRaw;\n  result.raw_override_status = overrideStatusRaw;\n  result.raw_disable1_status = disable1StatusRaw;\n  result.raw_disable2_status = disable2StatusRaw;\n\n  // Add convenience fields for Home Assistant integration\n  result.is_locked = lockStatusRaw === 1;\n  result.motor_active = motorStatusRaw === 1;\n  result.shade_opening = forwardStatusRaw === 1;\n  result.shade_closing = reverseStatusRaw === 1;\n  result.shade_moving = result.shade_opening || result.shade_closing;\n  result.has_overcurrent = overcurrentStatusRaw === 1;\n  result.override_active = overrideStatusRaw === 1;\n  result.disable1_active = disable1StatusRaw === 1;\n  result.disable2_active = disable2StatusRaw === 1;\n  result.any_disable_active = result.disable1_active || result.disable2_active;\n\n  // Determine shade position status\n  if (typeof result.operating_status === \"number\") {\n    result.shade_position_percent = result.operating_status;\n    result.shade_fully_open = result.operating_status >= 99;\n    result.shade_fully_closed = result.operating_status <= 1;\n    result.shade_partially_open =\n      result.operating_status > 1 && result.operating_status < 99;\n  } else {\n    result.shade_position_percent = null;\n    result.shade_fully_open = false;\n    result.shade_fully_closed = false;\n    result.shade_partially_open = false;\n  }\n\n  // Validate instance - Window shade valid instances are 1-250\n  if (result.instance < 1 || result.instance > 250) {\n    node.warn(\n      `Invalid shade instance: ${result.instance} (${result.instance_name}) - message ignored`,\n    );\n    return null;\n  }\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the WINDOW_SHADE_CONTROL_STATUS message\nlet decodedData;\nif (dgn === \"1FEDE\") {\n  decodedData = decodeWindowShadeControlStatusMessage(dgn, dataBytes);\n\n  // Filter out messages that are either from an inactive instance OR are invalid/non-compliant.\n  // Inactive: Operating Status is \"Not Available\" (raw value 255).\n  // Invalid: Last Command is 0, which is not a defined command in the RV-C spec.\n  if (\n    decodedData.raw_operating_status === 255 ||\n    decodedData.raw_last_command === 0\n  ) {\n    let reason =\n      decodedData.raw_operating_status === 255\n        ? \"Inactive (Status Not Available)\"\n        : \"Invalid (Last Command is 0)\";\n    node.debug(`Filtering out instance ${decodedData.instance}: ${reason}`);\n    return null; // Stop the message from continuing.\n  }\n} else {\n  decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 220,
        "wires": [
            [
                "4ab29d3dd1da32a5"
            ]
        ]
    },
    {
        "id": "eb3524b2b7bf51e5",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode LOCK_STATUS",
        "func": "// Status Updater for Lock\n// Decodes LOCK_STATUS messages (1FEE5)\n\n// === Helper Functions ===\n\nfunction decodeBits(value, startBit, endBit) {\n    const mask = ((1 << (endBit - startBit + 1)) - 1) << startBit;\n    return (value & mask) >> startBit;\n}\n\n// === LOCK_STATUS Specific Decoders ===\n\nfunction decodeInstance(value) {\n    // Lock instance mapping per Section 6.40.1\n    if (value >= 1 && value <= 250) {\n        return value; // Direct instance number\n    } else if (value === 0) {\n        return \"Invalid\";\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeLockStatus(value) {\n    // Lock status (bits 0-1)\n    const lockMap = {\n        0: \"Unlocked\",\n        1: \"Locked\"\n    };\n    return lockMap[value] || `Unknown Lock Status ${value}`;\n}\n\nfunction decodeMotion(value) {\n    // Motion status\n    const motionMap = {\n        0: \"No Motion\",\n        1: \"Opening\",\n        2: \"Closing\"\n    };\n    return motionMap[value] || `Unknown Motion ${value}`;\n}\n\nfunction decodePosition(value) {\n    // Position as percentage per Table 5.3 (100% = Fully Open)\n    if (value <= 200) {\n        return parseFloat((value * 0.5).toFixed(1)); // 0.5% per step, 0-100%\n    } else if (value === 251) {\n        return \"Error\";\n    } else if (value === 252) {\n        return \"Not Supported\";\n    } else if (value === 253) {\n        return \"Out of Range\";\n    } else if (value === 254) {\n        return \"Reserved\";\n    } else if (value === 255) {\n        return \"Not Available\";\n    }\n    return \"Invalid\";\n}\n\nfunction decodeVoltage(value) {\n    // Voltage decoding per Table 5.3 (16-bit, little-endian)\n    if (value === 65535) {\n        return \"Not Available\";\n    } else if (value === 65534) {\n        return \"Reserved\";\n    } else if (value === 65533) {\n        return \"Out of Range\";\n    } else if (value === 65532) {\n        return \"Error\";\n    } else if (value <= 65530) {\n        // Voltage in mV with 0.1V resolution\n        return parseFloat((value * 0.1).toFixed(1)); // 0.1V per step\n    }\n    return \"Invalid\";\n}\n\nfunction decodeUint16(data, startByte) {\n    // Decode 16-bit value (little-endian)\n    if (!data || startByte + 1 >= data.length) {\n        return 65535; // Not available\n    }\n    return data[startByte] | (data[startByte + 1] << 8);\n}\n\n// === Main Decode Function ===\n\nfunction decodeLockStatusMessage(dgn, data) {\n    const result = {\n        dgn: dgn,\n        dgn_name: \"LOCK_STATUS\"\n    };\n\n    if (data.length < 6) {\n        return { error: \"Invalid data length for LOCK_STATUS - expected at least 6 bytes\" };\n    }\n\n    // Byte 0: Instance\n    result.instance = data[0];\n    result.instance_name = decodeInstance(data[0]);\n\n    // Byte 1: Lock Status (bits 0-1)\n    const byte1 = data[1];\n    const lockStatusRaw = decodeBits(byte1, 0, 1);\n    result.lock_status = decodeLockStatus(lockStatusRaw);\n\n    // Byte 2: Motion\n    result.motion = decodeMotion(data[2]);\n\n    // Byte 3: Position\n    result.position = decodePosition(data[3]);\n\n    // Bytes 4-5: Voltage (16-bit, little-endian)\n    const voltageRaw = decodeUint16(data, 4);\n    result.voltage = decodeVoltage(voltageRaw);\n\n    // Raw values for debugging\n    result.raw_instance = data[0];\n    result.raw_byte1 = byte1;\n    result.raw_lock_status = lockStatusRaw;\n    result.raw_motion = data[2];\n    result.raw_position = data[3];\n    result.raw_voltage_bytes = data.length >= 6 ? [data[4], data[5]] : null;\n    result.raw_voltage = voltageRaw;\n\n    // Include additional bytes if present\n    if (data.length > 6) {\n        for (let i = 6; i < data.length; i++) {\n            result[`raw_byte${i}`] = data[i];\n        }\n    }\n\n    // Add convenience fields for Home Assistant integration\n    result.is_locked = lockStatusRaw === 1;\n    result.is_unlocked = lockStatusRaw === 0;\n    result.is_moving = data[2] === 1 || data[2] === 2;\n    result.is_opening = data[2] === 1;\n    result.is_closing = data[2] === 2;\n    result.is_stationary = data[2] === 0;\n\n    // Position status (if available)\n    if (typeof result.position === 'number') {\n        result.position_percent = result.position;\n        result.fully_open = result.position >= 99;\n        result.fully_closed = result.position <= 1;\n        result.partially_open = result.position > 1 && result.position < 99;\n    } else {\n        result.position_percent = null;\n        result.fully_open = false;\n        result.fully_closed = false;\n        result.partially_open = false;\n    }\n\n    // Voltage status (if available)\n    if (typeof result.voltage === 'number') {\n        result.voltage_volts = result.voltage;\n        result.low_voltage = result.voltage < 11.0; // Typical 12V system low voltage threshold\n        result.high_voltage = result.voltage > 15.0; // Typical 12V system high voltage threshold\n        result.normal_voltage = result.voltage >= 11.0 && result.voltage <= 15.0;\n    } else {\n        result.voltage_volts = null;\n        result.low_voltage = false;\n        result.high_voltage = false;\n        result.normal_voltage = false;\n    }\n\n    // Validate instance - Lock valid instances are 0-250 (0 = broadcast/all locks)\n    if (result.instance < 0 || result.instance > 250) {\n        node.warn(`Invalid lock instance: ${result.instance} (${result.instance_name}) - message ignored`);\n        return null;\n    }\n\n    // Lock and motion combination status\n    result.locked_and_closed = result.is_locked && result.fully_closed;\n    result.unlocked_and_open = result.is_unlocked && result.fully_open;\n    result.secure_status = result.locked_and_closed ? \"Secure\" : \"Not Secure\";\n\n    return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.warn('Invalid payload: expected object');\n    return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n    node.warn('Missing required fields: dgn and/or data_payload');\n    return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== 'string' || data_payload.length % 2 !== 0) {\n    node.warn('Invalid data_payload: must be even-length hex string');\n    return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n    const hexByte = data_payload.substring(i, i + 2);\n    const byteValue = parseInt(hexByte, 16);\n    if (isNaN(byteValue)) {\n        node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n        return null;\n    }\n    dataBytes.push(byteValue);\n}\n\n// Decode the LOCK_STATUS message\nlet decodedData;\nif (dgn === '1FEE5') {\n    decodedData = decodeLockStatusMessage(dgn, dataBytes);\n} else {\n    decodedData = { error: `Decoder for DGN ${dgn} is not implemented.` };\n}\n\n// Handle null return (invalid instance filtered out)\nif (!decodedData) {\n    return null;\n}\n\n// Handle decode errors\nif (decodedData.error) {\n    incomingPayload.decoding_error = decodedData.error;\n    msg.payload = incomingPayload;\n    return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n    ...incomingPayload,\n    ...decodedData\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 280,
        "wires": [
            [
                "f00adfe38f0e26b5"
            ]
        ]
    },
    {
        "id": "f00adfe38f0e26b5",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "LOCK_STATUS",
        "mode": "link",
        "links": [
            "1d2d33ef4e57dd39"
        ],
        "x": 1300,
        "y": 280,
        "wires": [],
        "l": true
    },
    {
        "id": "4ab29d3dd1da32a5",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "SHADE_STATUS",
        "mode": "link",
        "links": [
            "f9a04003db7d8e4a"
        ],
        "x": 1310,
        "y": 220,
        "wires": [],
        "l": true
    },
    {
        "id": "b87fcd5e60905824",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "AUTOFILL_STATUS",
        "mode": "link",
        "links": [
            "93a2783b5bb8d93d"
        ],
        "x": 1320,
        "y": 100,
        "wires": [],
        "l": true
    },
    {
        "id": "295d4bc9058dab71",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "WATER_PUMP_STATUS",
        "mode": "link",
        "links": [
            "efb5c968a0a43c7d"
        ],
        "x": 1330,
        "y": 40,
        "wires": [],
        "l": true
    },
    {
        "id": "40bc1ec5180b6589",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "DC_SOURCE_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 870,
        "y": 1720,
        "wires": []
    },
    {
        "id": "db73295f937c90a1",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "FLOOR_HEAT_STATUS",
        "mode": "link",
        "links": [
            "bd2d1b59183b99bb"
        ],
        "x": 1330,
        "y": 460,
        "wires": [],
        "l": true
    },
    {
        "id": "5e7062bde869c7a5",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AQUAHOT_STATUS",
        "func": "// Status Updater for Aqua-Hot\n// Decodes proprietary AQUAHOT status byte into individual status messages\n\nconst DISCRIMINATOR = 0xA9; // The expected first data byte (Byte 1)\n\n// Maps the bit position to the instance name\nconst BIT_MAP = {\n    0: 'burner',     // Burner Status (Bit 0)\n    2: 'ac_1',       // AC Element 1 Status (Bit 2)\n    3: 'ac_2',       // AC Element 2 Status (Bit 3)\n    6: 'engine'      // Engine Pre-heat Status (Bit 6)\n};\n\nconst data_payload = msg.payload.data_payload;\n\n// Extract the status byte (Byte 2 of the data payload)\nconst statusByte = parseInt(data_payload.substring(2, 4), 16);\n\nlet outputMessages = [];\n\n// Decode the individual status bits\nfor (const bit in BIT_MAP) {\n    const bitIndex = Number(bit);\n    const instance = BIT_MAP[bitIndex];\n\n    // Check if the bit is set (Bit = 1 for ON)\n    const isBitSet = (statusByte >> bitIndex) & 1;\n    const status = isBitSet ? \"ON\" : \"OFF\";\n\n    // Prepare the message following the standard pattern\n    const statusMsg = {\n        payload: {\n            instance,\n            status\n        }\n    };\n\n    outputMessages.push(statusMsg);\n}\n\n// Send all four status updates simultaneously\nreturn [outputMessages];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 520,
        "wires": [
            [
                "b6c72de91f6e7ec7"
            ]
        ]
    },
    {
        "id": "b6c72de91f6e7ec7",
        "type": "link out",
        "z": "3e5f038a4f5a8b9a",
        "name": "AQUAHOT_STATUS",
        "mode": "link",
        "links": [
            "2ee0ed60af1beb40"
        ],
        "x": 1320,
        "y": 520,
        "wires": [],
        "l": true
    },
    {
        "id": "871009c15ad9a99b",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AQUAHOT_THERMOSTAT_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 580,
        "wires": []
    },
    {
        "id": "be1c2b9fdc3dd714",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "CIRCULATION_PUMP_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1350,
        "y": 1780,
        "wires": []
    },
    {
        "id": "54c7344ace5b029a",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "AIR_CONDITIONER_STATUS",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1350,
        "y": 1840,
        "wires": []
    },
    {
        "id": "4a7ebb2b6a783a13",
        "type": "debug",
        "z": "3e5f038a4f5a8b9a",
        "name": "WATERHEATER_STATUS_2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1340,
        "y": 1900,
        "wires": []
    },
    {
        "id": "5ac8d282ced2b5a1",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode AIR_CONDITIONER_STATUS",
        "func": "// Status Updater for Air Conditioner\n// Decodes AIR_CONDITIONER_STATUS messages (1FFE1)\n\n// === Helper Functions ===\n\nfunction decodeOperatingMode(value) {\n  // Operating mode mapping\n  const modes = {\n    0: \"Automatic\",\n    1: \"Manual\",\n    255: \"Not Available\",\n  };\n  return modes[value] || `Unknown (${value})`;\n}\n\nfunction decodePercentage(value) {\n  // Percentage decoding: 0.5% per count, range 0-100%\n  if (value <= 200) {\n    return parseFloat((value * 0.5).toFixed(1));\n  } else if (value === 251) {\n    return \"Error\";\n  } else if (value === 252) {\n    return \"Not Supported\";\n  } else if (value === 253) {\n    return \"Out of Range\";\n  } else if (value === 254) {\n    return \"Reserved\";\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeDeadband(value) {\n  // Dead band: 0.1°C precision, range 0-25.0°C\n  if (value <= 250) {\n    return parseFloat((value * 0.1).toFixed(1));\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\nfunction decodeInstance(value) {\n  // Instance decoding per Table 5.3\n  if (value === 0) {\n    return 0; // All instances / Auto fan speed\n  } else if (value >= 1 && value <= 250) {\n    return value;\n  } else if (value === 255) {\n    return \"Not Available\";\n  }\n  return \"Invalid\";\n}\n\n// === Main Decode Function ===\n\nfunction decodeAirConditionerStatusMessage(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"AIR_CONDITIONER_STATUS\",\n  };\n\n  if (data.length < 6) {\n    result.error = \"Data payload too short (expected at least 6 bytes)\";\n    return result;\n  }\n\n  // Byte 0: Instance (Zone)\n  result.instance = decodeInstance(data[0]);\n  if (typeof result.instance === \"number\") {\n    result.instance_description =\n      result.instance === 0 ? \"All zones\" : `Zone ${result.instance}`;\n  } else {\n    result.instance_description = result.instance;\n  }\n\n  // Byte 1: Operating Mode\n  result.operating_mode = decodeOperatingMode(data[1]);\n  result.is_automatic = data[1] === 0;\n  result.is_manual = data[1] === 1;\n\n  // Byte 2: Max Fan Speed (%)\n  result.max_fan_speed = decodePercentage(data[2]);\n  result.max_fan_speed_limited =\n    typeof result.max_fan_speed === \"number\" && result.max_fan_speed < 100;\n\n  // Byte 3: Max AC Output Level (%)\n  result.max_ac_output_level = decodePercentage(data[3]);\n  result.max_output_limited =\n    typeof result.max_ac_output_level === \"number\" &&\n    result.max_ac_output_level < 100;\n\n  // Byte 4: Fan Speed (%)\n  result.fan_speed = decodePercentage(data[4]);\n  result.fan_running =\n    typeof result.fan_speed === \"number\" && result.fan_speed > 0;\n\n  // Byte 5: AC Output Level (%)\n  result.ac_output_level = decodePercentage(data[5]);\n  result.compressor_running =\n    typeof result.ac_output_level === \"number\" && result.ac_output_level > 0;\n\n  // Byte 6: Dead Band (optional)\n  if (data.length >= 7) {\n    result.dead_band = decodeDeadband(data[6]);\n    result.dead_band_unit = \"°C\";\n  }\n\n  // Byte 7: Second Stage Dead Band (optional)\n  if (data.length >= 8) {\n    result.second_stage_dead_band = decodeDeadband(data[7]);\n    result.second_stage_dead_band_unit = \"°C\";\n  }\n\n  // Convenience fields\n  result.ac_active = result.compressor_running;\n  result.status = result.compressor_running\n    ? \"COOLING\"\n    : result.fan_running\n      ? \"FAN ONLY\"\n      : \"OFF\";\n\n  // Power sharing status\n  result.power_limited =\n    result.max_fan_speed_limited || result.max_output_limited;\n\n  // Raw values for debugging\n  result.raw_instance = data[0];\n  result.raw_operating_mode = data[1];\n  result.raw_max_fan_speed = data[2];\n  result.raw_max_ac_output_level = data[3];\n  result.raw_fan_speed = data[4];\n  result.raw_ac_output_level = data[5];\n  if (data.length >= 7) result.raw_dead_band = data[6];\n  if (data.length >= 8) result.raw_second_stage_dead_band = data[7];\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the AIR_CONDITIONER_STATUS message\nconst decodedData = decodeAirConditionerStatusMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 1840,
        "wires": [
            [
                "54c7344ace5b029a"
            ]
        ]
    },
    {
        "id": "2d9036a34ecd189a",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode CIRCULATION_PUMP_STATUS",
        "func": "// Status Updater for Circulation Pump\n// Decodes CIRCULATION_PUMP_STATUS messages (1FE97)\n\n// === Helper Functions ===\n\nfunction decodeOutputStatus(value) {\n  // Output status mapping\n  const statuses = {\n    0: \"Off\",\n    1: \"On\",\n    5: \"Test (Forced On)\",\n  };\n  return statuses[value] || `Unknown (${value})`;\n}\n\nfunction decode2BitStatus(value) {\n  // Generic 2-bit status for warning/error fields\n  const statuses = {\n    0: \"OK\",\n    1: \"Warning\",\n    2: \"Reserved\",\n    3: \"Not Available\",\n  };\n  return statuses[value] || `Unknown (${value})`;\n}\n\n// === Main Decode Function ===\n\nfunction decodeCirculationPumpStatusMessage(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"CIRCULATION_PUMP_STATUS\",\n  };\n\n  if (data.length < 3) {\n    result.error = \"Data payload too short (expected at least 3 bytes)\";\n    return result;\n  }\n\n  // Byte 0: Instance\n  result.instance = data[0];\n  if (result.instance === 0) {\n    result.instance_description = \"All pumps\";\n  } else if (result.instance >= 1 && result.instance <= 250) {\n    result.instance_description = `Pump ${result.instance}`;\n  } else {\n    result.instance_description = \"Invalid\";\n  }\n\n  // Byte 1, Bits 0-3: Output Status\n  const outputStatusRaw = data[1] & 0x0f;\n  result.output_status = decodeOutputStatus(outputStatusRaw);\n  result.pump_running = outputStatusRaw === 1 || outputStatusRaw === 5;\n\n  // Byte 2: Status flags\n  const byte2 = data[2];\n\n  // Bits 0-1: Pump Overcurrent Status\n  const overcurrentRaw = byte2 & 0x03;\n  result.overcurrent_status = decode2BitStatus(overcurrentRaw);\n  result.overcurrent_detected = overcurrentRaw === 1;\n\n  // Bits 2-3: Pump Undercurrent Status\n  const undercurrentRaw = (byte2 >> 2) & 0x03;\n  result.undercurrent_status = decode2BitStatus(undercurrentRaw);\n  result.undercurrent_detected = undercurrentRaw === 1;\n\n  // Bits 4-5: Pump Temperature Status\n  const temperatureRaw = (byte2 >> 4) & 0x03;\n  result.temperature_status = decode2BitStatus(temperatureRaw);\n  result.temperature_warning = temperatureRaw === 1;\n\n  // Convenience fields\n  result.status = result.pump_running ? \"ON\" : \"OFF\";\n  result.has_fault =\n    result.overcurrent_detected ||\n    result.undercurrent_detected ||\n    result.temperature_warning;\n\n  // Raw values for debugging\n  result.raw_instance = data[0];\n  result.raw_output_status = outputStatusRaw;\n  result.raw_byte2 = byte2;\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the CIRCULATION_PUMP_STATUS message\nconst decodedData = decodeCirculationPumpStatusMessage(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 1780,
        "wires": [
            [
                "be1c2b9fdc3dd714"
            ]
        ]
    },
    {
        "id": "5bb6491915c598ce",
        "type": "function",
        "z": "3e5f038a4f5a8b9a",
        "name": "Decode WATERHEATER_STATUS_2",
        "func": "// Status Updater for Water Heater (Ext)\n// Decodes WATERHEATER_STATUS_2 messages (1FE99)\n\n// === Helper Functions ===\n\nfunction decodeEnginePreheat(value) {\n  // Engine preheat status mapping\n  const statuses = {\n    0: \"Off\",\n    1: \"On\",\n    5: \"Test (Forced On)\",\n  };\n  return statuses[value] || `Unknown (${value})`;\n}\n\nfunction decode2BitOnOff(value) {\n  // Generic 2-bit on/off status\n  const statuses = {\n    0: \"Off\",\n    1: \"On\",\n    2: \"Reserved\",\n    3: \"Not Available\",\n  };\n  return statuses[value] || `Unknown (${value})`;\n}\n\nfunction decode2BitWarning(value) {\n  // Generic 2-bit warning status\n  const statuses = {\n    0: \"OK\",\n    1: \"Warning\",\n    2: \"Reserved\",\n    3: \"Not Available\",\n  };\n  return statuses[value] || `Unknown (${value})`;\n}\n\nfunction decodeCoolantLevel(value) {\n  const statuses = {\n    0: \"Sufficient\",\n    1: \"Low\",\n    2: \"Reserved\",\n    3: \"Not Available\",\n  };\n  return statuses[value] || `Unknown (${value})`;\n}\n\nfunction decodeHotWaterPriority(value) {\n  const priorities = {\n    0: \"Domestic Water\",\n    1: \"Heating\",\n    2: \"Reserved\",\n    3: \"Not Available\",\n  };\n  return priorities[value] || `Unknown (${value})`;\n}\n\n// === Main Decode Function ===\n\nfunction decodeWaterheaterStatus2Message(dgn, data) {\n  const result = {\n    dgn: dgn,\n    dgn_name: \"WATERHEATER_STATUS_2\",\n  };\n\n  if (data.length < 8) {\n    result.error = \"Data payload too short (expected 8 bytes)\";\n    return result;\n  }\n\n  // Byte 0: Instance\n  result.instance = data[0];\n  if (result.instance === 0) {\n    result.instance_description = \"All water heaters\";\n  } else if (result.instance >= 1 && result.instance <= 250) {\n    result.instance_description = `Water Heater ${result.instance}`;\n  } else {\n    result.instance_description = \"Invalid\";\n  }\n\n  // Byte 1: Electric Element Levels\n  const byte1 = data[1];\n  result.electric_element_level = byte1 & 0x0f; // Bits 0-3\n  result.max_electric_element_level = (byte1 >> 4) & 0x0f; // Bits 4-7\n\n  // Byte 2: Engine Preheat, Coolant Level, Hot Water Priority\n  const byte2 = data[2];\n  const enginePreheatRaw = byte2 & 0x0f; // Bits 0-3\n  result.engine_preheat = decodeEnginePreheat(enginePreheatRaw);\n  result.engine_preheat_active =\n    enginePreheatRaw === 1 || enginePreheatRaw === 5;\n\n  const coolantLevelRaw = (byte2 >> 4) & 0x03; // Bits 4-5\n  result.coolant_level = decodeCoolantLevel(coolantLevelRaw);\n  result.coolant_low = coolantLevelRaw === 1;\n\n  const hotWaterPriorityRaw = (byte2 >> 6) & 0x03; // Bits 6-7\n  result.hot_water_priority = decodeHotWaterPriority(hotWaterPriorityRaw);\n\n  // Byte 3: Output Statuses\n  const byte3 = data[3];\n  const burnerOutputRaw = byte3 & 0x03; // Bits 0-1\n  result.burner_output = decode2BitOnOff(burnerOutputRaw);\n  result.burner_on = burnerOutputRaw === 1;\n\n  const burnerIndicatorRaw = (byte3 >> 2) & 0x03; // Bits 2-3\n  result.burner_indicator = decode2BitOnOff(burnerIndicatorRaw);\n\n  const electricLowOutputRaw = (byte3 >> 4) & 0x03; // Bits 4-5\n  result.electric_low_output = decode2BitOnOff(electricLowOutputRaw);\n  result.electric_low_on = electricLowOutputRaw === 1;\n\n  const electricHighOutputRaw = (byte3 >> 6) & 0x03; // Bits 6-7\n  result.electric_high_output = decode2BitOnOff(electricHighOutputRaw);\n  result.electric_high_on = electricHighOutputRaw === 1;\n\n  // Byte 4: Burner Status Flags\n  const byte4 = data[4];\n  const burnerOvercurrentRaw = byte4 & 0x03; // Bits 0-1\n  result.burner_overcurrent = decode2BitWarning(burnerOvercurrentRaw);\n\n  const burnerUndercurrentRaw = (byte4 >> 2) & 0x03; // Bits 2-3\n  result.burner_undercurrent = decode2BitWarning(burnerUndercurrentRaw);\n\n  const burnerTempRaw = (byte4 >> 4) & 0x03; // Bits 4-5\n  result.burner_temperature = decode2BitWarning(burnerTempRaw);\n\n  const burnerInputRaw = (byte4 >> 6) & 0x03; // Bits 6-7\n  result.burner_input = decode2BitOnOff(burnerInputRaw);\n\n  // Byte 5: Burner Indicator Status Flags\n  const byte5 = data[5];\n  const burnerIndOvercurrentRaw = byte5 & 0x03; // Bits 0-1\n  result.burner_indicator_overcurrent = decode2BitWarning(\n    burnerIndOvercurrentRaw,\n  );\n\n  const burnerIndUndercurrentRaw = (byte5 >> 2) & 0x03; // Bits 2-3\n  result.burner_indicator_undercurrent = decode2BitWarning(\n    burnerIndUndercurrentRaw,\n  );\n\n  const burnerIndTempRaw = (byte5 >> 4) & 0x03; // Bits 4-5\n  result.burner_indicator_temperature = decode2BitWarning(burnerIndTempRaw);\n\n  // Byte 6: Electric Low Element Status Flags\n  const byte6 = data[6];\n  const elecLowOvercurrentRaw = byte6 & 0x03; // Bits 0-1\n  result.electric_low_overcurrent = decode2BitWarning(elecLowOvercurrentRaw);\n\n  const elecLowUndercurrentRaw = (byte6 >> 2) & 0x03; // Bits 2-3\n  result.electric_low_undercurrent = decode2BitWarning(elecLowUndercurrentRaw);\n\n  const elecLowTempRaw = (byte6 >> 4) & 0x03; // Bits 4-5\n  result.electric_low_temperature = decode2BitWarning(elecLowTempRaw);\n\n  const elecLowInputRaw = (byte6 >> 6) & 0x03; // Bits 6-7\n  result.electric_low_input = decode2BitOnOff(elecLowInputRaw);\n\n  // Byte 7: Electric High Element Status Flags\n  const byte7 = data[7];\n  const elecHighOvercurrentRaw = byte7 & 0x03; // Bits 0-1\n  result.electric_high_overcurrent = decode2BitWarning(elecHighOvercurrentRaw);\n\n  const elecHighUndercurrentRaw = (byte7 >> 2) & 0x03; // Bits 2-3\n  result.electric_high_undercurrent = decode2BitWarning(\n    elecHighUndercurrentRaw,\n  );\n\n  const elecHighTempRaw = (byte7 >> 4) & 0x03; // Bits 4-5\n  result.electric_high_temperature = decode2BitWarning(elecHighTempRaw);\n\n  const elecHighInputRaw = (byte7 >> 6) & 0x03; // Bits 6-7\n  result.electric_high_input = decode2BitOnOff(elecHighInputRaw);\n\n  // === Convenience Fields ===\n\n  // Overall heating status\n  result.any_heat_source_on =\n    result.burner_on ||\n    result.electric_low_on ||\n    result.electric_high_on ||\n    result.engine_preheat_active;\n\n  // Determine primary status for simple display\n  if (result.burner_on && (result.electric_low_on || result.electric_high_on)) {\n    result.status = \"GAS+ELECTRIC\";\n  } else if (result.burner_on) {\n    result.status = \"GAS\";\n  } else if (result.electric_high_on) {\n    result.status = \"ELECTRIC HIGH\";\n  } else if (result.electric_low_on) {\n    result.status = \"ELECTRIC LOW\";\n  } else if (result.engine_preheat_active) {\n    result.status = \"ENGINE PREHEAT\";\n  } else {\n    result.status = \"OFF\";\n  }\n\n  // Fault detection\n  result.burner_fault =\n    burnerOvercurrentRaw === 1 ||\n    burnerUndercurrentRaw === 1 ||\n    burnerTempRaw === 1;\n  result.electric_low_fault =\n    elecLowOvercurrentRaw === 1 ||\n    elecLowUndercurrentRaw === 1 ||\n    elecLowTempRaw === 1;\n  result.electric_high_fault =\n    elecHighOvercurrentRaw === 1 ||\n    elecHighUndercurrentRaw === 1 ||\n    elecHighTempRaw === 1;\n  result.has_fault =\n    result.burner_fault ||\n    result.electric_low_fault ||\n    result.electric_high_fault ||\n    result.coolant_low;\n\n  // Raw values for debugging\n  result.raw_instance = data[0];\n  result.raw_byte1 = data[1];\n  result.raw_byte2 = data[2];\n  result.raw_byte3 = data[3];\n  result.raw_byte4 = data[4];\n  result.raw_byte5 = data[5];\n  result.raw_byte6 = data[6];\n  result.raw_byte7 = data[7];\n\n  return result;\n}\n\n// === Main Logic ===\n\n// Validate input payload\nif (!msg.payload || typeof msg.payload !== \"object\") {\n  node.warn(\"Invalid payload: expected object\");\n  return null;\n}\n\nconst incomingPayload = msg.payload;\nconst { dgn, data_payload } = incomingPayload;\n\nif (!dgn || !data_payload) {\n  node.warn(\"Missing required fields: dgn and/or data_payload\");\n  return null;\n}\n\n// Validate and convert hex payload to byte array\nif (typeof data_payload !== \"string\" || data_payload.length % 2 !== 0) {\n  node.warn(\"Invalid data_payload: must be even-length hex string\");\n  return null;\n}\n\nconst dataBytes = [];\nfor (let i = 0; i < data_payload.length; i += 2) {\n  const hexByte = data_payload.substring(i, i + 2);\n  const byteValue = parseInt(hexByte, 16);\n  if (isNaN(byteValue)) {\n    node.warn(`Invalid hex byte in data_payload: ${hexByte}`);\n    return null;\n  }\n  dataBytes.push(byteValue);\n}\n\n// Decode the WATERHEATER_STATUS_2 message\nconst decodedData = decodeWaterheaterStatus2Message(dgn, dataBytes);\n\n// Handle decode errors\nif (decodedData.error) {\n  incomingPayload.decoding_error = decodedData.error;\n  msg.payload = incomingPayload;\n  return msg;\n}\n\n// Merge the incoming payload and the decoded data into a single flat object\nmsg.payload = {\n  ...incomingPayload,\n  ...decodedData,\n};\n\n// Clean up the final object by removing the raw data field\ndelete msg.payload.data_payload;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 1900,
        "wires": [
            [
                "4a7ebb2b6a783a13"
            ]
        ]
    },
    {
        "id": "7e609140970f546c",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Load on Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 260,
        "y": 1580,
        "wires": [
            [
                "74c7e4a6cc2508eb"
            ]
        ]
    },
    {
        "id": "74c7e4a6cc2508eb",
        "type": "file in",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Read DGN table",
        "filename": "/config/projects/libre-coach-node-red/rvc/dgn-summary-table.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "allProps": false,
        "x": 460,
        "y": 1580,
        "wires": [
            [
                "c78420a075d43408"
            ]
        ]
    },
    {
        "id": "cd670f6465b6374b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "Store DGN map",
        "func": "// Convert the data to a Map when initially storing it\nconst dgnMap = new Map(\n  msg.payload.map((entry) => [entry.Hex.toString().toUpperCase(), entry.DGN]),\n);\n\n// Store the Map in global context\nglobal.set(\"dgnMap\", dgnMap);\n\n// Count the number of records\nconst decoderCount = dgnMap.size;\n\n// Update the node status to indicate success\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `Config loaded, ${decoderCount} records`,\n});\nreturn null;\n",
        "outputs": 0,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 1580,
        "wires": []
    },
    {
        "id": "c78420a075d43408",
        "type": "json",
        "z": "292e70a6ba25b323",
        "g": "9cfcca5efde78052",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 670,
        "y": 1580,
        "wires": [
            [
                "cd670f6465b6374b"
            ]
        ]
    },
    {
        "id": "cacf35b859af22a9",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out: Retain TRUE",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 730,
        "y": 380,
        "wires": []
    },
    {
        "id": "e7ae35364ce60f3f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 420,
        "wires": []
    },
    {
        "id": "f658418a7b9b4857",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out: Retain TRUE",
        "links": [
            "d38c75bc1474be23",
            "d3a13b531babee66",
            "d4ef1d361f084b58",
            "ea29386f9f8682bc",
            "b94bb12a8c0a7027",
            "927340668e7942e4",
            "bc627a6a37117bc0",
            "cff02a511add6887",
            "f0ba2779795efdae",
            "1c1403c14b577fb4"
        ],
        "x": 270,
        "y": 380,
        "wires": [
            [
                "cacf35b859af22a9",
                "e7ae35364ce60f3f"
            ]
        ],
        "l": true
    },
    {
        "id": "b86f82e84d961549",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/+/+/set",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 180,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "64c5e5cfd4382453",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "mode": "link",
        "links": [
            "a3b957142479c075"
        ],
        "x": 670,
        "y": 280,
        "wires": [],
        "l": true
    },
    {
        "id": "2110ea4d0b85f784",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "topic": "can/raw",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 120,
        "wires": [
            [
                "958fed9f12301f59",
                "32add109922d428a"
            ]
        ]
    },
    {
        "id": "958fed9f12301f59",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "CAN in",
        "mode": "link",
        "links": [
            "2fcbc4d630144362"
        ],
        "x": 680,
        "y": 140,
        "wires": [],
        "l": true
    },
    {
        "id": "8d7d5d3ea117cf79",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decode RVC CAN",
        "func": "// decode_rvc_can.js\n// RV-C CAN Message Parser\n// Decodes a raw CAN message to output only the fields needed for\n// downstream routing (dgn_name) and decoding (data_payload).\n\nconst originalMessage = msg.payload;\n\n// Validate input\nif (!originalMessage || typeof originalMessage !== 'string') {\n    node.warn(\"Invalid message payload: expected string, got \" + typeof originalMessage);\n    return null;\n}\nconst dgnMap = global.get('dgnMap');\nif (!dgnMap) {\n    node.error(\"dgnMap not found in global context. Ensure the map is initialized.\");\n    return null;\n}\n\n// Parse CAN message format: CANID#PAYLOAD\nconst parts = originalMessage.split('#');\nif (parts.length !== 2) {\n    node.warn(\"Invalid CAN message format: \" + originalMessage);\n    return null;\n}\nconst canIdHex = parts[0];\nconst data_payload = parts[1];\nconst canIdNum = parseInt(canIdHex, 16);\n\nif (isNaN(canIdNum)) {\n    node.warn(\"Invalid CAN ID: \" + canIdHex);\n    return null;\n}\n\n// Extract PGN (4-digit) and DGN (5-digit) keys\n\n// Get the 4-digit J1939 PGN (PF + PS). This value is consistent.\nconst pf = (canIdNum >> 16) & 0xFF;  // PDU Format (Bits 16-23)\nconst ps = (canIdNum >> 8) & 0xFF;   // PDU Specific (Bits 8-15)\nlet pgn = ((pf << 8) | ps).toString(16).toUpperCase();\n\n// Ensure 4 characters for known PGNs (e.g., EF4D)\nwhile (pgn.length < 4) {\n    pgn = '0' + pgn;\n}\n\n// PDU1 handling: For PF < 240, PS is destination address, not part of DGN\n// Replace PS with 00 for lookup (with exceptions)\nlet lookupPgn = pgn;\nif (pf < 0xF0) {  // PDU1 format\n    if (pf === 0xEF) {\n        // Exception: Proprietary messages keep PS (EF4D, EF64, EF9F)\n        lookupPgn = pgn;\n    } else if (pf === 0xEC || pf === 0xEB) {\n        // Exception: Multi-packet transport uses FF\n        lookupPgn = pf.toString(16).toUpperCase() + 'FF';\n    } else {\n        // Standard PDU1: Replace PS with 00\n        lookupPgn = pf.toString(16).toUpperCase() + '00';\n    }\n    // Ensure 4 characters\n    while (lookupPgn.length < 4) {\n        lookupPgn = '0' + lookupPgn;\n    }\n}\n\n// The lookup DGN starts as the lookup PGN\nlet dgn = lookupPgn;\nlet dgn_name;\n\n// --- DGN Conversion and Primary Lookup ---\n// If the PGN is in the FE/FF range, convert it to the 5-digit RV-C DGN (1F prefix)\n// for primary map lookup. This handles 1FECA, 1FFA9, etc.\nif (dgn.startsWith('FE') || dgn.startsWith('FF')) {\n    dgn = '1' + lookupPgn;\n    dgn_name = dgnMap.get(dgn); // Use the 5-digit key for lookup\n} else {\n    // For all other PGNs (like 00F7, EF4D), use the 4-digit PGN for lookup\n    dgn_name = dgnMap.get(dgn);\n}\n\n\n// Fallback logic for Aqua-Hot proprietary PGNs not in lookup table\nif (!dgn_name) {\n    if (pgn === 'EF64') {\n        dgn_name = \"AQUAHOT_COMMAND\";\n    } else if (pgn === 'EF9F') {\n        dgn_name = \"AQUAHOT_STATUS\";\n    } else if (pgn === 'EF4D') {\n        dgn_name = \"AQUAHOT_THERMOSTAT_STATUS\";\n    }\n}\n\n// Final output\nif (!dgn_name) {\n    dgn_name = \"UNKNOWN\";\n}\n\nmsg.payload = {\n    originalMessage: originalMessage,\n    dgn: dgn,\n    dgn_name: dgn_name,\n    data_payload: data_payload\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 520,
        "wires": [
            [
                "ac47ce53a9fc3f21",
                "698efabc308fece6",
                "a16ce99da6a2a88f",
                "2e131d4d25819c93",
                "a2dad25eb05117f7",
                "fc66c16576e28548",
                "c6fb02a17f709e08",
                "a6594a9464d8fe4e"
            ]
        ]
    },
    {
        "id": "ac47ce53a9fc3f21",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Decoded",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 640,
        "wires": []
    },
    {
        "id": "698efabc308fece6",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dataPayload",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dataPayload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 600,
        "wires": []
    },
    {
        "id": "a16ce99da6a2a88f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgn",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgn",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 400,
        "wires": []
    },
    {
        "id": "2e131d4d25819c93",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "dgnName",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.dgnName",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 440,
        "wires": []
    },
    {
        "id": "a2dad25eb05117f7",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "originalMessage",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.originalMessage",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1480,
        "y": 360,
        "wires": []
    },
    {
        "id": "fc66c16576e28548",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "sourceAddress",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.sourceAddress",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1480,
        "y": 480,
        "wires": []
    },
    {
        "id": "c6fb02a17f709e08",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "priority",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.priority",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 560,
        "wires": []
    },
    {
        "id": "2fcbc4d630144362",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "CAN in",
        "links": [
            "958fed9f12301f59"
        ],
        "x": 1010,
        "y": 520,
        "wires": [
            [
                "8d7d5d3ea117cf79"
            ]
        ],
        "l": true
    },
    {
        "id": "a6594a9464d8fe4e",
        "type": "switch",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "DM-RV",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "DATE_TIME_STATUS",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ACKNOWLEDGEMENT",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "REQUEST_FOR_DGN",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "TIME",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "STATUS",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ADDRESS_CLAIMED",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "PROPRIETARY",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "UNKNOWN",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 11,
        "x": 1690,
        "y": 520,
        "wires": [
            [],
            [],
            [],
            [],
            [],
            [
                "02bdfc59de71b5a5"
            ],
            [
                "4fa9b9fdc36c83da"
            ],
            [
                "45414bacecada477"
            ],
            [
                "3d5ce3e925ee2f04"
            ],
            [
                "c781b519a9f9b156"
            ],
            [
                "463dfbbef66b51c2"
            ]
        ]
    },
    {
        "id": "a4028527eb23fa04",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2030,
        "y": 680,
        "wires": [
            [
                "092c751dcdd12270"
            ]
        ]
    },
    {
        "id": "092c751dcdd12270",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Reset function",
        "func": "flow.set(\"uniqueUnknown\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2300,
        "y": 680,
        "wires": [
            []
        ]
    },
    {
        "id": "c781b519a9f9b156",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "Unique unknown",
        "func": "// Unique Filter for Unknown Messages\n\n// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueUNKNOWN = flow.get(\"uniqueUNKNOWN\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgn);\n\n// Check if it's a new unique message\nif (!uniqueUNKNOWN.includes(newMsgStr)) {\n    uniqueUNKNOWN.push(newMsgStr);\n    flow.set(\"uniqueUNKNOWN\", uniqueUNKNOWN);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 740,
        "wires": [
            [
                "eea1641469efb23f"
            ]
        ]
    },
    {
        "id": "eea1641469efb23f",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "9dd6a98018824be9",
        "name": "New Unknown DGN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2320,
        "y": 740,
        "wires": []
    },
    {
        "id": "02bdfc59de71b5a5",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "STATUS out",
        "mode": "link",
        "links": [
            "fbc5efde2c447eda"
        ],
        "x": 1990,
        "y": 320,
        "wires": [],
        "l": true
    },
    {
        "id": "d34a8c1fd2cc4320",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 670,
        "y": 220,
        "wires": []
    },
    {
        "id": "515386b6b0d01893",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Load 5 seconds after Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 300,
        "y": 1060,
        "wires": [
            [
                "b846bc1605dae821"
            ]
        ]
    },
    {
        "id": "b846bc1605dae821",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim request",
        "func": "// RV-C Address Claim - Send Initial Claim\n// Generates a persistent unique ID, selects an address, and broadcasts the\n// ADDRESS_CLAIMED message (DGN EE00h) to claim the address.\n\n// --- Step 1: Handle Manual Reset Command (if triggered) ---\nif (msg.topic === \"reset_device_id\") {\n  // Clear the saved unique ID from persistent storage\n  global.set(\"my_persistent_rvc_id\", null);\n  // Reset the address attempt counter to start fresh\n  context.set(\"address_attempt\", null);\n  node.warn(\"Persistent DEVICE_NAME cleared. Generating a new one and starting claim...\");\n  // By not returning, we allow the script to continue and generate a new ID immediately.\n}\n\n\n// --- Configuration ---\nconst STARTING_ADDRESS = 223;\nconst MIN_ADDRESS = 208;\n\n\n// --- Step 2: Create or Retrieve a Persistent Unique DEVICE_NAME ---\nlet uniqueId = global.get(\"my_persistent_rvc_id\");\n\nif (!uniqueId) {\n  // No ID found, so generate a new one.\n  const randomSerial = Math.floor(Math.random() * 0x1FFFFF);\n  const randomSerialHex = randomSerial.toString(16).padStart(6, '0').toUpperCase();\n  uniqueId = \"8000000000\" + randomSerialHex;\n\n  // Save this new ID to the global context for future use.\n  global.set(\"my_persistent_rvc_id\", uniqueId);\n  //node.warn(\"Generated and saved a new persistent DEVICE_NAME: \" + uniqueId);\n}\nconst DEVICE_NAME = uniqueId;\n\n\n// --- Step 3: Select an Address to Claim ---\nconst usedAddresses = new Set(flow.get(\"used_addresses\") || []);\nlet addressToTry = context.get(\"address_attempt\") || STARTING_ADDRESS;\n\nif (msg.topic === \"address_claim_retry\") {\n  addressToTry--;\n  node.warn(`Lost address conflict. Trying next address: ${addressToTry}`);\n}\n\nwhile (usedAddresses.has(addressToTry) && addressToTry >= MIN_ADDRESS) {\n  addressToTry--;\n  node.warn(`Address ${addressToTry + 1} is known to be in use, skipping to ${addressToTry}`);\n}\n\nif (addressToTry < MIN_ADDRESS) {\n  node.error(`Exhausted all addresses in the valid range (${STARTING_ADDRESS}-${MIN_ADDRESS}). Address claiming failed.`);\n  flow.set(\"claim_in_progress\", false);\n  return null;\n}\n\ncontext.set(\"address_attempt\", addressToTry);\n\n\n// --- Step 4: Build and Send the Claim Message ---\nconst DGN = \"EE00\";\nconst priority = 6;\nconst canIdNum = (priority << 26) | (parseInt(DGN, 16) << 8) | addressToTry;\nconst canIdHex = canIdNum.toString(16).padStart(8, '0').toUpperCase();\nconst data_payload = DEVICE_NAME;\nconst canMessage = `${canIdHex}#${data_payload}`;\n\nflow.set(\"claiming_address\", addressToTry);\nflow.set(\"claim_in_progress\", true);\nflow.set(\"our_device_name\", DEVICE_NAME);\n\nmsg.payload = canMessage;\nmsg.topic = \"can/send\";\nmsg.claiming_address = addressToTry;\n\nnode.log(`Attempting to claim address ${addressToTry} (0x${addressToTry.toString(16).toUpperCase()})`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 1060,
        "wires": [
            [
                "55071115a3fe7c2c",
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "55071115a3fe7c2c",
        "type": "delay",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 850,
        "y": 1140,
        "wires": [
            [
                "6423c433e099d2a5"
            ]
        ]
    },
    {
        "id": "4e46ba83df00a31b",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim monitor",
        "func": "// RV-C Address Claim Monitor Function\n// Assumes it ONLY receives decoded ADDRESS_CLAIMED messages (DGN EE00)\n// Compares device NAMEs to determine winner in case of conflict\n\nconst claimInProgress = flow.get(\"claim_in_progress\");\nif (!claimInProgress) {\n  return null; // Not in the claiming process\n}\n\nconst claimingAddress = flow.get(\"claiming_address\");\nconst ourDeviceName = flow.get(\"our_device_name\");\nconst competitorName = msg.payload.data_payload.toUpperCase();\nconst sourceAddressInt = parseInt(msg.payload.sourceAddress, 16);\n\n// Check if a message is for the same address we are trying to claim\nif (sourceAddressInt === claimingAddress) {\n  // First, verify this isn't our own message being echoed back.\n  // If the NAMEs are identical, it's our own claim. Ignore it and let the timer run.\n  if (competitorName === ourDeviceName) {\n    // This is our own message, not a real conflict.\n    return null;\n  }\n\n  // If we get here, it's a real conflict from a different device.\n  node.warn(`Address ${claimingAddress} conflict detected!`);\n  node.warn(`Our NAME: ${ourDeviceName}, Competitor NAME: ${competitorName}`);\n\n  // Compare NAMEs - Lower numerical value wins\n  const ourNameValue = BigInt(\"0x\" + ourDeviceName);\n  const competitorNameValue = BigInt(\"0x\" + competitorName);\n\n  if (ourNameValue < competitorNameValue) {\n    // WE WIN\n    node.warn(\n      `We WIN the conflict. Continuing to claim address ${claimingAddress}`,\n    );\n    return null;\n  } else {\n    // WE LOSE\n    node.warn(\n      `We LOSE the conflict. Cancelling timer and trying next address.`,\n    );\n    flow.set(\"claim_in_progress\", false);\n\n    const retryMsg = { topic: \"address_claim_retry\" };\n    const resetTimerMsg = { reset: true };\n\n    return [retryMsg, resetTimerMsg];\n  }\n}\n\n// If we reach here, it's a claim for a different address, so ignore it.\nreturn null;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 1140,
        "wires": [
            [
                "b846bc1605dae821"
            ],
            [
                "55071115a3fe7c2c"
            ]
        ]
    },
    {
        "id": "45414bacecada477",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "ADDRESS_CLAIMED",
        "mode": "link",
        "links": [
            "f01db5ebc3ae2e18"
        ],
        "x": 2020,
        "y": 400,
        "wires": [],
        "l": true
    },
    {
        "id": "f01db5ebc3ae2e18",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "ADDRESS_CLAIMED",
        "links": [
            "45414bacecada477"
        ],
        "x": 260,
        "y": 1140,
        "wires": [
            [
                "4e46ba83df00a31b"
            ]
        ],
        "l": true
    },
    {
        "id": "a2334b77d3764815",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "MQTT out: Retain FALSE",
        "mode": "link",
        "links": [
            "74329f13cbbc528a"
        ],
        "x": 1650,
        "y": 1060,
        "wires": [],
        "l": true
    },
    {
        "id": "6423c433e099d2a5",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Address claim success",
        "func": "// RV-C Address Claim Success Function\n// Called after 250ms timer expires - finalizes address claim if no conflict lost\n// Reference: RV-C Spec Section 3.3.2 - Source Address Claiming\n//\n// IMPORTANT: This does NOT send a second ADDRESS_CLAIMED message.\n// We already sent ADDRESS_CLAIMED at the start of the process.\n// Success = 250ms timer expires without losing a conflict.\n\n// Get the address we were trying to claim when this timer started\nconst claimedAddress = msg.claiming_address;\n\nif (claimedAddress === undefined || claimedAddress === null) {\n    node.error(\"No address to claim - timer message missing claiming_address\");\n    return null;\n}\n\n// Check if this timer is still valid (claim hasn't been cancelled by monitor)\nconst claimInProgress = flow.get(\"claim_in_progress\");\nif (!claimInProgress) {\n    // Claim was cancelled during the 250ms window (we lost a conflict)\n    node.warn(`Timer expired for address ${claimedAddress}, but claim was cancelled - ignoring`);\n    return null;\n}\n\n// Verify we're still trying to claim the same address\nconst currentClaimingAddress = flow.get(\"claiming_address\");\nif (currentClaimingAddress !== claimedAddress) {\n    node.warn(`Timer expired for address ${claimedAddress}, but we're now trying ${currentClaimingAddress} - ignoring stale timer`);\n    return null;\n}\n\n// SUCCESS! No conflict detected during the 250ms monitoring window\n// Store the claimed address to global context\nglobal.set(\"rvc_source_address\", claimedAddress);\n\n// Clear claiming flags\nflow.set(\"claim_in_progress\", false);\nflow.set(\"claiming_address\", null);\nflow.set(\"our_device_name\", null);\n\n//node.warn(`Successfully claimed address ${claimedAddress} (0x${claimedAddress.toString(16).toUpperCase()})`);\n//node.warn(`Address stored to global.rvc_source_address: ${claimedAddress}`);\n\n// Return null - No CAN message to send\n// We already broadcast ADDRESS_CLAIMED at the beginning of the process\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1140,
        "wires": [
            [
                "a2334b77d3764815",
                "73abad3deeed31e8",
                "695ef0ed6d78a244",
                "3f5eb271f702c8f3",
                "1e244bad0304bb74"
            ]
        ]
    },
    {
        "id": "1ac6e0fa1cbb3852",
        "type": "mqtt out",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT Out: Retain FALSE",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "80727e60a251c36c",
        "x": 730,
        "y": 500,
        "wires": []
    },
    {
        "id": "74329f13cbbc528a",
        "type": "link in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out: Retain FALSE",
        "links": [
            "a2334b77d3764815",
            "6aa079d768e1571c"
        ],
        "x": 270,
        "y": 500,
        "wires": [
            [
                "1ac6e0fa1cbb3852",
                "0e65ff3bc0a0795c"
            ]
        ],
        "l": true
    },
    {
        "id": "73abad3deeed31e8",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll dc_dimmer_3",
        "func": "// Polling Function for DC Dimmer\n// Requests DC_DIMMER_STATUS_3 (1FEDA)\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// Build the data payload\n// This is the DGN for DC_DIMMER_STATUS_3 (1FEDA), sent in little-endian format (least-significant byte first).\nconst data_payload = \"DAFE01FFFFFFFF\";\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${data_payload.toUpperCase()}`;\n\n//node.warn(`[Poll Lights] Sending global request for light status. CAN: ${msg.payload}`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 1140,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "695ef0ed6d78a244",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll locks",
        "func": "// Polling Function for Locks\n// Requests LOCK_STATUS (1FEE5)\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// Build the data payload\n// This is the DGN for LOCK_STATUS (1FEE5), sent in little-endian format (least-significant byte first).\nconst data_payload = \"E5FE01FFFFFFFF\";\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${data_payload.toUpperCase()}`;\n\n//node.warn(`[Poll Locks] Sending global request for lock status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 1180,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "3f5eb271f702c8f3",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll shades",
        "func": "// Polling Function for Shades\n// Requests WINDOW_SHADE_CONTROL_STATUS (1FEDE)\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254; // 0xFE\nconst PRIORITY = 6;       // Standard priority for requests (Included in 18EAFF)\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// The DGN for WINDOW_SHADE_CONTROL_STATUS\nconst REQUESTED_DGN = \"01FEDE\";\n\n// Build the data payload\n// The payload is the DGN being requested, sent in 3-byte little-endian format.\n// The remaining 5 bytes are padded with 0xFF.\nconst requestedDgnInt = parseInt(REQUESTED_DGN, 16);\nconst dataPayloadBytes = new Uint8Array(8);\ndataPayloadBytes.fill(0xFF); // Pad the entire payload with 0xFF first\ndataPayloadBytes[0] = requestedDgnInt & 0xFF;         // Byte 1: DE\ndataPayloadBytes[1] = (requestedDgnInt >> 8) & 0xFF;  // Byte 2: FE\ndataPayloadBytes[2] = (requestedDgnInt >> 16) & 0xFF; // Byte 3: 01\nconst data_payload_hex = Array.from(dataPayloadBytes).map(b => b.toString(16).padStart(2, '0')).join('');\n\n// Construct the CAN ID\n// Combine the DGN (which already includes Priority 6 and PGN 0xEAFF) with the Source Address.\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${data_payload_hex.toUpperCase()}`;\n\n// node.warn(`[Poll Shades] Sending global request for shade status. CAN: ${msg.payload}`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 1220,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "1e244bad0304bb74",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Clear unique values",
        "mode": "link",
        "links": [
            "21799a7e71f6c5b4",
            "54c6beb1daaa00bb",
            "84e908d542084d74",
            "99381e18a0d5f318",
            "b9f27aaa32da92c0",
            "d192b275aac0824e",
            "e8b62c33eab8e3ac",
            "893d80d1125057e8",
            "aa12f93df2087d62"
        ],
        "x": 1400,
        "y": 1380,
        "wires": [],
        "l": true
    },
    {
        "id": "07b8bcce03f19e8f",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Device discovery",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1110,
        "y": 1240,
        "wires": [
            [
                "73abad3deeed31e8",
                "695ef0ed6d78a244",
                "3f5eb271f702c8f3",
                "1e244bad0304bb74",
                "d3cc901dd2fbd359",
                "ba0c52ff61838986",
                "922f2738c2000150"
            ]
        ]
    },
    {
        "id": "463dfbbef66b51c2",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "Otherwsie dgnName",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2020,
        "y": 820,
        "wires": []
    },
    {
        "id": "d3cc901dd2fbd359",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll water pump",
        "func": "// Polling Function for Water Pump\n// Requests WATER_PUMP_STATUS (1FFB3)\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// Build the data payload\n// This is the DGN for WATER_PUMP_STATUS (1FFB3), sent in little-endian format (least-significant byte first).\nconst data_payload = \"B3FB01FFFFFFFF\";\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${data_payload.toUpperCase()}`;\n\n//node.warn(`[Poll Water Pump] Sending global request for water pump status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 1260,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "ba0c52ff61838986",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll autofill",
        "func": "// Polling Function for Autofill\n// Requests AUTOFILL_STATUS (1FFB1)\n\n// --- Configuration ---\n// The source address of this Node-RED system.\nconst SOURCE_ADDRESS = global.get(\"rvc_source_address\") || 254;\nconst PRIORITY = 6;       // Standard priority for requests\nconst DGN = \"18EAFF\";     // DGN for a broadcast request message\n\n// Build the data payload\n// This is the DGN for AUTOFILL_STATUS (1FFB1), sent in little-endian format (least-significant byte first).\nconst data_payload = \"B1FB01FFFFFFFF\";\n\n// Construct the CAN ID\nconst dgnInt = parseInt(DGN, 16);\nconst canIdInt = (dgnInt << 8) | SOURCE_ADDRESS;\nconst canIdHex = canIdInt.toString(16).padStart(8, '0');\n\n// Construct the final output message in CAN bus format\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex.toUpperCase()}#${data_payload.toUpperCase()}`;\n\n//node.warn(`[Poll AutoFill] Sending global request for autofill status. CAN: ${msg.payload}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 1300,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "17b175c97c0551d4",
        "type": "inject",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2030,
        "y": 500,
        "wires": [
            [
                "9f47dc231ecd50cd"
            ]
        ]
    },
    {
        "id": "9f47dc231ecd50cd",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "Reset function",
        "func": "flow.set(\"uniqueProprietary\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2300,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "5968e8ee034f8751",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "New Proprietary DGN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2320,
        "y": 560,
        "wires": []
    },
    {
        "id": "3d5ce3e925ee2f04",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "9c4e4196e56cc471",
        "name": "Unique proprietary",
        "func": "// Unique Filter for proprietary DGNs\n\n// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueProprietary = flow.get(\"uniqueProprietary\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgn);\n\n// Check if it's a new unique message\nif (!uniqueProprietary.includes(newMsgStr)) {\n    uniqueProprietary.push(newMsgStr);\n    flow.set(\"uniqueProprietary\", uniqueProprietary);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 560,
        "wires": [
            [
                "5968e8ee034f8751"
            ]
        ]
    },
    {
        "id": "0e65ff3bc0a0795c",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "MQTT out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 460,
        "wires": []
    },
    {
        "id": "9e9b11b9441e51db",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/climate/+/set_mode",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 240,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "54cd7e4a8959a77c",
        "type": "mqtt in",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "HA in",
        "topic": "homeassistant/climate/+/set_preset_mode",
        "qos": "1",
        "datatype": "utf8",
        "broker": "80727e60a251c36c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 300,
        "wires": [
            [
                "64c5e5cfd4382453",
                "d34a8c1fd2cc4320"
            ]
        ]
    },
    {
        "id": "32add109922d428a",
        "type": "debug",
        "z": "292e70a6ba25b323",
        "g": "3c819b7900145438",
        "name": "can/raw",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 100,
        "wires": []
    },
    {
        "id": "922f2738c2000150",
        "type": "function",
        "z": "292e70a6ba25b323",
        "g": "8ef86a1c4b59d8e1",
        "name": "Poll Aqua-Hot",
        "func": "// Polling Function for AquaHot\n// Sends Engine OFF command to force response\n\nconst PGN_INT = 0xEF64;\nconst DA = 0x9F;\nconst PRIORITY = 6;\nconst CONTROL_BYTE = 0xAB;\nconst ENGINE_OFF_BYTE = 0x3F;\n\n// Calculate CAN ID (Results in 1AEF649F)\n// (P << 26) | (PGN << 8) | DA \nconst canIdInt = (PRIORITY << 26) | (PGN_INT << 8) | DA;\nconst canIdHex = canIdInt.toString(16).toUpperCase().padStart(8, '0');\n\n// Build Payload (AB3FFFFFFFFFFFFF)\nconst dataBytes = new Array(8).fill(0xFF);\ndataBytes[0] = CONTROL_BYTE;\ndataBytes[1] = ENGINE_OFF_BYTE;\nconst dataHex = dataBytes.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join('');\n\n// Set Message\nmsg.topic = \"can/send\";\nmsg.payload = `${canIdHex}#${dataHex}`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 1340,
        "wires": [
            [
                "a2334b77d3764815"
            ]
        ]
    },
    {
        "id": "4fa9b9fdc36c83da",
        "type": "link out",
        "z": "292e70a6ba25b323",
        "g": "f09f79586501cb0b",
        "name": "COMMAND out",
        "mode": "link",
        "links": [
            "00b1afc9a96aca8e"
        ],
        "x": 2000,
        "y": 360,
        "wires": [],
        "l": true
    },
    {
        "id": "b2cbbdbaab1fc227",
        "type": "inject",
        "z": "7ecdba18640c1184",
        "g": "081183d6c363e792",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 790,
        "y": 560,
        "wires": [
            [
                "f96e5b3b013a2b8f"
            ]
        ]
    },
    {
        "id": "f96e5b3b013a2b8f",
        "type": "function",
        "z": "7ecdba18640c1184",
        "g": "081183d6c363e792",
        "name": "Reset function",
        "func": "flow.set(\"uniqueCommand\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "bc59e15bf069f17d",
        "type": "debug",
        "z": "7ecdba18640c1184",
        "g": "081183d6c363e792",
        "name": "New COMMAND",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1070,
        "y": 620,
        "wires": []
    },
    {
        "id": "03744ec33f2e6776",
        "type": "function",
        "z": "7ecdba18640c1184",
        "g": "081183d6c363e792",
        "name": "Unique COMMAND",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueCommand = flow.get(\"uniqueCommand\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dgnName);\n\n// Check if it's a new unique message\nif (!uniqueCommand.includes(newMsgStr)) {\n    uniqueCommand.push(newMsgStr);\n    flow.set(\"uniqueCommand\", uniqueCommand);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 620,
        "wires": [
            [
                "bc59e15bf069f17d"
            ]
        ]
    },
    {
        "id": "86dc00dfc2dbcd9e",
        "type": "inject",
        "z": "7ecdba18640c1184",
        "d": true,
        "g": "54c9dde7767b8935",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 790,
        "y": 200,
        "wires": [
            [
                "4f86998be2551032"
            ]
        ]
    },
    {
        "id": "4f86998be2551032",
        "type": "function",
        "z": "7ecdba18640c1184",
        "d": true,
        "g": "54c9dde7767b8935",
        "name": "Reset function",
        "func": "global.set(\"uniqueDcDimmerCmd\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "0f09356f283bfae7",
        "type": "debug",
        "z": "7ecdba18640c1184",
        "d": true,
        "g": "54c9dde7767b8935",
        "name": "New DC_DIMMER cmd",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1090,
        "y": 260,
        "wires": []
    },
    {
        "id": "54bee06f72b5c1f5",
        "type": "function",
        "z": "7ecdba18640c1184",
        "d": true,
        "g": "54c9dde7767b8935",
        "name": "Unique DC_DIMMER cmd",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueDcDimmerCmd = global.get(\"uniqueDcDimmerCmd\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dataPayload);\n\n// Check if it's a new unique message\nif (!uniqueDcDimmerCmd.includes(newMsgStr)) {\n    uniqueDcDimmerCmd.push(newMsgStr);\n    global.set(\"uniqueDcDimmerCmd\", uniqueDcDimmerCmd);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 260,
        "wires": [
            [
                "0f09356f283bfae7"
            ]
        ]
    },
    {
        "id": "00b1afc9a96aca8e",
        "type": "link in",
        "z": "7ecdba18640c1184",
        "name": "COMMAND in",
        "links": [
            "4fa9b9fdc36c83da"
        ],
        "x": 230,
        "y": 360,
        "wires": [
            [
                "c063a09a82cdd204"
            ]
        ],
        "l": true
    },
    {
        "id": "c063a09a82cdd204",
        "type": "switch",
        "z": "7ecdba18640c1184",
        "name": "COMMAND",
        "property": "payload.dgnName",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "DC_DIMMER_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "GENERIC_INDICATOR_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WATER_PUMP_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "WINDOW_SHADE_CONTROL_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "LOCK_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AUTOFILL_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "FLOOR_HEAT_COMMAND",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "AQUAHOT_COMMAND",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 490,
        "y": 360,
        "wires": [
            [
                "54bee06f72b5c1f5"
            ],
            [
                "c95a503942e20c78"
            ],
            [],
            [],
            [],
            [],
            [],
            [],
            [
                "03744ec33f2e6776"
            ]
        ]
    },
    {
        "id": "738e5a8857696209",
        "type": "inject",
        "z": "7ecdba18640c1184",
        "g": "ea5519f0372a650f",
        "name": "Reset unique",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 790,
        "y": 380,
        "wires": [
            [
                "dc9f6facce21379f"
            ]
        ]
    },
    {
        "id": "dc9f6facce21379f",
        "type": "function",
        "z": "7ecdba18640c1184",
        "g": "ea5519f0372a650f",
        "name": "Reset function",
        "func": "global.set(\"uniqueGenericCmd\", []);\nreturn null;  // Nothing needs to go downstream\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "d825c1e1a2850fa5",
        "type": "debug",
        "z": "7ecdba18640c1184",
        "g": "ea5519f0372a650f",
        "name": "New GENERIC cmd",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 440,
        "wires": []
    },
    {
        "id": "c95a503942e20c78",
        "type": "function",
        "z": "7ecdba18640c1184",
        "g": "ea5519f0372a650f",
        "name": "Unique GENERIC cmd",
        "func": "// Retrieve existing messages from flow context, or initialize as empty array\nlet uniqueGenericCmd = global.get(\"uniqueGenericCmd\") || [];\n\nlet newMsgStr = JSON.stringify(msg.payload.dataPayload);\n\n// Check if it's a new unique message\nif (!uniqueGenericCmd.includes(newMsgStr)) {\n    uniqueGenericCmd.push(newMsgStr);\n    global.set(\"uniqueGenericCmd\", uniqueGenericCmd);\n\n    // Only return if new\n    return msg;\n}\n\n// Return nothing if duplicate\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 440,
        "wires": [
            [
                "d825c1e1a2850fa5"
            ]
        ]
    },
    {
        "id": "802228bc8d89d80a",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "sensor",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "black",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 120,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "a2d2ed96ff4615f9",
        "type": "function",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${type}_${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 160,
        "wires": [
            [
                "d38c75bc1474be23"
            ]
        ]
    },
    {
        "id": "d38c75bc1474be23",
        "type": "link out",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "MQTT out: Retain TRUE",
        "mode": "link",
        "links": [
            "f658418a7b9b4857"
        ],
        "x": 630,
        "y": 160,
        "wires": [],
        "l": true
    },
    {
        "id": "abd1e06a1927df6d",
        "type": "inject",
        "z": "222c995b7790b8de",
        "g": "04e375b0c463df72",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "switch",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "58",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 200,
        "wires": [
            [
                "a2d2ed96ff4615f9"
            ]
        ]
    },
    {
        "id": "68c09ec9b9f984fd",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "rv_link_aqua_hot_diesel_burner",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 360,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "da1b195a794a61f2",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete sensor",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "rv_link_aqua_hot_engine_pre_heat",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 540,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "356ca3617c50f06b",
        "type": "function",
        "z": "222c995b7790b8de",
        "name": "Delete HA entity",
        "func": "const type = msg.type;\nconst entityId = msg.entityId;\n\nconst discoveryTopic = `homeassistant/${type}/${entityId}/config`;\n\nmsg.topic = discoveryTopic;\nmsg.payload = \"\";   // empty payload\nmsg.retain = true;  // retain so broker overwrites the old config\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 380,
        "wires": [
            [
                "d38c75bc1474be23",
                "578d3f3784c2f9d1"
            ]
        ]
    },
    {
        "id": "578d3f3784c2f9d1",
        "type": "debug",
        "z": "222c995b7790b8de",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 380,
        "wires": []
    },
    {
        "id": "4c36d204a0dcb38f",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "rv_link_aqua_hot_ac_element_1",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 420,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "45cd9bd685e09007",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "light",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "rv_link_aqua_hot_ac_element_2",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 480,
        "wires": [
            [
                "356ca3617c50f06b"
            ]
        ]
    },
    {
        "id": "c6f1577708bfe9cd",
        "type": "inject",
        "z": "222c995b7790b8de",
        "name": "Delete switch",
        "props": [
            {
                "p": "type",
                "v": "switch",
                "vt": "str"
            },
            {
                "p": "entityId",
                "v": "floor_heat_3_schedule",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 270,
        "y": 600,
        "wires": [
            []
        ]
    }
]